const FRAMEBRXC = {
    helpers: {
        getElementObject: function(id, forceStructure = false){

            const getElementObject = FRAMEBRXC.vueGlobalProp.$_getElementObject;
            const getDynamicElementById = FRAMEBRXC.vueGlobalProp.$_getDynamicElementById;
        
            if (typeof getElementObject === 'function') {
                return getElementObject(id);
            } else if (typeof getDynamicElementById === 'function') {
                const obj = getDynamicElementById(id);
                if(obj && obj.hasOwnProperty('cid')){
                    return FRAMEBRXC.vueGlobalProp.$_getComponentElementById(obj.cid);
                } else {
                    return obj;
                }
            } else {
                console.error("No suitable function available to get element object.");
                return null;
            }
            
        },
        getFinalObject: function(skipClass = false, skipComponent = false, forceStructure = false){
            if(!skipClass && FRAMEBRXC.helpers.isClassActive()){
                return FRAMEBRXC.vueState.globalClasses.find(el => el.id === FRAMEBRXC.vueState.activeClass.id);
            }

            if(!skipComponent && FRAMEBRXC.vueState.activeElement && FRAMEBRXC.vueState.activeElement.hasOwnProperty('cid') 
            ){
                return FRAMEBRXC.vueGlobalProp.$_getComponentElementById(FRAMEBRXC.vueState.activeElement.cid);
            }
            if(typeof FRAMEBRXC.vueState.activeElement === "object" && FRAMEBRXC.vueState.activeElement.hasOwnProperty('id')){
                return FRAMEBRXC.helpers.getElementObject(FRAMEBRXC.vueState.activeElement.id, forceStructure)
            }

            return false;
        },
    }
};

window.ADMINBRXC = {
    globalSettings: {
        generalCats: [],
        keyboardShortcuts: {
        },
        disableIDStyles: false,
        integrations:{
        },
        elements : [],
        styleControls: [],
        customComponentsElements: [
            {id: "frejij", label: "My Custom Element", icon: "ti-ruler-alt", category: 'ijefii', elements: '[{"id":"lvhrck","name":"block","parent":0,"children":["sqnrrm","jalqyd"],"settings":{}},{"id":"sqnrrm","name":"image","parent":"lvhrck","children":[],"settings":{}},{"id":"jalqyd","name":"div","parent":"lvhrck","children":["hxppvz","rsrldr","rsefif"],"settings":{}},{"id":"hxppvz","name":"heading","parent":"jalqyd","children":[],"settings":{"text":"I am a heading"}},{"id":"rsrldr","name":"text-basic","parent":"jalqyd","children":[],"settings":{"text":"Here goes your text ... Select any part of your text to access the formatting toolbar.","tag":"p"}},{"id":"rsefif","name":"button","parent":"jalqyd","children":[],"settings":{"text":"I am a button","style":"primary"}}]'}
        ],
        customComponentsCategories: [
            {id: "ijefii", label: "My Category"}
        ],
    },
    vue: document.querySelector('.brx-body').__vue_app__,
    vueGlobalProp: document.querySelector('.brx-body').__vue_app__.config.globalProperties,
    vueState: document.querySelector('.brx-body').__vue_app__.config.globalProperties.$_state,
    cssVariables: [],
    cssVariablesHints: [],
    nestableElements: [],
    sassInstances: [],
    helpers: {
        tiIcons: ["ti-arrow-up", "ti-arrow-right", "ti-arrow-left", "ti-arrow-down", "ti-arrows-vertical", "ti-arrows-horizontal", "ti-angle-up", "ti-angle-right", "ti-angle-left", "ti-angle-down", "ti-angle-double-up", "ti-angle-double-right", "ti-angle-double-left", "ti-angle-double-down", "ti-move", "ti-fullscreen", "ti-arrow-top-right", "ti-arrow-top-left", "ti-arrow-circle-up", "ti-arrow-circle-right", "ti-arrow-circle-left", "ti-arrow-circle-down", "ti-arrows-corner", "ti-split-v", "ti-split-v-alt", "ti-split-h", "ti-hand-point-up", "ti-hand-point-right", "ti-hand-point-left", "ti-hand-point-down", "ti-back-right", "ti-back-left", "ti-exchange-vertical", "ti-wand", "ti-save", "ti-save-alt", "ti-direction", "ti-direction-alt", "ti-user", "ti-link", "ti-unlink", "ti-trash", "ti-target", "ti-tag", "ti-desktop", "ti-tablet", "ti-mobile", "ti-email", "ti-star", "ti-spray", "ti-signal", "ti-shopping-cart", "ti-shopping-cart-full", "ti-settings", "ti-search", "ti-zoom-in", "ti-zoom-out", "ti-cut", "ti-ruler", "ti-ruler-alt-2", "ti-ruler-pencil", "ti-ruler-alt", "ti-bookmark", "ti-bookmark-alt", "ti-reload", "ti-plus", "ti-minus", "ti-close", "ti-pin", "ti-pencil", "ti-pencil-alt", "ti-paint-roller", "ti-paint-bucket", "ti-na", "ti-medall", "ti-medall-alt", "ti-marker", "ti-marker-alt", "ti-lock", "ti-unlock", "ti-location-arrow", "ti-layout", "ti-layers", "ti-layers-alt", "ti-key", "ti-image", "ti-heart", "ti-heart-broken", "ti-hand-stop", "ti-hand-open", "ti-hand-drag", "ti-flag", "ti-flag-alt", "ti-flag-alt-2", "ti-eye", "ti-import", "ti-export", "ti-cup", "ti-crown", "ti-comments", "ti-comment", "ti-comment-alt", "ti-thought", "ti-clip", "ti-check", "ti-check-box", "ti-camera", "ti-announcement", "ti-brush", "ti-brush-alt", "ti-palette", "ti-briefcase", "ti-bolt", "ti-bolt-alt", "ti-blackboard", "ti-bag", "ti-world", "ti-wheelchair", "ti-car", "ti-truck", "ti-timer", "ti-ticket", "ti-thumb-up", "ti-thumb-down", "ti-stats-up", "ti-stats-down", "ti-shine", "ti-shift-right", "ti-shift-left", "ti-shift-right-alt", "ti-shift-left-alt", "ti-shield", "ti-notepad", "ti-server", "ti-pulse", "ti-printer", "ti-power-off", "ti-plug", "ti-pie-chart", "ti-panel", "ti-package", "ti-music", "ti-music-alt", "ti-mouse", "ti-mouse-alt", "ti-money", "ti-microphone", "ti-menu", "ti-menu-alt", "ti-map", "ti-map-alt", "ti-location-pin", "ti-light-bulb", "ti-info", "ti-infinite", "ti-id-badge", "ti-hummer", "ti-home", "ti-help", "ti-headphone", "ti-harddrives", "ti-harddrive", "ti-gift", "ti-game", "ti-filter", "ti-files", "ti-file", "ti-zip", "ti-folder", "ti-envelope", "ti-dashboard", "ti-cloud", "ti-cloud-up", "ti-cloud-down", "ti-clipboard", "ti-calendar", "ti-book", "ti-bell", "ti-basketball", "ti-bar-chart", "ti-bar-chart-alt", "ti-archive", "ti-anchor", "ti-alert", "ti-alarm-clock", "ti-agenda", "ti-write", "ti-wallet", "ti-video-clapper", "ti-video-camera", "ti-vector", "ti-support", "ti-stamp", "ti-slice", "ti-shortcode", "ti-receipt", "ti-pin2", "ti-pin-alt", "ti-pencil-alt2", "ti-eraser", "ti-more", "ti-more-alt", "ti-microphone-alt", "ti-magnet", "ti-line-double", "ti-line-dotted", "ti-line-dashed", "ti-ink-pen", "ti-info-alt", "ti-help-alt", "ti-headphone-alt", "ti-gallery", "ti-face-smile", "ti-face-sad", "ti-credit-card", "ti-comments-smiley", "ti-time", "ti-share", "ti-share-alt", "ti-rocket", "ti-new-window", "ti-rss", "ti-rss-alt", "ti-control-stop", "ti-control-shuffle", "ti-control-play", "ti-control-pause", "ti-control-forward", "ti-control-backward", "ti-volume", "ti-control-skip-forward", "ti-control-skip-backward", "ti-control-record", "ti-control-eject", "ti-paragraph", "ti-uppercase", "ti-underline", "ti-text", "ti-Italic", "ti-smallcap", "ti-list", "ti-list-ol", "ti-align-right", "ti-align-left", "ti-align-justify", "ti-align-center", "ti-quote-right", "ti-quote-left", "ti-layout-width-full", "ti-layout-width-default", "ti-layout-width-default-alt", "ti-layout-tab", "ti-layout-tab-window", "ti-layout-tab-v", "ti-layout-tab-min", "ti-layout-slider", "ti-layout-slider-alt", "ti-layout-sidebar-right", "ti-layout-sidebar-none", "ti-layout-sidebar-left", "ti-layout-placeholder", "ti-layout-menu", "ti-layout-menu-v", "ti-layout-menu-separated", "ti-layout-menu-full", "ti-layout-media-right", "ti-layout-media-right-alt", "ti-layout-media-overlay", "ti-layout-media-overlay-alt", "ti-layout-media-overlay-alt-2", "ti-layout-media-left", "ti-layout-media-left-alt", "ti-layout-media-center", "ti-layout-media-center-alt", "ti-layout-list-thumb", "ti-layout-list-thumb-alt", "ti-layout-list-post", "ti-layout-list-large-image", "ti-layout-line-solid", "ti-layout-grid4", "ti-layout-grid3", "ti-layout-grid2", "ti-layout-grid2-thumb", "ti-layout-cta-right", "ti-layout-cta-left", "ti-layout-cta-center", "ti-layout-cta-btn-right", "ti-layout-cta-btn-left", "ti-layout-column4", "ti-layout-column3", "ti-layout-column2", "ti-layout-accordion-separated", "ti-layout-accordion-merged", "ti-layout-accordion-list", "ti-widgetized", "ti-widget", "ti-widget-alt", "ti-view-list", "ti-view-list-alt", "ti-view-grid", "ti-upload", "ti-download", "ti-loop", "ti-layout-sidebar-2", "ti-layout-grid4-alt", "ti-layout-grid3-alt", "ti-layout-grid2-alt", "ti-layout-column4-alt", "ti-layout-column3-alt", "ti-layout-column2-alt", "ti-flickr", "ti-flickr-alt", "ti-instagram", "ti-google", "ti-github", "ti-facebook", "ti-dropbox", "ti-dropbox-alt", "ti-dribbble", "ti-apple", "ti-android", "ti-yahoo", "ti-trello", "ti-stack-overflow", "ti-soundcloud", "ti-sharethis", "ti-sharethis-alt", "ti-reddit", "ti-microsoft", "ti-microsoft-alt", "ti-linux", "ti-jsfiddle", "ti-joomla", "ti-html5", "ti-css3", "ti-drupal", "ti-wordpress", "ti-tumblr", "ti-tumblr-alt", "ti-skype", "ti-youtube", "ti-vimeo", "ti-vimeo-alt", "ti-twitter", "ti-twitter-alt", "ti-linkedin", "ti-pinterest", "ti-pinterest-alt", "ti-themify-logo", "ti-themify-favicon", "ti-themify-favicon-alt"],
        bpIcons: function(device){
            let svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="screen-1--screen-device-electronics-monitor-diplay-computer"><path id="Vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13 1.5H1c-0.276142 0 -0.5 0.22386 -0.5 0.5v7.5c0 0.27614 0.223858 0.5 0.5 0.5h12c0.2761 0 0.5 -0.22386 0.5 -0.5V2c0 -0.27614 -0.2239 -0.5 -0.5 -0.5Z" stroke-width="1"></path><path id="Vector_2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m6 10 -1 2.5" stroke-width="1"></path><path id="Vector_3" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 10 1 2.5" stroke-width="1"></path><path id="Vector_4" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 12.5h6" stroke-width="1"></path></g></svg></span>';
            if( device === "desktop-3") {
                svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="screen-2--screen-device-electronics-monitor-diplay-computer"><path id="Vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4.09052 12.5c0.10594 -0.6957 0.4577 -1.3305 0.99148 -1.7892C5.61578 10.2522 6.29625 10 7.00002 10s1.38424 0.2522 1.91802 0.7108c0.53379 0.4587 0.88554 1.0935 0.99149 1.7892" stroke-width="1"></path><path id="Vector_2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13 1.5H1c-0.276142 0 -0.5 0.22386 -0.5 0.5v7.5c0 0.27614 0.223858 0.5 0.5 0.5h12c0.2761 0 0.5 -0.22386 0.5 -0.5V2c0 -0.27614 -0.2239 -0.5 -0.5 -0.5Z" stroke-width="1"></path></g></svg></span>';
            }
            if( device === "desktop-2") {
                svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="screen-curve--screen-curved-device-electronics-monitor-diplay-computer"><path id="Vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12.93 10.8466c-3.93345 -0.5601 -7.92646 -0.5601 -11.85996 0 -0.070445 0.0099 -0.142209 0.0048 -0.210494 -0.0152 -0.068284 -0.02 -0.131516 -0.0544 -0.185471 -0.1007 -0.053954 -0.0464 -0.097388 -0.1038 -0.1274 -0.1683 -0.030011 -0.0645 -0.045909 -0.1347 -0.046631 -0.2058V1.99658c-0.000963 -0.07167 0.013809 -0.14267 0.043274 -0.20801 0.029465 -0.06534 0.072905 -0.12342 0.127258 -0.17015 0.054352 -0.04672 0.118293 -0.08095 0.187315 -0.10027 0.069021 -0.01933 0.141441 -0.02328 0.212149 -0.01157 3.93421 0.55001 7.9258 0.55001 11.85996 0 0.0699 -0.01156 0.1415 -0.00784 0.2098 0.01091s0.1317 0.05209 0.1859 0.09771c0.0542 0.04562 0.0978 0.10245 0.1279 0.16656 0.0301 0.06412 0.0459 0.134 0.0464 0.20482v8.36002c0.0008 0.072 -0.0141 0.1433 -0.0435 0.209 -0.0294 0.0657 -0.0726 0.1243 -0.1267 0.1718 -0.0541 0.0475 -0.1179 0.0827 -0.1869 0.1033 -0.069 0.0205 -0.1416 0.026 -0.2129 0.0159v0Z" stroke-width="1"></path><path id="Vector_2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 10.4297 7 12.5" stroke-width="1"></path><path id="Vector_3" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.5h5" stroke-width="1"></path></g></svg></span>';
            }
            if( device === "laptop") {
                svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="laptop--device-laptop-electronics-computer-notebook"><path id="Vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3.08 1.61H10.9136C11.4549 1.61 11.8936 2.0488 11.8936 2.59V7.98H2.1V2.59C2.1 2.002 2.492 1.61 3.08 1.61Z" stroke-width="1"></path><path id="Vector 3945" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M0.6957 11.2566L2.1 7.98H11.9L13.3042 11.2566C13.3477 11.3578 13.37 11.4667 13.37 11.5769C13.37 12.0259 13.0059 12.39 12.5569 12.39H1.4431C0.994 12.39 0.63 12.0259 0.63 11.5769C0.63 11.4667 0.6524 11.3578 0.6957 11.2566Z" stroke-width="1"></path></g></svg></span>';
            }
            if( device === "tablet-landscape") {
                svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="ipad-tablet-screen"><path id="vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12.2619 2H1.7381C1.05431 2 0.5 2.53256 0.5 3.18952v7.62098C0.5 11.4674 1.05431 12 1.7381 12h10.5238c0.6838 0 1.2381 -0.5326 1.2381 -1.1895V3.18952C13.5 2.53256 12.9457 2 12.2619 2Z" stroke-width="1"></path><path id="vector_2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4.33203 9.77588h5.33993" stroke-width="1"></path></g></svg></span>';
            }
            if( device === "tablet-portrait") {
                svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="one-handed-holding-tablet-handheld"><path id="Rectangle 2038" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.64593 1.23658C9.47168 1.089 9.24623 1 9 1H2c-0.55228 0 -1 0.44771 -1 1v9.0938c0 0.5522 0.44772 1 1 1h3.75" stroke-width="1"></path><path id="vector 296" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m12.3106 13 0.6383 -3.15223c0.0742 -0.36672 0.0675 -0.7452 -0.0197 -1.10906l-0.9088 -3.79119c-0.1682 -0.70134 -0.7013 -1.25797 -1.3954 -1.45681l-0.6221 -0.17821 -0.0002 5.23879c0 0.35407 -0.35839 0.59595 -0.68734 0.46392l-1.6994 -0.68209c-0.3105 -0.12463 -0.66467 -0.06608 -0.91839 0.15183 -0.3824 0.32842 -0.41818 0.90721 -0.07914 1.28012l1.24302 1.36723L8.89958 13" stroke-width="1"></path></g></svg></span>';
            }
            if( device === "phone-landscape") {
                svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="phone-landscape--android-phone-mobile-device-smartphone-iphone-landscape"><path id="Vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m13.5 10.5 0 -7c0 -0.55228 -0.4477 -1 -1 -1l-11 0c-0.552285 0 -1 0.44771 -1 1l0 7c0 0.5523 0.447714 1 1 1l11 0c0.5523 0 1 -0.4477 1 -1Z" stroke-width="1"></path><path id="Vector_2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m3 6.5 0 1" stroke-width="1"></path></g></svg></span>';
            }
            if( device === "phone-portrait") {
                svg = '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="phone-mobile-phone--android-phone-mobile-device-smartphone-iphone"><path id="Vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.5 0.5h-7c-0.55228 0 -1 0.447715 -1 1v11c0 0.5523 0.44772 1 1 1h7c0.5523 0 1 -0.4477 1 -1v-11c0 -0.552285 -0.4477 -1 -1 -1Z" stroke-width="1"></path><path id="Vector_2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6.5 11h1" stroke-width="1"></path></g></svg></span>';
            }
            return svg;
        },
        isComponentPanelOpen: function () {
            const activePanel = ADMINBRXC.vueState.activePanel === "element";
            const selector = !!document.querySelector('#bricks-panel-element.property, #bricks-panel-element.instance');
            return activePanel && selector;
        },
        getElementObject: function(id, forceStructure = false){

            const getElementObject = ADMINBRXC.vueGlobalProp.$_getElementObject;
            const getDynamicElementById = ADMINBRXC.vueGlobalProp.$_getDynamicElementById;
        
            if (typeof getElementObject === 'function') {
                return getElementObject(id);
            } else if (typeof getDynamicElementById === 'function') {
                const obj = getDynamicElementById(id);
                if(obj && obj.hasOwnProperty('cid') && !forceStructure){
                    return ADMINBRXC.vueGlobalProp.$_getComponentElementById(obj.cid);
                } else {
                    return obj;
                }
            } else {
                console.error("No suitable function available to get element object.");
                return null;
            }
            
        },
        getFinalObject: function(skipClass = false, skipComponent = false, forceStructure = false){
            if(!skipClass && ADMINBRXC.helpers.isClassActive()){
                return ADMINBRXC.vueState.globalClasses.find(el => el.id === ADMINBRXC.vueState.activeClass.id);
            }

            if(!skipComponent && ADMINBRXC.vueState.activeElement && ADMINBRXC.vueState.activeElement.hasOwnProperty('cid') 
            ){
                return ADMINBRXC.vueGlobalProp.$_getComponentElementById(ADMINBRXC.vueState.activeElement.cid);
            }
            if(typeof ADMINBRXC.vueState.activeElement === "object" && ADMINBRXC.vueState.activeElement.hasOwnProperty('id')){
                return ADMINBRXC.helpers.getElementObject(ADMINBRXC.vueState.activeElement.id, forceStructure)
            }

            return false;
        },
        getFinalSelector: function(){
            const dot = ADMINBRXC.helpers.isComponentActive() ? '.' : '#';
            const elementObj = ADMINBRXC.helpers.getFinalObject();
            return ADMINBRXC.helpers.isClassActive() ? `.${ADMINBRXC.vueState.activeClass.name}` : elementObj.settings.hasOwnProperty('_cssId') ? `${dot}${elementObj.settings._cssId}` : `${dot}brxe-${elementObj.id}`;
        },
            
        // Get keys settings divided by pseudo
        stylesByPseudo: function(settings){
            const arr = {};
            const hasPseudo = []
            const pseudos = ADMINBRXC.vueState.pseudoClasses;
            pseudos.forEach(pseudo => {
                const nestedArr = Object.keys(settings)
                    .filter(key => key && ADMINBRXC.helpers.isCSSControlKey(key.split(':')[0]) && key.includes(pseudo))
                    .sort();
                nestedArr.forEach(el => hasPseudo.push(el));
                arr[pseudo.replace(':', '')] = nestedArr
            })
            arr['no-pseudo'] = Object.keys(settings)
                .filter(key => key && ADMINBRXC.helpers.isCSSControlKey(key.split(':')[0]) && !hasPseudo.includes(key))
                .sort();
            return arr;
        },
        // Get unique keys settings divided by pseudo and
        uniqueKeysByPseudo: function(settings){
            arr = ADMINBRXC.helpers.stylesByPseudo(settings);
            for(const row of Object.keys(arr)){
                const newArr = arr[row].map(property => property.split(":")[0]);
                arr[row] = [...new Set(newArr)];
            }
            return arr;
        },
        // Global Colors
        isGlobalColorsTabActive: function(){
            if (Object.values(ADMINBRXC.globalSettings.themeSettingsTabs).includes("global-colors")) return true;
            return false;
        },
        // CSS Variables
        isCSSVariablesTabActive: function(option){
            if (Object.values(ADMINBRXC.globalSettings.themeSettingsTabs).includes("css-variables")) return true;
            return false;
        },
        // Classes & Styles
        isClassesAndStylesTabActive: function(option){
            if (Object.values(ADMINBRXC.globalSettings.themeSettingsTabs).includes("classes-and-styles")) return true
            return false;
        },
        // Builder Tweaks
        isBuilderTweaksTabActive: function(option){
            if (Object.values(ADMINBRXC.globalSettings.themeSettingsTabs).includes("builder-tweaks")) return true;
            return false;
        },
        // AI
        isAIActive: function(){
            if (Object.values(ADMINBRXC.globalSettings.themeSettingsTabs).includes("ai") ) return true;
            return false;
        },
        // Custom Elements
        isCustomElements: function(option){
            if (ADMINBRXC.helpers.isBuilderTweaksTabActive('elements') && Object.values(ADMINBRXC.globalSettings.defaultElementFeatures).includes(option) ) return true;
            return false;
        },
        isCSSControlKey: function(key){
            if(ADMINBRXC.CSScontrolKeys.includes(JSON.parse(JSON.stringify(key.split(":")[0]))) && !ADMINBRXC.excludedControlKeyFromCSS.includes(JSON.parse(JSON.stringify(key.split(":")[0])))){
                return true;
            }
            return false;
        },
        isClassActive: function(){
            const activeClass = ADMINBRXC.vueState.activeClass;
            if(activeClass && typeof activeClass === "object" && activeClass.hasOwnProperty('id')) return true;
            return false
        },
        isComponentActive: function(){
            if(!ADMINBRXC.vueState.hasOwnProperty('components')) return false;
            const activeComponent = ADMINBRXC.vueState.activeComponent;
            if (typeof activeComponent === "undefined"
                || activeComponent === false
                || activeComponent === "" 
                || !activeComponent.hasOwnProperty('id')) return false;
            return true;
        },
        getTemplateType: function(){
            const templateType = ADMINBRXC.vueState.templateType;
            if(templateType === "section" || templateType === "archive" || templateType === "error" || templateType === "popup" || templateType === "search" || !ADMINBRXC.vueState.hasOwnProperty(templateType)){
                return "content";
            } else {
                return templateType;
            }
        },
        clampBuilder: function(minFontSize, maxFontSize, minWidthPx = false, maxWidthPx = false) {
            const minViewportWidth = minWidthPx ? minWidthPx : 'var(--min-viewport)';
            const maxViewportWidth = maxWidthPx ? maxWidthPx : 'var(--max-viewport)';
            
            return `clamp(calc(1rem * (${minFontSize} / var(--base-font))), calc(1rem * ((((-1 * ${minViewportWidth}) / var(--base-font)) * ((${maxFontSize} - ${minFontSize}) / var(--base-font)) / ((${maxViewportWidth} - ${minViewportWidth}) / var(--base-font))) + (${minFontSize} / var(--base-font)))) + (((${maxFontSize} - ${minFontSize}) / var(--base-font)) / ((${maxViewportWidth} - ${minViewportWidth}) / var(--base-font)) * 100) * var(--clamp-unit), calc(1rem * (${maxFontSize} / var(--base-font))));`
             
        },
         isElementActive: function(){
            if(ADMINBRXC.vueState.activePanel === "element" && 
                (
                    (
                        ADMINBRXC.vueState.activeElement &&
                        ADMINBRXC.vueState.activeElement.hasOwnProperty('id')
                    ) || 
                    (
                        typeof ADMINBRXC.vueState.activeElement === "undefined" && 
                        ADMINBRXC.vueState.activeComponent &&
                        ADMINBRXC.vueState.activeComponent.hasOwnProperty('id')
                    )
                )
            ) return true
            return false;
         },
         isValidCSSClassName: function(className) {
            if (!/^[a-zA-Z_\-]/.test(className)) {
              return false;
            }
          
            if (!/^[a-zA-Z0-9_\-\s]*$/.test(className)) {
              return false;
            }
          
            return true;
        },
        createClassCategory: function(name){
            if(!name) return;
            if(ADMINBRXC.helpers.getClassCategoryIdByName(name.toLowerCase()) !== false) ADMINBRXC.vueGlobalProp.$_showMessage('ABORT: Category already exists!');
            ADMINBRXC.vueState.globalClassesCategories.push({
                id: ADMINBRXC.vueGlobalProp.$_generateId(),
                name: name,
            })
            ADMINBRXC.populateClassCategories();
        },
        checkClassName: function(classname, list = false){
            let format = classname.replaceAll('<span class="brxc_changes">', '');
            format = format.replaceAll('</span>', '')
            if(Array.from(ADMINBRXC.vueState.globalClasses).find(el => el && el.name === `${format}`)){
                if (list) return ADMINBRXC.helpers.checkClassName(`${classname}<span class="brxc_changes">-new</span>`, list);
                return ADMINBRXC.helpers.checkClassName(`${classname}-new`, list);
            } else {
                return `${classname}`;
            }
        },
        isFramework(id){
            if(id && id.startsWith('acss')) return true;
            return false;
        },
        setColorPrefix: function(name, isFramework){
            prefix = ADMINBRXC.globalSettings.generalCats.globalColorsPrefix
            if(prefix === '' || prefix === "0" || name.startsWith(prefix) || isFramework) return name;
            return `${prefix}-${name}`;
        },
        escapeHtmlSpecialChars: function(input) {
            const entityMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
                '/': '&#47;',
                '`': '&#96;',
                '!': '&#33;',
                '@': '&#64;',
                '#': '&#35;',
                '$': '&#36;',
                '%': '&#37;',
                '^': '&#94;',
                '*': '&#42;',
                '(': '&#40;',
                ')': '&#41;',
                '+': '&#43;',
                '=': '&#61;',
                '{': '&#123;',
                '}': '&#125;',
                '[': '&#91;',
                ']': '&#93;',
                '|': '&#124;',
                '\\': '&#92;',
                ':': '&#58;',
                ';': '&#59;',
                ',': '&#44;',
                '.': '&#46;',
                '?': '&#63;',
                '~': '&#126;'
            };
        
            return input.replace(/[&<>"'\/`!@#$%^*()+=\{\}\[\]|\\:;,.<>?~]/g, (char) => entityMap[char]);
        },
        formatForClasses: function(input){
            return input.trim().replaceAll(/[^a-zA-Z0-9_-]+/g, '-').toLowerCase();
        },
        checkBreakpointFormat: function(property){
            const bpSettings = Array.from(ADMINBRXC.vueState.breakpoints).find(el => el && el.key === ADMINBRXC.vueState.breakpointActive);
            if(bpSettings.key !== "desktop"){
                property += `:${bpSettings.key}`;
            }
            return property;
        },
        isVarActiveOnPage: function(colorRaw){
            // content
            const content = ADMINBRXC.helpers.getContent();
            let string = (content) ? JSON.stringify(content) : '';

            // check if colorRaw is active
            if(string.includes(colorRaw)) return true;

            // theme settings
            const themeSettings = ADMINBRXC.vueState.themeStyleSettings;
            string = (themeSettings) ? JSON.stringify(themeSettings) : '';

            // check if colorRaw is active
            if(string.includes(colorRaw)) return true;

            // active classes
            let cls = [];
            string = "";
            if (Array.isArray(content) && content.length > 0) {
                cls = content.reduce((accumulator, el) => {
                    if (
                        el.settings.hasOwnProperty('_cssGlobalClasses') &&
                        Array.isArray(el.settings._cssGlobalClasses) &&
                        el.settings._cssGlobalClasses.length > 0
                    ) {
                        accumulator.push(...el.settings._cssGlobalClasses);
                    }
                    return accumulator;
                }, cls);
            }
            cls = [...new Set(cls)];
            if(cls.length > 0){
                cls.forEach(el =>{
                    string += JSON.stringify(ADMINBRXC.vueGlobalProp.$_getGlobalClass(el));
                })
            }

            // check if colorRaw is active
            if(string.includes(colorRaw)) return true;

            return false;
        },
        setCursorToLastRowMinusOne: function(codeMirror) {
            const lineCount = codeMirror.lineCount();
            if(!lineCount) return;
            const lastLine = lineCount - 2;
            const getLine = codeMirror.getLine(lastLine);
            if(!getLine) return;
            const lastCh = getLine.length;
            codeMirror.setCursor({ line: lastLine, ch: lastCh });
        },
        replaceRWithRoot: function (codeMirror, event) {
            const self = this;
            const cursor = codeMirror.getCursor();
            const lineContent = codeMirror.getLine(cursor.line);
            const cursorPos = cursor.ch;
            let currentWord = codeMirror.getRange(...Object.values(codeMirror.findWordAt(cursor)));

            // r = %root%
            const precedingChar = cursorPos > 1 ? lineContent[cursorPos - 2] : ' ';
            const validPrecedingChars = [' ', '\t', '(', '[', '{'];

            if (cursorPos > 0 && lineContent[cursorPos - 1].toLowerCase() === 'r' && validPrecedingChars.includes(precedingChar)) {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 1] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%${pos}`, { line: cursor.line, ch: cursorPos - 1 }, cursor);

                if (lineContent[cursorPos - 1] === "R") {
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };

                    codeMirror.setCursor(newCursor);
                }

                return;
            }

            // rh = %root%:hover
            if (cursorPos > 1 && lineContent[cursorPos - 2].toLowerCase() === 'r' && lineContent[cursorPos - 1] === 'h') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 2] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%:hover${pos}`, { line: cursor.line, ch: cursorPos - 2 }, cursor);

                if((lineContent[cursorPos - 2] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }

                return;
            }

            // rb = %root%::before
            if (cursorPos > 1 && lineContent[cursorPos - 2].toLowerCase() === 'r' && lineContent[cursorPos - 1] === 'b') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 2] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%::before${pos}`, { line: cursor.line, ch: cursorPos - 2 }, cursor);

                if((lineContent[cursorPos - 2] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }

                return;
            }

            // ra = %root%::after
            if (cursorPos > 1 && lineContent[cursorPos - 2].toLowerCase() === 'r' && lineContent[cursorPos - 1] === 'a') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 2] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%::after${pos}`, { line: cursor.line, ch: cursorPos - 2 }, cursor);

                if((lineContent[cursorPos - 2] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            // rf = %root%:focus
            if (cursorPos > 1 && lineContent[cursorPos - 2].toLowerCase() === 'r' && lineContent[cursorPos - 1] === 'f') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 2] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%:focus${pos}`, { line: cursor.line, ch: cursorPos - 2 }, cursor);

                if((lineContent[cursorPos - 2] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            // rcf = %root%:first-child
            if (cursorPos > 2 && lineContent[cursorPos - 3].toLowerCase() === 'r' && lineContent[cursorPos - 2] === 'c' && lineContent[cursorPos - 1] === 'f') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 3] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%:first-child${pos}`, { line: cursor.line, ch: cursorPos - 3 }, cursor);

                if((lineContent[cursorPos - 3] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            // rcl = %root%:last-child
            if (cursorPos > 2 && lineContent[cursorPos - 3].toLowerCase() === 'r' && lineContent[cursorPos - 2] === 'c' && lineContent[cursorPos - 1] === 'l') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 3] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%:last-child${pos}`, { line: cursor.line, ch: cursorPos - 3 }, cursor);

                if((lineContent[cursorPos - 3] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            //rc1 = %root%:nth-child(1)
            if (currentWord.length > 2 && currentWord[0].toLowerCase() === "r" && currentWord[1].toLowerCase() === "c") {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 3] === "R") ? ' {\n\t\n}' : '';
                const word = codeMirror.findWordAt(cursor);

                codeMirror.replaceRange(`%root%:nth-child(${currentWord.substring(2)})${pos}`,word.anchor, word.head);

                if((currentWord[0] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            // rtf = %root%:first-of-type
            if (cursorPos > 2 && lineContent[cursorPos - 3].toLowerCase() === 'r' && lineContent[cursorPos - 2] === 't' && lineContent[cursorPos - 1] === 'f') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 3] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%:first-of-type${pos}`, { line: cursor.line, ch: cursorPos - 3 }, cursor);

                if((lineContent[cursorPos - 3] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            // rtl = %root%:last-of-type
            if (cursorPos > 2 && lineContent[cursorPos - 3].toLowerCase() === 'r' && lineContent[cursorPos - 2] === 't' && lineContent[cursorPos - 1] === 'l') {
                event.preventDefault();
                const pos = (lineContent[cursorPos - 3] === "R") ? ' {\n\t\n}' : '';

                codeMirror.replaceRange(`%root%:last-of-type${pos}`, { line: cursor.line, ch: cursorPos - 3 }, cursor);

                if((lineContent[cursorPos - 3] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            //rt1 = %root%:nth-of-type(1)
            if (currentWord.length > 2 && currentWord[0].toLowerCase() === "r" && currentWord[1].toLowerCase() === "t") {
                event.preventDefault();
                const pos = (currentWord[0] === "R") ? ' {\n\t\n}' : '';
                const word = codeMirror.findWordAt(cursor);

                codeMirror.replaceRange(`%root%:nth-of-type(${currentWord.substring(2)})${pos}`,word.anchor, word.head);

                if((currentWord[0] === "R")){
                    const newCursor = {
                        line: cursor.line + 1,
                        ch: cursorPos,
                    };
                    
                    codeMirror.setCursor(newCursor);
                }
                
                return;
            }

            //@media queuries
            if (currentWord.length > 1 && currentWord[0].toLowerCase() === "q" && currentWord[1].toLowerCase() === "c") {
                event.preventDefault();
                const mq = (ADMINBRXC.vueGlobalProp.$_isMobileFirst._value) ? 'min' : 'max';
                const word = codeMirror.findWordAt(cursor);
                const content = (currentWord[0] === "Q") ? '\n\t%root% {\n\t\t\n\t}\n' : '\n\t\n';
                const pos = (currentWord[0] === "Q") ? 2 : 1;

                codeMirror.replaceRange(`@media screen and (${mq}-width: ${ADMINBRXC.vueState.previewWidth}px) {${content}}`,word.anchor, word.head);

                const newCursor = {
                    line: cursor.line + pos,
                    ch: cursorPos,
                };
                
                codeMirror.setCursor(newCursor);
                return;

            } else if(currentWord.length > 1 && currentWord[0].toLowerCase() === "q"){
                event.preventDefault();
                const mq = (ADMINBRXC.vueGlobalProp.$_isMobileFirst._value) ? 'min' : 'max';
                const word = codeMirror.findWordAt(cursor);
                const content = (currentWord[0] === "Q") ? '\n\t%root% {\n\t\t\n\t}\n' : '\n\t\n';
                const pos = (currentWord[0] === "Q") ? 2 : 1;

                codeMirror.replaceRange(`@media screen and (${mq}-width: ${currentWord.substring(1)}) {${content}}`,word.anchor, word.head);

                const newCursor = {
                    line: cursor.line + pos,
                    ch: cursorPos,
                };
                
                codeMirror.setCursor(newCursor);
                return;
            }

            // Recipes
            const start = lineContent.slice(0, cursorPos).search(/[@\w-]+$/);
            const forwardSlice = lineContent.slice(cursorPos);
            const end = cursorPos + (forwardSlice.match(/^[\w-]+/) ? forwardSlice.match(/^[\w-]+/)[0].length : 0);
            currentWord = lineContent.slice(start, end);

            if(currentWord.length > 1 && currentWord[0] === "@"){
                event.preventDefault();
                const key = currentWord.substring(1);
                const obj = brxcAdvancedCSSDefault.find(el => el && el.typeLabel === "recipe" && el.label === key && el.contentCss && el.contentCss !== "");
                if(obj){
                    // Set value
                    let replacement = obj.contentCss;
                    codeMirror.replaceRange(replacement, { line: cursor.line, ch: start }, { line: cursor.line, ch: end });
                    codeMirror.setValue(css_beautify(codeMirror.getValue(), { indent_size: 2 }))

                    // Set cursor
                    const replacementLines = replacement.split('\n');
                    const lastLine = replacementLines.length - 1;
                    const lastCharPos = codeMirror.getLine(cursor.line + lastLine).length;
                    codeMirror.setCursor({ line: cursor.line + lastLine, ch: lastCharPos });
                    codeMirror.focus();
                }
                
            }
        },
        saveChanges: function(cat, modifiedClassId = false){
            if(Array.isArray(ADMINBRXC.vueState.unsavedChanges) && !ADMINBRXC.vueState.unsavedChanges.includes(cat)) ADMINBRXC.vueState.unsavedChanges.push(cat);

            // Modified Class Id
            if(modifiedClassId){
                if(!ADMINBRXC.vueState.globalChanges.modified.includes(modifiedClassId)) {
                    ADMINBRXC.vueState.globalChanges.modified.push(modifiedClassId);
                }
            }
        },
        createTarget: function (target){
            const bpSettings = Array.from(ADMINBRXC.vueState.breakpoints).find(el => el && el.key === ADMINBRXC.vueState.breakpointActive);
            if(bpSettings.key !== "desktop"){
                target += `:${bpSettings.key}`;
            }
            return target;
        },
        createTargetWithPseudo: function (target){
            const bpSettings = Array.from(ADMINBRXC.vueState.breakpoints).find(el => el && el.key === ADMINBRXC.vueState.breakpointActive);
            if(bpSettings.key !== "desktop"){
                target += `:${bpSettings.key}`;
            }
            if(ADMINBRXC.vueState.pseudoClassActive !== ''){
                target += ADMINBRXC.vueState.pseudoClassActive;
            }
            return target;
        },
        checkHigherBreakpoint: function(target, type){
            const currentBp = Array.from(ADMINBRXC.vueState.breakpoints).find(el => el && el.key === ADMINBRXC.vueState.breakpointActive);
            let indexBp = ADMINBRXC.vueState.breakpoints.indexOf(currentBp);
            let obj;
            type === "element" ? obj = ADMINBRXC.vueState.activeElement : obj = ADMINBRXC.vueState.activeClass;
            if (!obj || !obj.hasOwnProperty('settings')) return false;

            function checkBp(index){
                if(index - 1 === -1) return false;
                const key = ADMINBRXC.vueState.breakpoints[index - 1].key;
                const finalTarget = key === "desktop" ? target : `${target}:${key}`;
                if(obj.settings.hasOwnProperty(finalTarget)) {
                    return finalTarget;
                } else {
                    return checkBp(index - 1);
                }
            }
            return checkBp(parseInt(indexBp));

        },
        setActiveItem: function(selectors, event){
            const li = document.querySelectorAll(selectors);
            if(!li || li.length < 1) return; 
            const isActive = event.target.classList.contains('active');
            li.forEach(el => {
                el.classList.remove('active');
            })
            if(!isActive) {
                event.target.classList.add('active')
                return true;
            } else {
                ADMINBRXC.structureHelperStates.activeFilter = false;
                ADMINBRXC.structureHelperStates.filterArr = [];
                ADMINBRXC.setStructureHelper();
                return false;
            }
        },
        isThemeVariableActive: function(){
            if(ADMINBRXC.helpers.isCSSVariablesTabActive() && Array.isArray(ADMINBRXC.globalSettings.generalCats.cssVariables) && ADMINBRXC.globalSettings.generalCats.cssVariables.includes('theme-variables')) return true;
            return false;
        },
        themeHasVariables: function(){
            if(ADMINBRXC.vueState.themeStyleSettings && ADMINBRXC.vueState.themeStyleSettings.hasOwnProperty('general') && ADMINBRXC.vueState.themeStyleSettings.general.hasOwnProperty('_cssVariables')) return true;
            return false;
        },
        createThemeVariable: function(){
            if(!ADMINBRXC.vueState.themeStyleSettings.hasOwnProperty('general')) ADMINBRXC.vueState.themeStyleSettings.general = {};
            if(!ADMINBRXC.vueState.themeStyleSettings.general.hasOwnProperty('_cssVariables')) ADMINBRXC.vueState.themeStyleSettings.general._cssVariables = [];
        },
        getComponentClasses: function(tempClasses = [], id){
            const obj = ADMINBRXC.helpers.getElementObject(id);
            if(obj.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(obj.settings._cssGlobalClasses) && obj.settings._cssGlobalClasses.length > 0){
                obj.settings._cssGlobalClasses.forEach(el => {
                    if(!tempClasses.includes(el)) tempClasses.push(el);
                })
            }
            if(obj.hasOwnProperty('children') && Array.isArray(obj.children) && obj.children.length > 0){
                obj.children.forEach(el =>{
                    ADMINBRXC.helpers.getComponentClasses(tempClasses, el);
                })
            }

            return JSON.parse(JSON.stringify(tempClasses));
        },
        getComponentElements: function(content = [], id){
            const obj = ADMINBRXC.helpers.getElementObject(id);
            content.push(obj);
            if(obj.hasOwnProperty('children') && Array.isArray(obj.children) && obj.children.length > 0){
                obj.children.forEach(el =>{
                    ADMINBRXC.helpers.getComponentElements(content, el);
                })
            }

            return content;
        },
        hasGlobalClass: function(id){
            const el = ADMINBRXC.helpers.getElementObject(id);
            if(el && el.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.length > 0) return true;
            return false;
        },
        removeTrailingNewlines: function(String) {
            const pattern = /\n+$/;
            return String.replace(pattern, '');
        },
        keyMatchBreakpoint: function(key, bpKey){
            if(bpKey === "desktop"){
                let found = false;
                ADMINBRXC.vueState.breakpoints.forEach(el => {
                    if(el.key !== "desktop" && key.indexOf(`:${el.key}`) > -1) found = true;
                })

                if(found){
                    return false;
                } else {
                    return true;
                }
            } else {
                if(key.indexOf(`:${bpKey}`) > -1) return true;
            }
            
            return false;
        },

        keyMatchPseudo: function(key, pseudo){
            if(pseudo === ""){
                let found = false;
                ADMINBRXC.vueState.pseudoClasses.forEach(el => {
                    if(el !== "" && key.indexOf(`${el}`) > -1) found = true;
                })

                if(found){
                    return false;
                } else {
                    return true;
                }
            } else {
                if(key.indexOf(`${pseudo}`) > -1) return true;
            }
            
            return false;
        },
        getClassKeysFromGlobalSettings: function(classesIds) {
            let classesKeys = [];
            
            classesIds.forEach((id) => {
                const globalClass = ADMINBRXC.vueGlobalProp.$_getGlobalClass(id);
    
                if (typeof globalClass !== "undefined" && globalClass.hasOwnProperty("settings")) {
                    const settings = globalClass.settings;
    
                    for (const key in settings) {
                        if (key.startsWith("_") && settings[key] !== "") classesKeys.push(key);
                    }
                }
            });
            
            return [...new Set(classesKeys)];
        },
        easeInQuad: function(x){
            return x * x;
        },
        rgbStringToArray: function(rgbString){
            const rgbValues = rgbString.match(/\d+/g);
            return rgbValues.map(Number);
        },
        getElementTag: function(obj){
            let tag;
            if(!bricksData.elements[obj.name]) return false;
            if(typeof obj !== "undefined" && obj.name === "button" && obj.settings.hasOwnProperty('link') && typeof obj.settings.link === "object"){
                tag = "a";
            } else if (typeof obj !== "undefined" && obj.name === "image" && obj.hasOwnProperty('settings') && !obj.settings.hasOwnProperty('tag') ) {
                tag = "img";
            } else if (typeof obj !== "undefined" && obj.name === "image" && obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('tag') ) {
                tag = `${obj.settings.tag} > img`;
            } else if (typeof obj !== "undefined" && obj.name === "code" && obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('noRoot') && obj.settings.noRoot === true) {
                tag = "none"
            } else if (typeof obj !== "undefined" && obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('tag') && obj.settings.tag === "custom" && obj.settings.hasOwnProperty('customTag')) {
                tag = obj.settings.customTag
            } else if (typeof obj !== "undefined" && obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('tag')) {
                tag = obj.settings.tag
            } else {
                if(!bricksData.elements[obj.name].hasOwnProperty('tag')) return;
                tag = bricksData.elements[obj.name].tag
            }
            return tag;
        },
        getClassCategoryNameById: function(id){
            const obj = Array.from(ADMINBRXC.vueState.globalClassesCategories).find(el => el && el.id === id);
            if(!obj) return false;
            return obj.name;
        },
        getClassCategoryObjById: function(id){
            const obj = Array.from(ADMINBRXC.vueState.globalClassesCategories).find(el => el && el.id === id);
            if(!obj) return false;
            return obj;
        },
        getClassCategoryIdByName: function(name){
            const obj = Array.from(ADMINBRXC.vueState.globalClassesCategories).find(el => el && el.name.toLowerCase() === name.toLowerCase());
            if(!obj) return false;
            return obj.id;
        },
        getClassCategoryObjByName: function(name){
            const obj = Array.from(ADMINBRXC.vueState.globalClassesCategories).find(el => el && el.name.toLowerCase() === name.toLowerCase());
            if(!obj) return false;
            return obj;
        },
        getQueryCategoryNameById: function(id){
            const obj = Array.from(ADMINBRXC.globalSettings.generalCats.queryManagerCats).find(el => el && el.id === id);
            if(!obj) return false;
            return obj.name;
        },
        getQueryCategoryObjById: function(id){
            const obj = Array.from(ADMINBRXC.globalSettings.generalCats.queryManagerCats).find(el => el && el.id === id);
            if(!obj) return false;
            return obj;
        },
        getQueryCategoryIdByName: function(name){
            const obj = Array.from(ADMINBRXC.globalSettings.generalCats.queryManagerCats).find(el => el && el.name.toLowerCase() === name.toLowerCase());
            if(!obj) return false;
            return obj.id;
        },
        getQueryCategoryObjByName: function(name){
            const obj = Array.from(ADMINBRXC.globalSettings.generalCats.queryManagerCats).find(el => el && el.name.toLowerCase() === name.toLowerCase());
            if(!obj) return false;
            return obj;
        },
        getAdvancedCSSObjByName: function(label){
            const obj = Object.entries(brxcAdvancedCSSDefault).find(([key,o]) => o && o.label === label);
            if(!obj) return false;
            return obj;
        },
        convertToPhpArrowFunction: function(jsonString) {
            const jsonObject = JSON.parse(jsonString);
            const indentedPhpString = JSON.stringify(jsonObject, null, 4)
                .replace(/(?<!")\{/g, '[')
                .replace(/\}(?!\")/g, ']')
                .replace(/"([^"]+)":/g, '"$1" =>');

            return `return ${indentedPhpString};`;
        },
        // convertToPhpArrowFunction: function(jsonString) {
        //     const jsonObject = JSON.parse(jsonString);
        //     const indentedPhpString = JSON.stringify(jsonObject, null, 4)
        //         .replace(/(\{)/g, '[')  // Replace all `{` with `[`
        //         .replace(/(\})/g, ']')  // Replace all `}` with `]`
        //         .replace(/"([^"]+)":/g, '"$1" =>'); // Convert JSON keys to PHP associative array keys
        
        //     return `return ${indentedPhpString};`;
        // },
        isValidUrl: function(urlString){
            var urlPattern = new RegExp('^(https?:\\/\\/)?' + // validate protocol (http or https)
                '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // validate domain name
                '((\\d{1,3}\\.){3}\\d{1,3}))' + // validate OR ip (v4) address
                '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' + // validate port and path
                '(\\?[;&a-z\\d%_.~+=-]*)?' + // validate query string
                '(\\#[-a-z\\d_]*)?$', 'i'); // validate fragment locator
            return !!urlPattern.test(urlString);
        },
        getGlobalVariableNameById: function(id){
            const arr = ADMINBRXC.helpers.isThemeVariableActive() && ADMINBRXC.helpers.themeHasVariables() ? ADMINBRXC.vueState.globalVariables.concat(ADMINBRXC.vueState.themeStyleSettings.general._cssVariables) : ADMINBRXC.vueState.globalVariables;
            const obj = Array.from(arr).find(el => el && el.id === id);
            if(!obj || !obj.hasOwnProperty('name')) return false;
            return obj.name;
        },
        getGlobalVariableIdByName: function(name){
            const arr = ADMINBRXC.helpers.isThemeVariableActive() && ADMINBRXC.helpers.themeHasVariables() ? ADMINBRXC.vueState.globalVariables.concat(ADMINBRXC.vueState.themeStyleSettings.general._cssVariables) : ADMINBRXC.vueState.globalVariables;
            const obj = Array.from(arr).find(el => el && el.name === name);
            if(!obj || !obj.hasOwnProperty('id')) return false;
            return obj.id;
        },
        getGlobalVariableObjById: function(id){
            const arr = ADMINBRXC.helpers.isThemeVariableActive() && ADMINBRXC.helpers.themeHasVariables() ? ADMINBRXC.vueState.globalVariables.concat(ADMINBRXC.vueState.themeStyleSettings.general._cssVariables) : ADMINBRXC.vueState.globalVariables;
            const obj = Array.from(arr).find(el => el && el.id === id);
            if(!obj) return false;
            return obj;
        },
        getGlobalVariableCategoryNameById: function(id){
            const obj = Array.from(ADMINBRXC.vueState.globalVariablesCategories).find(el => el && el.id === id);
            if(!obj || !obj.hasOwnProperty('name')) return false;
            return obj.name;
        },
        getGlobalVariableCategoryIdByName: function(name){
            const obj = Array.from(ADMINBRXC.vueState.globalVariablesCategories).find(el => el && el.name.toLowerCase() === name.toLowerCase());
            if(!obj || !obj.hasOwnProperty('id')) return false;
            return obj.id;
        },
        getGlobalVariableCategoryObjById: function(id){
            const obj = Array.from(ADMINBRXC.vueState.globalVariablesCategories).find(el => el && el.id === id);
            if(!obj) return false;
            return obj;
        },
        getGlobalVariableCategoryObjByName: function(name){
            const obj = Array.from(ADMINBRXC.vueState.globalVariablesCategories).find(el => el && el.name.toLowerCase() === name.toLowerCase());
            if(!obj) return false;
            return obj;
        },
        getRootFontSize: function(){
            return parseInt(window.getComputedStyle(FRAMEBRXC.content.querySelector('html')).getPropertyValue('font-size').replace('px',''));
        },
        getCustomComponentObjById: function(id){
            const obj = Array.from(ADMINBRXC.customComponentStates.defaultElements.concat(ADMINBRXC.globalSettings.customComponentsElements)).find(el => el && el.id === id);
            if(!obj) return false;
            return obj;
        },
        getCustomComponentCatObjById: function(id){
            const obj = Array.from(ADMINBRXC.customComponentStates.defaultCategory.concat(ADMINBRXC.globalSettings.customComponentsCategories)).find(el => el && el.id === id);
            if(!obj) return false;
            return obj;
        },
        getCustomComponentCatObjByName: function(name){
            const obj = Array.from(ADMINBRXC.customComponentStates.defaultCategory.concat(ADMINBRXC.globalSettings.customComponentsCategories)).find(el => el && el.label.toLowerCase() === name.toLowerCase());
            if(!obj) return false;
            return obj;
        },
        isVariableUncategorized: function(varObj){
            if(!varObj || !varObj.hasOwnProperty('category')) return true;
            const catObj = Array.from(ADMINBRXC.vueState.globalVariablesCategories).find(el => el && el.id === varObj.category);
            if(!catObj) return true;
            return false;

        },
        isClassUncategorized: function(varObj){
            if(!varObj || !varObj.hasOwnProperty('category')) return true;
            const catObj = Array.from(ADMINBRXC.vueState.globalClassesCategories).find(el => el && el.id === varObj.category);
            if(!catObj) return true;
            return false;

        },
        isCustomComponentUncategorized: function(varObj){
            if(!varObj || !varObj.hasOwnProperty('category')) return true;
            const catObj = Array.from(ADMINBRXC.customComponentStates.defaultCategory.concat(ADMINBRXC.globalSettings.customComponentsCategories)).find(el => el && el.id === varObj.category);
            if(!catObj) return true;
            return false;

        },
        moveArr: function (arr, from, to, on = 1) {
            return arr.splice(to, 0, ...arr.splice(from, on)), arr;
        },
        elementHasStyle: function(obj) {
            return obj && Object.keys(obj).some(key => ADMINBRXC.helpers.isCSSControlKey(key.split(':')[0]));
        },
        elementHasClass: function(obj) {
            if (!obj) return false;
            if (obj._cssClasses && obj._cssClasses.length > 0) return true;
            if (obj._cssGlobalClasses && Array.isArray(obj._cssGlobalClasses) && obj._cssGlobalClasses.length > 0) {
                return obj._cssGlobalClasses.some(cls => ADMINBRXC.vueGlobalProp.$_getGlobalClass(cls));
            }
            return false;
        },
        createTagBtn: function(sibling, tag, optionType, options, id){
            const wrapper = document.createElement('div');;
            wrapper.setAttribute("class", "brxc-tag-btn-wrapper");
            const btn = document.createElement('button')
            btn.setAttribute('class', 'brxc-tag-btn')
            if (options === false) {
                btn.classList.add('red');
            } 
            if(ADMINBRXC.vueState.brxc.tagsView === 'developer') {
                const fn = id === ADMINBRXC.structureStates.activeDropdown ? `ADMINBRXC.vueState.rerenderControls = Date.now()` : `ADMINBRXC.activateTagManagerDropdown('${id}')`;
                btn.setAttribute('onClick', fn);
            }
            btn.textContent = tag
            wrapper.appendChild(btn);
            
            const elementObj = ADMINBRXC.helpers.getFinalObject(true);
            if(ADMINBRXC.vueState.brxc.tagsView === 'developer' && id === elementObj?.id) {
                const existingBtn = btn.querySelector("ul.dropdown");
                if(existingBtn){
                    return existingBtn.remove();
                }
                if(ADMINBRXC.structureStates.activeDropdown && ADMINBRXC.structureStates.activeDropdown === id){
                    ul = document.createElement("ul");
                    ul.setAttribute('class', 'dropdown')
                    if (optionType === "select" && options !== false && typeof options === "object") {
                        options = Object.entries(options);
                        for(let i = 0; i<options.length + 1; i++){
                            const li = document.createElement('li');
                            li.setAttribute('class', 'hover');
                            li.setAttribute('data-id', id);
                            if(i === 0){
                                 li.innerHTML = `<input type="text" placeholder="Type an HTML tag and hit ENTER"/ value="" onkeydown="ADMINBRXC.setCustomTagInStructurePanel(this, event, 'select')"/>`
                            } else {
                                li.setAttribute('onClick', `ADMINBRXC.setTagInStructurePanel(this.dataset.id, '${options[i-1][0]}')`)
                                li.textContent = options[i-1][1];
                            }
                            ul.appendChild(li)
                        }
                    } else if(optionType === "text"){
                        const li = document.createElement('li');
                            li.setAttribute('class', 'hover');
                            li.setAttribute('data-id', id);
                            li.innerHTML = `<input type="text" placeholder="Type an HTML tag and hit ENTER"/ value="" onkeydown="ADMINBRXC.setCustomTagInStructurePanel(this, event, 'text')"/>`
                            ul.appendChild(li)
                    } else {
                        const li = document.createElement('li');
                        li.setAttribute('class', 'no-hover');
                        li.innerHTML = `<div data-control="info">The HTML tag of this element cannot be changed.</div>`;
                        ul.appendChild(li)
                    }
                    wrapper.appendChild(ul);
                }
            }
            sibling.after(wrapper);
            const newInput = wrapper.querySelector('ul.dropdown input[type="text"]');
            if(newInput) {
                newInput.focus();
                newInput.setSelectionRange(0, newInput.value.length)
            }
        },
        convertCSSToVariables: function (cssString, variableSelector = ':root') {
            const variableMap = new Map();
            const propertyCounters = new Map();

            function createVariableName(property, value) {
                let baseName = property.replace(/[^a-zA-Z0-9-]/g, '');
                let variableName = `--${baseName}`;
                
                const key = `${property}:${value.trim()}`;
                
                if (variableMap.has(key)) {
                return variableMap.get(key);
                }

                if (propertyCounters.has(baseName)) {
                const counter = propertyCounters.get(baseName) + 1;
                propertyCounters.set(baseName, counter);
                variableName = `--${baseName}-${counter}`;
                } else {
                propertyCounters.set(baseName, 1);
                }

                variableMap.set(key, variableName);
                return variableName;
            }

            const blockRegex = /([^{]+)\{([^}]+)\}/g;
            const propertyRegex = /([a-zA-Z-]+)\s*:\s*([^;\n]+)/g;

            const convertedBlocks = [];
            const variables = new Map();

            let match;
            while ((match = blockRegex.exec(cssString)) !== null) {
                const [fullMatch, selector, block] = match;
                const convertedBlock = block.replace(propertyRegex, (propMatch, property, value) => {
                
                // Ignore existing variables & scoped variables
                if (property.startsWith('--') || value.trim().startsWith('var(--')) {
                    return propMatch;
                }

                const variableName = createVariableName(property, value);
                variables.set(variableName, value.trim());
                return `${property}: var(${variableName})`;
                });

                convertedBlocks.push(`${selector.trim()} {${convertedBlock}}`);
            }

            const sortedVariables = Array.from(variables.entries()).sort((a,b) => a[0].localeCompare(b[0]));
            const variableDeclarations = sortedVariables
                .map(([name, value]) => `  ${name}: ${value};`)
                .join('\n');

            const variableBlock = `${variableSelector} {\n${variableDeclarations}\n}`;

            return `${variableBlock}\n\n${convertedBlocks.join('\n\n')}`;
        },
        resetStyles: function(obj){
            // Remove styles on ID
            for (const [key, value] of Object.entries(obj.settings)){
                if (ADMINBRXC.helpers.isCSSControlKey(key)) delete obj.settings[key];
            }
        },
        isValidFileUrl(url){
            try {
                const parsedUrl = new URL(url);
                return parsedUrl;
            } catch (error) {
                return false;
            }
        },
        getFilenameURLFromUrl: function(url){
            const parsedUrl = ADMINBRXC.helpers.isValidFileUrl(url);
            if(!parsedUrl){
                return ADMINBRXC.globalSettings.placeholderImg;
            } else {
                return url;
            }
        },
        getFilenameFromUrl: function(url) {
            const parsedUrl = ADMINBRXC.helpers.isValidFileUrl(url);
            if(!parsedUrl){
                return 'placeholder-image-png';
            } else {
                const path = parsedUrl.pathname;
                const filename = path.split('/').pop();
                
                return filename;
            }
        },
        elementTagbyHTMLTag: function(parsedElement, tag) {
            if(tag.startsWith("b-")){
                return tag.replace("b-","");
            }
            // Define the complete mapping that includes all possible elements
            const completeMapping = {
                'section': ['section'],
                'div': ['div', 'a', 'article', 'nav', 'ol', 'ul', 'li', 'aside'],
                'text-basic': ['p', 'span', 'figcaption', 'address'],
                'heading': ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
                'image': ['img', 'picture'],
                'video': ['video'],
                'button': ['button'],
                'code': ['style', 'script']
            };
        
            // The specific keys for elements with text content and no children
            const textOnlyKeys = ['text-basic', 'heading', 'button', 'code'];
        
            // Check if the element has text content and no children
            if (parsedElement.textContent && typeof parsedElement.textContent === "string" && parsedElement.textContent.length > 0 && parsedElement.children.length === 0) {
                for (const key of textOnlyKeys) {
                    if (completeMapping[key].includes(tag)) {
                        return key; // Return the corresponding key
                    }
                }
                return 'text-basic';
            }
        
            // If the element has children or no text, check the full mapping
            for (const key in completeMapping) {
                if (completeMapping[key].includes(tag)) {
                    return key;
                }
            }
        
            return 'div';
        },
        setIdFromParsedHTML: function (parsedElement, obj, codepenStates){
            const id = parsedElement.id;

            // Excluded
            if (codepenStates.excludeIds !== '' && codepenStates.excludeIds.replaceAll(' ', '').split(',').some(item => id.trim().toLowerCase().includes(item.trim().toLowerCase()))) {
                return obj;
            }          
            if(!id && obj.settings.hasOwnProperty('_cssId')){
                delete obj.settings._cssId;
            } else if (id && id !== `brxe-${obj.id}`){
                obj.settings._cssId = id;
            }
            return obj;
        },
        setClassesFromParsedHTML: function(parsedElement, obj, codepenStates){
            const classes = parsedElement.className;
            if(classes && typeof classes === "string"){
                const classesArr = classes.split(' ');
                const globalClasses = [];
                const cssClasses = [];
                classesArr.forEach(tempCls => {
                    // Excluded
                    if (codepenStates.excludeClasses !== '' && codepenStates.excludeClasses.replaceAll(' ', '').split(',').some(item => tempCls.trim().toLowerCase().includes(item.trim().toLowerCase()))) {
                        return;
                    }
                    
                    const existingGlobalClass = ADMINBRXC.vueState.globalClasses.find(el => el && el.name === tempCls);
                    if(existingGlobalClass) {
                        globalClasses.push(existingGlobalClass.id);
                    } else {
                        if(codepenStates.createGlobalClasses){
                            const newId = ADMINBRXC.vueGlobalProp.$_generateId();
                            ADMINBRXC.vueState.globalClasses.push({
                                id: newId,
                                name: tempCls,
                                settings: {},
                            })
                            globalClasses.push(newId);
                        } else {
                            cssClasses.push(tempCls)
                        }
                    }
                })
                if(globalClasses.length > 0){
                    obj.settings._cssGlobalClasses = globalClasses;
                } else {
                    delete obj.settings._cssGlobalClasses;
                }
                if(cssClasses.length > 0){
                    obj.settings._cssClasses = cssClasses.join(' ');
                } else {
                    delete obj.settings._cssClasses;
                }
            } else {
                delete obj.settings._cssGlobalClasses;
                delete obj.settings._cssClasses;
            }

            return obj;
        },
        setTextFromParsedHTML: function(parsedElement, obj, objConfig){
            const innerText = parsedElement.innerHTML;
            const tagName = parsedElement.tagName.toLowerCase();

            // Exceptions
            if(innerText && tagName === "style"){
                obj.settings.cssCode = innerText;
                obj.settings.noRoot = true;
                return obj;
            }
            if(innerText && tagName === "script"){
                obj.settings.javascriptCode = innerText;
                obj.settings.noRoot = true;
                return obj;
            }

            //Global
            if(!innerText && objConfig.controls.hasOwnProperty('text')){
                delete obj.settings.text;
            } else if(objConfig.controls.hasOwnProperty('text') && innerText && typeof innerText === "string" && innerText.length > 0){
                obj.settings.text = innerText;
            }

            return obj
        },
        setAttributesFromParsedHTML: function(parsedElement, obj, codepenStates) {
            const attributes = [];
        
            for (const attr of parsedElement.attributes) {
                const attrName = attr.name.toLowerCase();
                const attrValue = attr.value.trim();
        
                // Exclude unwanted attributes
                if (attrName === "id" || attrName === "class" || 
                    codepenStates.excludeAttributes.replaceAll(' ', '').split(',').some(item => item.trim().toLowerCase() === attrName)) {
                    continue;
                }

                // Handle src (image)
                if (attrName === "src") {
                    obj.settings.image = {
                        url: ADMINBRXC.helpers.getFilenameURLFromUrl(attrValue),
                        external: true,
                        filename: ADMINBRXC.helpers.getFilenameFromUrl(attrValue)
                    };
                }

                // Bricks Label
                else if(attrName === "data-bricks-label"){
                    obj.label = attrValue;
                }
        
                // Handle href (link)
                else if (attrName === "href") {
                    obj.settings.link = "url";
                    obj.settings.url = obj.settings.url || {};
                    obj.settings.url.url = attrValue;
                    obj.settings.url.type = "external";
                }
        
                // Handle rel
                else if (attrName === "rel") {
                    obj.settings.url = obj.settings.url || {};
                    obj.settings.url.rel = attrValue;
                }
        
                // Handle title
                else if (attrName === "title") {
                    obj.settings.url = obj.settings.url || {};
                    obj.settings.url.title = attrValue;
                }
        
                // Handle aria-label
                else if (attrName === "aria-label") {
                    obj.settings.url = obj.settings.url || {};
                    obj.settings.url.ariaLabel = attrValue;
                }
        
                // Handle target (newTab)
                else if (attrName === "target" && attrValue === "_blank") {
                    obj.settings.url = obj.settings.url || {};
                    obj.settings.url.newTab = true;
                }
        
                // Handle alt (image alt text)
                else if (attrName === "alt") {
                    obj.settings.altText = attrValue;
                }
        
                // Handle loading
                else if (attrName === "loading") {
                    obj.settings.loading = attrValue;
                }
        
                // Handle other attributes
                else {
                    const attrObj = {
                        id: ADMINBRXC.vueGlobalProp.$_generateId(),
                        name: attrName,
                        value: attrValue
                    };
                    attributes.push(attrObj);
                }
            }
        
            // Set _attributes if any custom attributes were found, or clean it if empty
            if (attributes.length > 0) {
                obj.settings._attributes = attributes;
            } else if (obj.settings.hasOwnProperty('_attributes')) {
                delete obj.settings._attributes;
            }
        
            return obj;
        },
        parseHtmlStringToObjectArray: function(rootId, parentId, cmValues, codepenStates){
            // Parse the HTML string into a DOM structure
            const parser = new DOMParser();
            const doc = parser.parseFromString(cmValues.html, 'text/html');
            
            // This will store the final array of objects
            const elementsArray = [];
            const rootChildren = [];  // To store top-level child IDs
        
            function setDefaultTag(elementObj, tag){
                elementObj.settings.tag = 'custom';
                elementObj.settings.customTag = tag;
            }
        
            // Function to recursively walk through the DOM and generate objects
            function traverseElement(element, parentId = rootId) {
                // Generate a unique ID for the current element
                const id = ADMINBRXC.vueGlobalProp.$_generateId();
                const tagName = element.tagName.toLowerCase();
                const bricksName = ADMINBRXC.helpers.elementTagbyHTMLTag(element, tagName);
                const elementConfig = ADMINBRXC.vueGlobalProp.$_getElementConfig(bricksName);
        
                // Create the object for the current element
                let elementObj = {
                    id: id,
                    name: bricksName,
                    parent: parentId,
                    children: [],
                    settings: {},
                };

                const isNestable = ADMINBRXC.vueGlobalProp.$_isNestable(elementObj);
        
                if(elementConfig.tag !== tagName){
                    if(tagName === "img" || tagName.startsWith('b-')){
                        // silence
                    } else{
                        let isOption = false;
                        if(elementConfig.controls.hasOwnProperty('tag') && !elementConfig.controls.tag.hasOwnProperty('customTag')){
                            // can't change the tag
                        }
                        if(elementConfig.controls.hasOwnProperty('tag') && elementConfig.controls.tag.hasOwnProperty('options')){
                            for(const key in elementConfig.controls.tag.options){
                                if(key == tagName) isOption = true;
                            }
                        }
        
                        if(isOption){
                            elementObj.settings.tag = tagName;
                        } else {
                            setDefaultTag(elementObj, tagName);
                        }
                    }
                }
            
        
                // id
                if(codepenStates.includesIds) elementObj = ADMINBRXC.helpers.setIdFromParsedHTML(element, elementObj, codepenStates);
        
                // Classes
                if(codepenStates.includesClasses) elementObj = ADMINBRXC.helpers.setClassesFromParsedHTML(element, elementObj, codepenStates);
        
                // Text
                if(codepenStates.includesTexts) elementObj = ADMINBRXC.helpers.setTextFromParsedHTML(element, elementObj, elementConfig);
        
                // Attributes
                if(codepenStates.includesAttributes) elementObj = ADMINBRXC.helpers.setAttributesFromParsedHTML(element, elementObj, codepenStates);
                
                // If the element has children, process them recursively
                const children = [...element.children];
                if (children.length > 0 && isNestable) {
                    children.forEach((child) => {
                        const childObj = traverseElement(child, id);
                        elementObj.children.push(childObj.id); // Add child id to parent's "children" array
                    });
                }
               
        
                // Add the current element object to the final array
                elementsArray.push(elementObj);
                
                return elementObj; // Return the current object
            }
        
            // Traverse the top-level elements in the parsed document body
            [...doc.body.children].forEach((element) => {
                const topLevelElement = traverseElement(element);
                rootChildren.push(topLevelElement.id); // Store top-level children IDs
            });

            if(cmValues.css || cmValues.js){
                const codeId = ADMINBRXC.vueGlobalProp.$_generateId();
                const codeObj = {
                    id: codeId,
                    name: 'code',
                    label: 'CSS/JS Code',
                    parent: rootId,
                    children: [], // Set the correct top-level children here
                    settings: {},
                }
                if(cmValues.css){
                    codeObj.settings.cssCode = css_beautify(cmValues.css, { indent_size: 2 });
                }
                if(cmValues.js){
                    codeObj.settings.javascriptCode = cmValues.js;
                }
                elementsArray.splice(0, 0, codeObj);
                rootChildren.splice(0, 0, codeId);
            }
            const parentObj = {
                id: rootId,
                name: 'div',
                label: 'Generated By Codepen Converter',
                parent: parentId,
                children: rootChildren, // Set the correct top-level children here
                settings: {},
            }
            // Add the root element with its updated children array
            elementsArray.push(parentObj);
            return elementsArray;
        },
        commentCMCode: function(cm){
            cm.CodeMirror.toggleComment();
            var event = new Event('keyup');
            cm.CodeMirror.getInputField().dispatchEvent(event);
        },
        getCSSSelector: function(element) {
            const ignoredSelectors = ['bricks-preview', 'iframe', 'mounted'];
            const ignoredClasses = ['brxe-', 'brx-', 'bricks', 'is-active-element'];
            let currentElement = element;
            let selector = '';

            // Helper function to check if a class should be ignored
            function shouldIgnore(term, arr) {
                return arr.some(prefix => term.startsWith(prefix));
            }

            // Traverse the DOM up until body or html, or when an ID or class is found
            while (currentElement && currentElement.tagName.toLowerCase() !== 'body') {

                // Check if the element has an ID
                
                if (currentElement.classList.length > 0) {

                    // Check if the current element matches any ignored selectors
                    if ([...currentElement.classList].filter(className => shouldIgnore(className, ignoredSelectors)).length > 0) {
                        ADMINBRXC.vueGlobalProp.$_showMessage('ABORT: this element belongs to the builder only!')
                        continue;
                    }
                    // Filter out ignored classes
                    const validClasses = [...currentElement.classList].filter(className => !shouldIgnore(className, ignoredClasses));

                    // BEM
                    const hasBEMClass = validClasses.some(el => el.indexOf('__') > -1);
                    if (validClasses.length > 0 && hasBEMClass){
                            selector = `.${validClasses.find(el => el.indexOf('__') > -1)}` + selector;
                            break;
                    }

                    // If no BEM class but has valid classes, prioritize ID
                    if(validClasses.length > 0){
                        if (currentElement.id) {
                            if(bricksData.loadData.globalSettings.elementAttsAsNeeded && currentElement.id.startsWith('brxe-')){
                                const obj = ADMINBRXC.helpers.getElementObject(currentElement.id.replace('brxe-',''));
                                if(obj && ADMINBRXC.helpers.elementHasStyle(obj.settings)){
                                    selector = `#${currentElement.id}` + selector;
                                    break;
                                } 
                            } else {
                                selector = `#${currentElement.id}` + selector;
                                break
                            }
                        }

                        // If valid classes but no ID, join the classes.
                        selector = `.${validClasses.join('.')}` + selector;
                    }
                } 
                
                
                if (currentElement.id) {
                    if(bricksData.loadData.globalSettings.elementAttsAsNeeded && currentElement.id.startsWith('brxe-')){
                        const obj = ADMINBRXC.helpers.getElementObject(currentElement.id.replace('brxe-',''));
                        if(obj && ADMINBRXC.helpers.elementHasStyle(obj.settings)){
                            selector = `#${currentElement.id}` + selector;
                            break;
                        } 
                    } else {
                        selector = `#${currentElement.id}` + selector;
                        break
                    }
                } 
                
                // If no ID or class, add the tag name and nth-child
                const tagName = currentElement.tagName.toLowerCase();
                if (currentElement.parentNode) {
                    const siblings = currentElement.parentNode.children;
                    if (siblings.length > 1) {
                        const index = Array.prototype.indexOf.call(siblings, currentElement) + 1;
                        selector = ` > ${`${tagName}:nth-child(${index})`}` + selector;
                    } else {
                        selector = ` > ${tagName}` + selector;
                    }
                } else {
                    selector = ` > ${tagName}` + selector;
                }

                // Move to the parent element
                currentElement = currentElement.parentElement;
            }

            return selector;
        },
        textAreaAutoGrow: function(element, size) {
            element.style.height = size;
            element.style.height = element.scrollHeight + "px";
        },
        removeCommentedCSS: function(string){
            if(!string) return false;
            return string.replaceAll(/\/\*[\s\S]*?\*\//g, '');
        },
        childThemeCommentReadOnly: function(MyCM){
            const content = MyCM.getValue();
            const commentRegex = /\/\*[\s\S]*?\*\//;
            const match = commentRegex.exec(content);
            if(match){
                const startPos = MyCM.posFromIndex(match.index);
                const endPos = MyCM.posFromIndex(match.index + match[0].length);
                MyCM.markText(startPos, endPos, {readOnly: true, className: 'readonly-comment2'});
            }
        },
        classNametoLabel: function(clsName){
            const temp = clsName.includes('__') 
                    ? clsName.split('__')[1]  // Get the part after '__'
                    : clsName;  // Use the whole name if '__' is not present

            const result = temp
                .replaceAll('__', ' ')
                .replaceAll('_', ' ')
                .replaceAll('--', ' ')
                .replaceAll('-', ' ')
                .split(' ')
                .filter(Boolean);  // Remove empty strings from the array

            return result.map(el => el.charAt(0).toUpperCase() + el.slice(1).toLowerCase()).join(' ');
        },
        insertAfterNthParent(originalArray, newElements, targetParentPosition) {
            // Clone the original array to avoid mutations
            const array = JSON.parse(JSON.stringify(originalArray));

            if (targetParentPosition === 0) {
                // If target position is 0, insert newElements at the beginning
                array.unshift(...newElements);
                return array;
            }

            let parentCount = 0;
            let insertIndex = -1;

            // Find the position after the nth parent
            for (let i = 0; i < array.length; i++) {
                if (array[i].parent === 0) {
                    parentCount++;
                    if (parentCount === targetParentPosition) {
                        insertIndex = i + 1;
                        break;
                    }
                }
            }

            if (insertIndex !== -1) {
                array.splice(insertIndex, 0, ...newElements); // Insert at the calculated position
            } else {
                array.push(...newElements); // Append to the end if no position found
            }

            return array;
        },
        isElementOnRoot: function(parent){
            return parent === 0 || (ADMINBRXC.helpers.isComponentActive() && ADMINBRXC.helpers.isComponentRoot(parent));
        },
        getContent: function(forceStructure = false){
            if(ADMINBRXC.helpers.isComponentActive() && !forceStructure){
                return ADMINBRXC.vueState.activeComponent.elements;
            }
            const contentType = ADMINBRXC.helpers.getTemplateType();
            return ADMINBRXC.vueState[contentType];
        },
        getContentWithComponents: function(){
            const contentType = ADMINBRXC.helpers.getTemplateType();
            const mainElements = ADMINBRXC.vueState[contentType].filter(el => !el.hasOwnProperty('cid'));
            const componentElements = ADMINBRXC.vueState.components?.flatMap(el => el.elements) || [];
            return [...mainElements, ...componentElements];
        },
        getPageContentAndPageComponents: function(){
            const template = ADMINBRXC.helpers.getTemplateType();
            let fullArr = [];

            if (ADMINBRXC.vueState.hasOwnProperty('components')) {
                // Create a lookup set for better performance
                const templateCIDs = new Set(
                    ADMINBRXC.vueState[template]
                        .filter(el => el.hasOwnProperty('cid'))
                        .map(el => el.cid)
                );

                // Filter active components and associate them with their IDs
                const activeComponentsObjs = ADMINBRXC.vueState.components
                    .filter(el => templateCIDs.has(el.id))
                    .map(el => ({
                        obj: el,
                        component: el.id
                    })) || [];

                // Extract elements from active components and associate them with their parent component ID
                const activeElements = activeComponentsObjs.flatMap(el =>
                    el.obj.elements.map(el3 => ({
                        obj: el3,
                        component: el.component
                    }))
                );

                // Combine template elements, active components, and active elements
                fullArr = [
                    ...ADMINBRXC.vueState[template]
                        .filter(el => !el.hasOwnProperty('cid')) // Elements without 'cid'
                        .map(el => ({ obj: el })),
                    ...activeComponentsObjs,
                    ...activeElements
                ];

            } else {
                // If no components exist, fallback to the template array
                fullArr = ADMINBRXC.vueState[template];
            }


            return fullArr;
        },
        countCharacter: function(string, char) {
            const escapedChar = char.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const regex = new RegExp(escapedChar, "g");
            const matches = string.match(regex);
            return matches ? matches.length : 0;
        },
        camelCaseToHumanReadable: function(key) {
            // Remove leading underscore, if present
            const cleanedKey = key.startsWith("_") ? key.slice(1) : key;
            // Insert spaces before uppercase letters and make the first letter lowercase
            return cleanedKey
                .replace(/([A-Z])/g, ' $1') // Add space before uppercase letters
                .toLowerCase(); // Capitalize the first letter
        },
        isComponentRoot: function(id){
            if(!ADMINBRXC.vueState.hasOwnProperty('components')) return false;
            const obj = ADMINBRXC.vueGlobalProp.$_getComponentById(id);
            return obj && typeof obj === "object" && obj.hasOwnProperty('id');
        },
        isElementInComponent: function(id) {
            if (!ADMINBRXC.vueState.hasOwnProperty('components')) return false;
            const allElements = ADMINBRXC.vueState.components.flatMap(component => component.elements || []);
            return allElements.some(element => element.id === id);
        },
        getComponentByElementId: function(id) {
            if (!ADMINBRXC.vueState.hasOwnProperty('components')) return false;
            return ADMINBRXC.vueState.components.find(component =>
                (component.elements || []).some(element => element.id === id)
            );
        },
        elementHasGrid: function(){
            const obj = ADMINBRXC.helpers.getFinalObject();
            const target = ADMINBRXC.helpers.createTargetWithPseudo('_display');
            if(obj.settings.hasOwnProperty(target) && obj.settings[target] === "grid") return true;

            const structureObj = ADMINBRXC.helpers.getFinalObject(true);
            if(FRAMEBRXC.vueGlobalProp.$_elementHasCssGrid(structureObj.id)) return true;
            
            return false;
        },
    },
    debounceTimer: null,
    populateCSSVariables: function () {
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        let temp = Array.from(x.document.styleSheets)
            .filter(
                sheet =>
                    sheet && sheet.href === null || sheet.href.startsWith(window.location.origin)
            )
            .reduce(
                (acc, sheet) =>
                    (acc = [
                        ...acc,
                        ...Array.from(sheet.cssRules).reduce(
                            (def, rule) =>
                                (def =
                                    rule.selectorText && rule.selectorText.includes(":root")
                                        ? [
                                            ...def,
                                            ...Array.from(rule.style).filter(name =>
                                                name && name.startsWith("--") && !name.startsWith("--builder")
                                            )
                                        ]
                                        : def),
                            []
                        )
                    ]),
                []
            );

    
        // Include inline CSS variables defined on the :root element
        const rootElement = x.document.querySelector(":root");
        if (rootElement) {
            Array.from(rootElement.style).forEach(variable => {
                if (variable.startsWith("--") && !variable.startsWith("--builder")) {
                    temp.push(variable);
                }
            });
        }
        temp = [...new Set(temp)];
        self.cssVariables = Array.from(temp.sort()).map(el => `var(${el})`);
    },
    
    states:{
        // Class Manager
        classManagerType: 'global',
        classManagerFilterLocked: false,
        classManagerFilterActive: false,
        classManagerFilterStyle: false,
        classManagerSearch: '',
        classManagerActiveClass: '',
        classManagerMaxClasses: 50,
        // Bulk Actions
        classManagerActiveCategory: 'All',
        classManagerisAIopen: false,
        classManagerBulkActionType: 'Rename',
        classManagerBulkActionTargetContain: '',
        classManagerBulkActionTargetExclude: '',
        classManagerBulkActionTargetGroup: 'All',
        classManagerBulkActionLock: 'All',
        classManagerBulkActionHasStyles: 'All',
        classManagerBulkActionIsActive: 'All',
        classManagerBulkActionOld: '',
        classManagerBulkActionNew: '',
        classManagerBulkActionPrefix: '',
        classManagerBulkActionSuffix: '',
        classManagerBulkActionNewGroup: '',
        classManagerBulkAssignElements: true,
        classManagerBulkRemoveOldClass: false,
        classManagerBulkDeleteOldClass: false,
        // Class Converter
        classConverterBasename: '',
        classConverterDelimiter: '__',
        classConverterCategory: false,
        classConverterCopyStyles: true,
        classConverterEraseStyles: false, 
    },
    loremSentences: [
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
        'Integer nec odio. Praesent libero uctus non, massa.',
        'Sed cursus ante dapibus diam. Sed nisi.',
        'Nulla quis sem at nibh elementum imperdiet.',
        'Duis sagittis ipsum. Praesent mauris himenaeos.',
        'Fusce nec tellus sed augue semper porta.',
        'Vestibulum lacinia arcu eget nulla per conubia.',
        'Class aptent taciti sociosqu ad litora torquent.',
        'Curabitur sodales ligula in libero euismod in, nibh.',
        'Sed dignissim lacinia nunc nostra, per inceptos.',
        'Curabitur tortor pellentesque nibh aenean quam.',
        'In scelerisque sem at dolor maecenas mattis.',
        'Sed convallis tristique sem mauris massa.',
        'Proin ut ligula vel nunc egestas porttitor.',
        'Morbi lectus risus, iaculis vel, suscipit quis.',
        'Fusce ac turpis quis ligula lacinia aliquet.',
        'Mauris ipsum mam nec ante Nulla facilisi adipiscing diam.',
        'Nulla metus metus, ullamcorper vel, tincidunt sed.',
        'Quisque volutpat condimentum velit ante quis turpis.',
        'Class aptent taciti sociosqu ad litora torquent per conubia.',
        'Sed lacinia, urna non tincidunt mattis, tortor neque.',
        'Ut fringilla. Suspendisse potenti a cursus ipsum.',
        'Nunc feugiat mi a tellus consequat imperdiet.',
        'Vestibulum sapien. Proin quam. Etiam ultrices.',
        'Suspendisse in justo eu magna luctus suscipit.',
    ],
    CSScontrolKeys: [],
    excludedControlKeyFromCSS: [
        '_cssGlobalClasses',
        '_conditions',
        '_interactions',
        '_cssClasses',
        '_cssId',
        '_attributes'
    ],
    fields: {
        CSSVariabe : {
            includedFields: [
                'div[data-control="number"]',
                {
                    selector: 'div[data-control="text"]',
                    hasChild: [
                        '#_backdropFilter',
                        '#_pointerEvents',
                        '#_aspectRatio',
                        '#_perspectiveOrigin',
                        '#_cssTransition',
                        '#_transformOrigin',
                        '#_flexBasis',
                        '#_overflow',
                        '#_gridTemplateColumns',
                        '#_gridTemplateRows',
                        '#_gridAutoColumns',
                        '#_gridAutoRows',
                        '#_objectPosition',
                        '[id^="raw-"]'
                    ]
                }
            ],
            excludedFields: [
                // Query loop
                '.control-query',
                // Slider
                '[data-controlkey="start"]',
                '[data-controlkey="perPage"]',
                '[data-controlkey="perMove"]',
                '[data-controlkey="speed"]',
                '[data-controlkey="rating"]',
                '[data-controlkey="maxRating"]',
            ],
        },
        colors : {
            includedFields: [
                'div[data-control="color"]',
            ],
            excludedFields: [],
        },
        loremIpsum : {
            includedFields: [
                'div[data-control="textarea"]',
                {
                    selector:
                        '[data-controlkey="text"] div[data-control="text"][type="text"],[data-controlkey="title"] div[data-control="text"][type="text"], [data-controlkey="fields"] div[data-control="text"][type="text"], [data-controlkey="prefix"] div[data-control="text"][type="text"], [data-controlkey="suffix"] div[data-control="text"][type="text"], [data-controlkey="logoText"] div[data-control="text"][type="text"], [data-controlkey="actionText"] div[data-control="text"][type="text"], [data-controlkey="titleCustom"] div[data-control="text"][type="text"], [data-control-key="text"] div[data-control="text"][type="text"], [data-control-key="title"] div[data-control="text"][type="text"], [data-control-key="subtitle"] div[data-control="text"][type="text"], [data-control-key="name"] div[data-control="text"][type="text"], [data-control-key="buttonText"] div[data-control="text"][type="text"]',
                    hasChild: '.dynamic-tag-picker-button',
                }
            ],
            excludedFields: [
                '.control-query',
                'div[data-control="conditions"]',
                'div[data-control="interactions"]',
                '#transition',
                'div[data-controlkey="speed"]',
                '[data-controlkey="shortcode"]',
                'div[data-control-key="format"]',
                '[data-controlkey="_cssSuperPowerCSS"]',
            ],
        },
        openAI : {
            includedFields: [
                'div[data-control="textarea"]',
                {
                    selector:
                        '[data-controlkey="text"] div[data-control="text"][type="text"], [data-controlkey="title"] div[data-control="text"][type="text"], [data-controlkey="fields"] div[data-control="text"][type="text"], [data-controlkey="prefix"] div[data-control="text"][type="text"], [data-controlkey="suffix"] div[data-control="text"][type="text"], [data-controlkey="logoText"] div[data-control="text"][type="text"], [data-controlkey="actionText"] div[data-control="text"][type="text"], [data-controlkey="titleCustom"] div[data-control="text"][type="text"], [data-control-key="text"] div[data-control="text"][type="text"], [data-control-key="title"] div[data-control="text"][type="text"], [data-control-key="subtitle"] div[data-control="text"][type="text"], [data-control-key="name"] div[data-control="text"][type="text"], [data-control-key="buttonText"] div[data-control="text"][type="text"]',
                    hasChild: '.dynamic-tag-picker-button',
                }
            ],
            excludedFields: [
                '.control-query',
                'div[data-control="conditions"]',
                'div[data-control="interactions"]',
                '#transition',
                'div[data-controlkey="speed"]',
                '[data-controlkey="shortcode"]',
                'div[data-control-key="format"]',
                '[data-controlkey="_cssSuperPowerCSS"]',
            ],
        },
        dynamicDataModal: {
            includedFields: [
                '.dynamic-tag-picker-button:not([data-listening="true"]',
            ],
            excludedFields: [
                '.control.control-code',
            ],
        },
        colorsOnHover : {
            includedFields: [
                'ul.color-palette > li.color',
            ],
            excludedFields: [
            ],
        },
        classesOnHover : {
            includedFields: [
                'div.bricks-control-popup > div.css-classes > ul:nth-of-type(2) > li > div.actions',
            ],
            excludedFields: [
            ],
        }
    },
    aihistory:[
    ],
    handleGlobalClassesOnLoad: function(){
        const self = this;
        const isClassAndStyleActive = self.helpers.isClassesAndStylesTabActive();
        const classAndStylesAtt = self.globalSettings.generalCats.classesAndStyles || [];
        let globalClasses = self.vueState.globalClasses || [];
        let globalClassesLocked = self.vueState.globalClassesLocked || [];
        let globalClassesCategories = self.vueState.globalClassesCategories || [];
        let hasChangesGlobalClasses = false, hasChangesGlobalClassesLocked = false, hasChangesGlobalClassesCategories = false, hasChangesContent = false;
    
        const lockedClassIds = new Set(globalClassesLocked);
        const gridAndImportedIds = new Set(); // To collect IDs for locking
    
        // Batch save function
        const saveChangesIfNeeded = () => {
            if (hasChangesGlobalClasses) self.helpers.saveChanges('globalClasses');
            if (hasChangesGlobalClassesLocked) self.helpers.saveChanges('globalClassesLocked');
            if (hasChangesGlobalClassesCategories) self.helpers.saveChanges('globalClassesCategories');
            if (hasChangesContent) self.helpers.saveChanges('content')
        };
    
        // Iterate over globalClasses once and handle all conditions
        globalClasses = globalClasses.reduce((accumulatedClasses, item) => {
            if (!item || !item.id) return accumulatedClasses;
    
            let modified = false;
    
            // Remove grid and imported classes if options turned off
            const isGridClass = item.id.startsWith("brxc_grid");
            const isImportedClass = item.id.startsWith("brxc_imported");
            
            if ((!isClassAndStyleActive || !classAndStylesAtt.includes('grids')) && isGridClass) {
                hasChangesGlobalClasses = true;
                modified = true;
            }
    
            if ((!isClassAndStyleActive || !classAndStylesAtt.includes('class-importer')) && isImportedClass) {
                hasChangesGlobalClasses = true;
                modified = true;
            }
    
            // Skip adding to the final array if it's removed
            if (modified) return accumulatedClasses;
    
            // Collect grid and imported IDs for locking
            if (isGridClass || isImportedClass) {
                gridAndImportedIds.add(item.id);
            }
    
            // Ensure settings object exists
            if (!item.hasOwnProperty('settings')) {
                item.settings = {};
                hasChangesGlobalClasses = true;
            }
    
            // Fix class categories
            if (item.cat) {
                const categoryFound = self.helpers.getClassCategoryObjByName(item.cat);
                if (categoryFound) {
                    item.category = categoryFound.id;
                } else {
                    const newCategoryId = self.vueGlobalProp.$_generateId();
                    globalClassesCategories.push({
                        id: newCategoryId,
                        name: item.cat
                    });
                    item.category = newCategoryId;
                    hasChangesGlobalClassesCategories = true;
                }
                delete item.cat;
                hasChangesGlobalClasses = true;
            }
    
            // Add the item to the final array
            accumulatedClasses.push(JSON.parse(JSON.stringify(item)));
            return accumulatedClasses;
        }, []);

        self.vueState.globalClasses = globalClasses;
    
        // Lock grid and imported classes if not already locked
        gridAndImportedIds.forEach(id => {
            if (!lockedClassIds.has(id)) {
                globalClassesLocked.push(id);
                hasChangesGlobalClassesLocked = true;
            }
        });

        // Sanitize classes for inexistent ones in content elements
        if (Object.values(self.globalSettings.classFeatures).includes("clean-deleted-classes")){
            const content = self.helpers.getContent() || [];
        
            content.forEach(el => {
                if (el?.settings?._cssGlobalClasses?.length) {
                    const originalGlobalClasses = el.settings._cssGlobalClasses;
                    el.settings._cssGlobalClasses = el.settings._cssGlobalClasses.filter(cls => {
                        return globalClasses.some(globalClass => globalClass.id === cls);
                    });

                    // Add to unsaved Changes
                    if(originalGlobalClasses.length !== el.settings._cssGlobalClasses.length) hasChangesContent = true;

                    // remove property if Global Class array is empty
                    if(el.settings._cssGlobalClasses.length === 0) delete el.settings._cssGlobalClasses;
                }
            });
        }
    
        // Save all changes at once
        saveChangesIfNeeded();
    },
    qry: (el) => {
        return document.querySelector(el);
    },
    qryAll: (els) => {
        return document.querySelectorAll(els);
    },
    initAcc: (elem, option) => {
        document.addEventListener('click', (e) => {
            if (!e.target.matches(elem + ' .brxc-accordion-btn')) return;
            else {
                if (!e.target.parentElement.classList.contains('active')) {
                    if (option == true) {
                        var elementList = document.querySelectorAll(elem + ' .brxc-accordion-container');
                        Array.prototype.forEach.call(elementList, (e) => {
                        e.classList.remove('active');
                        });
                    }
                    e.target.parentElement.classList.add('active');
                } else {
                    e.target.parentElement.classList.remove('active');
                }
            }
        });
    },
    minimizeModal: function(overlay){
        const inner = document.querySelector(`${overlay} .brxc-overlay__inner`);
        (inner.classList.contains('brxc-large')) ? inner.classList.remove('brxc-large') : '';
        inner.classList.add('brxc-medium');
    },
    maximizeModal: function(icon, overlay){
        const modal = document.querySelector(overlay);
        const inner = document.querySelector(`${overlay} .brxc-overlay__inner`);
        const icons = modal.querySelectorAll('.brxc-overlay__resize-icons i')
        const btn  = modal.querySelector('.brxc-overlay__close-btn')
        modal.classList.remove(...['sidebar', 'left', 'right']);
        inner.style.width = '';
        btn.style.left = '';
        btn.style.right = '';
        if(icon.classList.contains('active')) {
            icons.forEach(el => el.classList.remove('active'));
            inner.classList.remove('brxc-large');
            inner.classList.add('brxc-medium')
        } else {
            icons.forEach(el => el.classList.remove('active'));
            icon.classList.add('active');
            inner.classList.add('brxc-large');
            inner.classList.remove('brxc-medium')
        }
    },
    rightSidebarModal: function(icon, overlay){
        const self = this;
        const modal = document.querySelector(overlay);
        const inner = modal.querySelector(`.brxc-overlay__inner`);
        const btn  = modal.querySelector('.brxc-overlay__close-btn')
        const icons = modal.querySelectorAll('.brxc-overlay__resize-icons i')
        modal.classList.remove(...['sidebar', 'left', 'right']);
        inner.style.width = '';
        btn.style.left = '';
        btn.style.right = '';
        if(icon.classList.contains('active')) {
            icons.forEach(el => el.classList.remove('active'));
            const max = modal.querySelector('.brxc-overlay__resize-icons .fa-window-maximize');
            (inner.classList.contains('brxc-large')) ? max.classList.add('active') : '';
            return;
        };
        icons.forEach(el => el.classList.remove('active'));

        self.calculatePanelWidth('right', inner, btn);
        modal.classList.add(...['sidebar', 'right']);
        icon.classList.add('active');

    },
    calculatePanelWidth: function(position, inner, btn, forced = false){
        let panel, width;
        if(position === 'left'){
            panel = document.querySelector('#bricks-panel');
            width = window.getComputedStyle( panel ,null).getPropertyValue('width');
            if(forced) width = forced;
            btn.style.left = `calc(${width} + 8px)`;
        } else if(position === 'right') {
            panel = document.querySelector('#bricks-structure');
            width = window.getComputedStyle( panel ,null).getPropertyValue('width');
            if(forced) width = forced;
            btn.style.right = `calc(${width} + 16px)`;
        }
        inner.style.width = width;
    },
    leftSidebarModal: function(icon, overlay){
        const self = this;
        const modal = document.querySelector(overlay);
        const inner = modal.querySelector(`.brxc-overlay__inner`);
        const btn  = modal.querySelector('.brxc-overlay__close-btn')
        const icons = modal.querySelectorAll('.brxc-overlay__resize-icons i')
        modal.classList.remove(...['sidebar', 'left', 'right']);
        inner.style.width = '';
        btn.style.left = '';
        btn.style.right = '';
        if(icon.classList.contains('active')) {
            icons.forEach(el => el.classList.remove('active'));
            const max = modal.querySelector('.brxc-overlay__resize-icons .fa-window-maximize');
            (inner.classList.contains('brxc-large')) ? max.classList.add('active') : '';
            return;
        }
        icons.forEach(el => el.classList.remove('active'));
        self.calculatePanelWidth('left', inner, btn);
        modal.classList.add(...['sidebar', 'left']);
        icon.classList.add('active');

    },
    autocomplete: function (inp, arr, type, ignorePreview = false) {
        const self = this;
        let currentFocus = 0;
    
        if (inp.dataset.autocomplete === "true") return;
        inp.setAttribute("data-autocomplete", "true");
    
        // Array to track event listeners for cleanup
        const eventListeners = [];
    
        // Named function to handle keyup
        function handleKeyup(e) {
            if (e.keyCode === 40 || e.keyCode === 38 || e.keyCode === 13) return;
            let a, b, i, j, ul, val = inp.value;
            closeAllLists();
    
            if (!val) return false;
            currentFocus = -1;
    
            a = document.createElement("DIV");
            a.setAttribute("id", inp.id + "autocomplete-list");
            a.setAttribute("class", "autocomplete-items bricks-control-popup bottom");
            inp.parentNode.appendChild(a);
    
            ul = document.createElement("ul");
            a.appendChild(ul);
    
            for (i = 0, j = 0; i < arr.length; i++) {
                if (arr[i].toUpperCase().includes(val.toUpperCase())) {
                    j++;
                    b = document.createElement("li");
                    b.innerHTML += arr[i];
                    b.innerHTML += `<input type='hidden' value='${arr[i]}'>`;
    
                    // Named function for click
                    function handleClick() {
                        inp.value = this.querySelector("input").value;
                        const event = new Event("input", { bubbles: true, cancelable: true });
                        inp.dispatchEvent(event);
                        closeAllLists();
                        removeEventListeners();
                    }
                    b.addEventListener("click", handleClick);
                    eventListeners.push({ element: b, type: "click", listener: handleClick });
    
                    if (Object.values(self.globalSettings.classFeatures).includes("autocomplete-variable-preview-hover") && !ignorePreview) {
                        let isMouseMoving = false;
    
                        function handleMouseMove() {
                            isMouseMoving = true;
                        }
                        b.addEventListener("mousemove", handleMouseMove);
                        eventListeners.push({ element: b, type: "mousemove", listener: handleMouseMove });
    
                        function handleMouseLeave() {
                            setTimeout(() => {
                                inp.value = inp.dataset.autocompleteInitial;
                                const event = new Event("input", { bubbles: false, cancelable: true });
                                inp.dispatchEvent(event);
                                inp.removeAttribute("data-autocomplete-initial");
                            }, 0);
                        }
                        b.addEventListener("mouseleave", handleMouseLeave);
                        eventListeners.push({ element: b, type: "mouseleave", listener: handleMouseLeave });
    
                        function handleMouseEnter() {
                            setTimeout(() => {
                                inp.setAttribute("data-autocomplete-initial", inp.value);
                                if (!isMouseMoving) return;
                                inp.value = this.querySelector("input").value;
                                const event = new Event("input", { bubbles: false, cancelable: true });
                                inp.dispatchEvent(event);
                                isMouseMoving = false;
                            }, 0);
                        }
                        b.addEventListener("mouseenter", handleMouseEnter);
                        eventListeners.push({ element: b, type: "mouseenter", listener: handleMouseEnter });
                    }
    
                    ul.appendChild(b);
                }
            }
    
            if (j === 0) closeAllLists();
        }
    
        inp.addEventListener("keyup", handleKeyup);
        eventListeners.push({ element: inp, type: "keyup", listener: handleKeyup });
    
        // Named function to handle keydown
        function handleKeydown(e) {
            const x = document.getElementById(inp.id + "autocomplete-list");
            if (!x) return;
    
            const items = x.getElementsByTagName("li");
            if (e.key === "ArrowDown") {
                currentFocus++;
                addActive(items);
            } else if (e.key === "ArrowUp") {
                currentFocus--;
                addActive(items);
            } else if (e.key === "Enter") {
                e.preventDefault();
                if (currentFocus > -1 && items[currentFocus]) items[currentFocus].click();
            } else if (e.key === "Tab" || e.key === "Escape") {
                closeAllLists();
            }
        }
    
        inp.addEventListener("keydown", handleKeydown);
        eventListeners.push({ element: inp, type: "keydown", listener: handleKeydown });
    
        // Named function to close all lists
        function closeAllLists(elmnt) {
            const items = document.getElementsByClassName("autocomplete-items");
            for (let i = 0; i < items.length; i++) {
                if (elmnt !== items[i] && elmnt !== inp) {
                    items[i].parentNode.removeChild(items[i]);
                }
            }
        }
    
        // Attach event listener for clicks outside the autocomplete
        function handleClickOutside(e) {
            closeAllLists(e.target);
        }
        document.addEventListener("click", handleClickOutside);
        eventListeners.push({ element: document, type: "click", listener: handleClickOutside });
    
        // Utility functions
        function addActive(x) {
            if (!x) return;
            removeActive(x);
            if (currentFocus >= x.length) currentFocus = 0;
            if (currentFocus < 0) currentFocus = x.length - 1;
            x[currentFocus].classList.add("selected");
        }
    
        function removeActive(x) {
            for (let i = 0; i < x.length; i++) {
                x[i].classList.remove("selected");
            }
        }
    
        // Cleanup function to remove all event listeners
        function removeEventListeners() {
            eventListeners.forEach(({ element, type, listener }) => {
                element.removeEventListener(type, listener);
            });
            eventListeners.length = 0;
            inp.removeAttribute("data-autocomplete");
        }
    },
    
    debounce: (fn, threshold) => {
        var timeout;
        threshold = threshold || 200;
        return function debounced() {
            clearTimeout(timeout);
            var args = arguments;
            var _this = this;
        
            function delayed() {
                fn.apply(_this, args);
            }
            timeout = setTimeout(delayed, threshold);
        };
    },
    randomize: (length) => {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        let counter = 0;
        while (counter < length) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
          counter += 1;
        }
        return result;
    },
    openModal: function(target, id, focus = false, closeActiveModals = true, forced = false){
        const self = this;
        // Close open modals
        if(closeActiveModals){
            const openModals = document.querySelectorAll('.brxc-overlay__wrapper[data-active="true"]');
            if(openModals && openModals.length > 0){
                openModals.forEach(el => el.removeAttribute('data-active'));
            }
        }

        // Open Modal
        const wrapper = document.querySelector(id);
        wrapper.setAttribute('data-active','true');

        document.addEventListener('keydown', function(e) {
            (e.key === "Escape") ? self.closeModal(target, target.target, id) : '';
        });
        if(focus) setTimeout(() => {
            focus.focus();
            focus.setSelectionRange(0, focus.value.length)

        }, 10);

        // Resize
        const inner = wrapper.querySelector(`.brxc-overlay__inner`);
        const btn = wrapper.querySelector('.brxc-overlay__close-btn')
        inner.style.width = '';
        btn.style.left = '';
        btn.style.right = '';
        if (wrapper.classList.contains('left')) {
            self.calculatePanelWidth('left', inner, btn, forced)
        } else if(wrapper.classList.contains('right')) {
            self.calculatePanelWidth('right', inner, btn, forced)
        } 

        // Refresh panels
        const activePanel = wrapper.querySelector('.brxc-overlay__pannels-wrapper');
        if(activePanel){
            activePanel.style.display = "none";
            setTimeout(()=> {activePanel.style.display = "flex"}, 0);
        }
    },
    variablePickerToggleExtandCats: function(event,id){
        const self = this;
        event.preventDefault();
        event.stopPropagation();
        const isIncluded = self.variablePickerStates.extendedCategories.includes(id);
        if(isIncluded){
            self.variablePickerStates.extendedCategories = self.variablePickerStates.extendedCategories.filter(el => el && el !== id);
        } else {
            self.variablePickerStates.extendedCategories.push(id);
        }
        self.refreshVariablePickerList(false);
    },
    variablePopulateGroups: function(firstRun){
        const self = this;
        let content = '<div id="sortableWrapper">';
        let isExpanded = false;
        let isExpandedDefault = false;
        let arr = self.helpers.isCSSVariablesTabActive('theme-variables') && self.helpers.themeHasVariables() ? self.vueState.globalVariables.concat(self.vueState.themeStyleSettings.general._cssVariables) : self.vueState.globalVariables;
        if(self.variablePickerStates.search !== '') arr = arr.filter(el => el && el.name.includes(self.variablePickerStates.search));
        self.vueState.globalVariablesCategories.forEach(group => {
            const variables = Array.from(arr).filter(el => el && el.category === group.id);
            isExpandedDefault = group.hasOwnProperty('defaultExpanded');
            if(firstRun && group.hasOwnProperty('defaultExpanded')) self.variablePickerStates.extendedCategories.push(group.id);
            isExpanded = self.variablePickerStates.extendedCategories.includes(group.id) || self.variablePickerStates.search !== '';
            if(self.variablePickerStates.search === '' || variables.length > 0){
                content += `<div class="brxc-variable-picker__category" data-id="${group.id}" onclick="ADMINBRXC.variablePickerToggleExtandCats(event,'${group.id}')">`; 
                content += `<label class="brxc-input__label has-tooltip${isExpanded ? ' expanded' : ''}">`
                if(self.variablePickerStates.search === '') content += `<div class="handle"><i class="fas fa-grip-vertical"></i></div>`;
                content += `<div class="title">${group.name} <span class="brxc-variable-count">(${variables.length})</span></div>`;
                content += `<div class="show-in-manager" data-balloon="Open in CSS Variable Manager" data-balloon-pos="top" onclick="ADMINBRXC.openVariableCategory('${group.id}')"><i class="fas fa-external-link-alt"></i></div>`;
                content += `<div class="default-expand${isExpandedDefault ? ' expanded' : ''}" data-balloon="${isExpandedDefault ? ' Expanded' : 'Collapsed'} by default" data-balloon-pos="top" onclick="ADMINBRXC.toggleExpandVariableCategory(event,'${group.id}')"><i class="fas fa-expand-alt"></i></div>`;
                if(self.variablePickerStates.search === '') content += `<div class="brxc-collapse-icon down" data-balloon="${isExpanded ? 'Collapse' : 'Expand'}" data-balloon-pos="top-right"><i class="fas fa-chevron-${isExpanded ? 'down' : 'right'}"></i></div>`
                content += `</label>`;
                content += `<div class="brxc-overlay__action-btn-wrapper isotope-container">`;
                if (isExpanded && variables && variables.length > 0){
                    variables.forEach((variable, index) => {
                        let balloon = false;
                        
                        if(variable.hasOwnProperty('type') && variable.type === "clamp" && variable.hasOwnProperty('min') && variable.hasOwnProperty('max')) {
                            balloon = `${variable.min} to ${variable.max} (px)`;
                        } else if(variable.hasOwnProperty('value')) {
                            balloon = variable.value;
                        }
                        const name = `var(--${self.helpers.formatForClasses(variable.name)})`;
                        const global = self.vueState.globalVariables.find(el => el.id === variable.id) ? true : false;
                        const isActive = name === self.variablePickerStates.target.value;
                        
                        content += `<div class="brxc-overlay__action-btn isotope-selector ${global ? 'global' : 'theme'}${isActive ? ' active' : ''}" data-variable="${name}"${balloon ? ` data-balloon="${balloon}" data-balloon-pos="top"` : ''}>${variable.name}${!global ? '<span class="type-indicator"></span>' : ''}</div>`;
                        if(self.helpers.isCSSVariablesTabActive('theme-variables') && index === variables.length - 1){
                            content += `<div class="add-new-variable" data-group="${group.id}" data-balloon="Add a new Global Variable" data-balloon-pos="top"><i class="fas fa-plus"></i></div>`;
                        }
                    })
                } else if(isExpanded && (!variables || variables.length < 1)){
                    content += `<p class="brxc-variable-picker__category-empty" data-control="info">This category is empty.</p>`
                    content += `<div class="add-new-variable" data-group="${group.id}" data-balloon="Add a new Global Variable" data-balloon-pos="top-right"><i class="fas fa-plus"></i></div>`;
                }
                content += `</div></div>`;
            }
            
        })
        content += `</div>`; // end sortable wrapper
        const uncategorizedVars = Array.from(arr).filter(el => el && self.helpers.isVariableUncategorized(el));
        if(uncategorizedVars.length > 0){
            isExpanded = self.variablePickerStates.extendedCategories.includes('uncategorized') || self.variablePickerStates.search !== '';
            content += `<div class="brxc-variable-picker__category no-handle" onclick="ADMINBRXC.variablePickerToggleExtandCats(event,'uncategorized')">`; 
            content += `<label class="brxc-input__label has-tooltip${isExpanded ? ' expanded' : ''}">`
            if(self.variablePickerStates.search === '') content += `<div class="handle" style="opacity: 0;"><i class="fas fa-grip-vertical"></i></div>`;
            content += `<div class="title">Uncategorized <span class="brxc-variable-count">(${uncategorizedVars.length})</span></div>`;
            content += `<div class="show-in-manager" data-balloon="Open in CSS Variable Manager" data-balloon-pos="top" onclick="ADMINBRXC.openVariableCategory('uncategorized')"><i class="fas fa-external-link-alt"></i></div>`;
            if(self.variablePickerStates.search === '') content += `<div class="brxc-collapse-icon down" data-balloon="${isExpanded ? 'Collapse' : 'Expand'}" data-balloon-pos="top-right"><i class="fas fa-chevron-${isExpanded ? 'down' : 'right'}"></i></div>`
            content += `</label>`;
            content += `<div class="brxc-overlay__action-btn-wrapper isotope-container">`;
            if(isExpanded && uncategorizedVars.length > 0){
                uncategorizedVars.forEach((variable, index) => {
                    let balloon = false;
                    
                    if(variable.hasOwnProperty('type') && variable.type === "clamp" && variable.hasOwnProperty('min') && variable.hasOwnProperty('max')) {
                        balloon = `${variable.min} to ${variable.max} (px)`;
                    } else if(variable.hasOwnProperty('value')) {
                        balloon = variable.value;
                    }
                    const name = `var(--${self.helpers.formatForClasses(variable.name)})`;
                    const global = self.vueState.globalVariables.find(el => el.id === variable.id) ? true : false;
                    const isActive = name === self.variablePickerStates.target.value;
                    
                    content += `<div class="brxc-overlay__action-btn isotope-selector ${global ? 'global' : 'theme'}${isActive ? ' active' : ''}" data-variable="${name}"${balloon ? ` data-balloon="${balloon}" data-balloon-pos="top"` : ''}>${variable.name}${!global ? '<span class="type-indicator"></span>' : ''}</div>`;
                    if(self.helpers.isCSSVariablesTabActive('theme-variables') && index === uncategorizedVars.length - 1){
                        content += `<div class="add-new-variable" data-group="uncategorized" data-balloon="Add a new Global Variable" data-balloon-pos="top"><i class="fas fa-plus"></i></div>`;
                    }
                })
            }
        }
        
        content += `</div></div>`
        
        return content;
            
    },
    colorsPopulateGroups: function(firstRun){
        const self = this;
        let content = '<div id="sortableWrapper">';
        let isExpanded = false;
        let isExpandedDefault = false;
        self.vueState.colorPalette
            .filter(el => !el.hasOwnProperty('status') || el.status !== "disabled")
            .forEach(palette => {
            let arr = palette['colors'].filter(el => el.hasOwnProperty('raw'));
            if(self.variablePickerStates.search !== '') arr = arr.filter(el => el && (el.name.includes(self.variablePickerStates.search) || el.raw.includes(self.variablePickerStates.search)));
            isExpandedDefault = palette.hasOwnProperty('defaultExpanded');
            const view = palette.view || 'column';
            if(firstRun && palette.hasOwnProperty('defaultExpanded')) self.variablePickerStates.extendedCategories.push(palette.id);
            isExpanded = self.variablePickerStates.extendedCategories.includes(palette.id) || self.variablePickerStates.search !== '';
            if(arr.length > 0){
                content += `<div class="brxc-variable-picker__category color" data-id="${palette.id}" onclick="ADMINBRXC.variablePickerToggleExtandCats(event,'${palette.id}')">`; 
                content += `<label class="brxc-input__label has-tooltip${isExpanded ? ' expanded' : ''}">`
                if(self.variablePickerStates.search === '') content += `<div class="handle"><i class="fas fa-grip-vertical"></i></div>`;
                content += `<div class="title">${palette.name} <span class="brxc-variable-count">(${arr.length})</span></div>`;
                content += `<div class="show-in-manager" data-balloon="Open in Color Manager" data-balloon-pos="top" onclick="ADMINBRXC.openColorCategory('${palette.id}')"><i class="fas fa-external-link-alt"></i></div>`;
                content += `<div class="default-expand${isExpandedDefault ? ' expanded' : ''}" data-balloon="${isExpandedDefault ? ' Expanded' : 'Collapsed'} by default" data-balloon-pos="top" onclick="ADMINBRXC.toggleExpandColorCategory(event,'${palette.id}')"><i class="fas fa-expand-alt"></i></div>`;
                content += `<div class="brxc-color-views">`;
                content += `<div class="view${view === 'column' ? ' active' : ''}" data-balloon="Column View" data-balloon-pos="top" onclick="ADMINBRXC.toggleViewColorCategory(event,'${palette.id}', 'column')"><i class="ti-layout-column3-alt"></i></div>`;
                content += `<div class="view${view === 'list' ? ' active' : ''}" data-balloon="List View" data-balloon-pos="top" onclick="ADMINBRXC.toggleViewColorCategory(event,'${palette.id}', 'list')"><i class="ti-menu-alt"></i></div>`;
                content += `<div class="view${view === 'grid' ? ' active' : ''}" data-balloon="Grid View" data-balloon-pos="top" onclick="ADMINBRXC.toggleViewColorCategory(event,'${palette.id}', 'grid')"><i class="ti-layout-grid2-alt"></i></div>`;
                content += `</div>`;
                if(self.variablePickerStates.search === '') content += `<div class="brxc-collapse-icon down" data-balloon="${isExpanded ? 'Collapse' : 'Expand'}" data-balloon-pos="top-right"><i class="fas fa-chevron-${isExpanded ? 'down' : 'right'}"></i></div>`
                content += `</label>`;
                content += `<div class="isotope-container brxc-color-container ${view}">`;
                if (isExpanded && arr && arr.length > 0){
                    
                    // Parent Colors
                    const parentColors = arr.filter(el => el.hasOwnProperty('shadeChildren') && Array.isArray(el.shadeChildren) && el.shadeChildren.length > 0);
                    if(parentColors && parentColors.length > 0){
                        parentColors.forEach(parent => {
                            content += `<div>`;
                            content += `<div class="brxc-color-label">${parent.name}</div>`;
                            content += `<div class="brxc-parent-color-container ${view}">`;
                            content += `<div class="brxc-color-wrapper">`;
                            content += `<div class="brxc-color-item" data-variable="${parent.raw}">`;
                            content += `<div class="brxc-overlay__action-btn isotope-selector"${view !== 'list' ? ` data-balloon="${parent.name}" data-balloon-pos="top"`: ''} style="--color:${parent.raw}"></div>`;
                            if(view === "list") content += `<div class="brxc-color-list-label">${parent.name}</div>`;
                            content += `</div></div>`;
                            // Children
                            const childrenColors = arr.filter(el => el.hasOwnProperty('shadeParent') && el.shadeParent === parent.id);
                            if(childrenColors){
                                // Light
                                const lightColors = childrenColors.filter(el => el.shadeType === "Light");
                                if(lightColors && lightColors.length > 0){
                                    content += `<div class="brxc-color-category-wrapper">`;
                                    if(view !== "column") content += `<div class="brxc-color-label">${parent.name} - Light</div>`;
                                    content += `<div class="brxc-color-wrapper">`;
                                    lightColors.forEach(el => {
                                        content += `<div class="brxc-color-item" data-variable="${el.raw}">`;
                                        content += `<div class="brxc-overlay__action-btn isotope-selector"${view !== 'list' ? ` data-balloon="${el.name}" data-balloon-pos="top"`: ''} style="--color:${el.raw}"></div>`;
                                        if(view === "list") content += `<div class="brxc-color-list-label">${el.name}</div>`;
                                        content += `</div>`;
                                    })
                                    content += `</div></div>`;

                                }
                                // Dark
                                const darkColors = childrenColors.filter(el => el.shadeType === "Dark");
                                if(darkColors && darkColors.length > 0){
                                    content += `<div class="brxc-color-category-wrapper">`;
                                    if(view !== "column") content += `<div class="brxc-color-label">${parent.name} - Dark</div>`;
                                    content += `<div class="brxc-color-wrapper">`;
                                    darkColors.forEach(el => {
                                        content += `<div class="brxc-color-item" data-variable="${el.raw}">`;
                                        content += `<div class="brxc-overlay__action-btn isotope-selector"${view !== 'list' ? ` data-balloon="${el.name}" data-balloon-pos="top"`: ''} style="--color:${el.raw}"></div>`;
                                        if(view === "list") content += `<div class="brxc-color-list-label">${el.name}</div>`;
                                        content += `</div>`;
                                    })
                                    content += `</div></div>`;

                                }
                                // Transparent
                                const transparentColors = childrenColors.filter(el => el.shadeType === "Transparent");
                                if(transparentColors && transparentColors.length > 0){
                                    content += `<div class="brxc-color-category-wrapper" style="--bg: url(${self.globalSettings.transparencyCheckboard})">`;
                                    if(view !== "column") content += `<div class="brxc-color-label">${parent.name} - Transparent</div>`;
                                    content += `<div class="brxc-color-wrapper"${view === "column" ? ` style="background-image: var(--bg);"` : ''}>`;
                                    transparentColors.forEach(el => {
                                        content += `<div class="brxc-color-item" data-variable="${el.raw}">`;
                                        content += `<div class="brxc-overlay__action-btn isotope-selector"${view !== 'list' ? ` data-balloon="${el.name}" data-balloon-pos="top"`: ''} style="--color:${el.raw}"></div>`;
                                        if(view === "list") content += `<div class="brxc-color-list-label">${el.name}</div>`;
                                        content += `</div>`;
                                    })
                                    content += `</div></div>`;

                                }
                            }
                             content += `</div></div>`;
                        })
                    }

                    // Others
                    const otherColors = arr.filter(el => (!el.hasOwnProperty('shadeChildren') && !el.hasOwnProperty('shadeParent')) || (el.hasOwnProperty('shadeChildren') && Array.isArray(el.shadeChildren) && el.shadeChildren.length < 1));
                    if(otherColors && otherColors.length > 0){
                        content += `<div style="--bg: url(${self.globalSettings.transparencyCheckboard})"s>`;
                        if(parentColors && parentColors.length > 0) content += `<div class="brxc-color-label">other colors</div>`;
                        content += `<div class="brxc-color-others ${view}">`;
                        otherColors.forEach((el) => {
                            content += `<div class="brxc-color-item" data-variable="${el.raw}">`;
                            content += `<div class="brxc-overlay__action-btn isotope-selector"${view !== 'list' ? ` data-balloon="${el.name}" data-balloon-pos="top"`: ''} style="--color:${el.raw}"></div>`;
                            if(view === "list") content += `<div class="brxc-color-list-label">${el.name}</div>`;
                            content += `</div>`;
                            
                        })
                        content += `</div></div>`;
                    }
                } else if(isExpanded && (!arr || arr.length < 1)){
                    content += `<p class="brxc-variable-picker__category-empty" data-control="info">This category is empty.</p>`
                }
                content += `</div></div>`;
            }
            
        })
        content += `</div>`; // end sortable wrapper
        
        return content;
            
    },
    variablePickerStates: {
        search: '',
        extendedCategories: [],
        target: false,
        clickTarget: false,
        id: false,
        type: 'variable',
    },
    refreshVariablePickerList: function(firstRun){
        const self = this;
        const wrapper = document.querySelector('#brxcVariableOverlay');
        const canvas = wrapper.querySelector('#brxcVariablePickrAT');
        if(canvas){
            content = self.variablePickerStates.type === "variable" ? self.variablePopulateGroups(firstRun) : self.colorsPopulateGroups(firstRun);
            canvas.innerHTML = content;
        }

        // Add Listeners
        const sortableWrapper = wrapper.querySelector('#sortableWrapper');
        const allWrappers = wrapper.querySelectorAll('#brxcVariablePickrAT > div');

        allWrappers.forEach(el => {
            const initialValue = self.variablePickerStates.target.value;

            let wasClicked = false;

            el.addEventListener('mouseover', (event) => {
                const btn = event.target.closest('[data-variable]');
                if (btn && el.contains(btn)) {
                    const dataset = btn.dataset.variable;
                    self.variablePickerStates.target.value = dataset;
                    const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                    self.variablePickerStates.target.dispatchEvent(inputEvent);
                }
            });

            el.addEventListener('mouseout', (event) => {
                const btn = event.target.closest('[data-variable]');
                if (btn && el.contains(btn) && !wasClicked) {
                    self.variablePickerStates.target.value = initialValue;
                    const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                    self.variablePickerStates.target.dispatchEvent(inputEvent);
                }
                wasClicked = false; // Reset the flag after mouseout
            });

            el.addEventListener('mousedown', (event) => {
                const btn = event.target.closest('[data-variable]');
                if (btn && el.contains(btn)) {
                    event.preventDefault();
                    event.stopPropagation();

                    wasClicked = true;

                    const dataset = btn.dataset.variable;
                    self.variablePickerStates.target.value = dataset;
                    const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                    self.variablePickerStates.target.dispatchEvent(inputEvent);
                    
                    self.variablePickerStates.clickTarget.click();
                    self.closeModal(
                        self.variablePickerStates.target,
                        self.variablePickerStates.target.target,
                        self.variablePickerStates.id
                    );
                } 
            });
        })



        // Input new variable

        const newVariables = canvas.querySelectorAll('.add-new-variable');
        if(newVariables.length > 0){
            newVariables.forEach(variable => {
                variable.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    self.setaddVariableFromPicker(e, self.variablePickerStates.target);
                })
            })
        }

        //Drag and drop

        if(sortableWrapper){
            const handles = sortableWrapper.querySelectorAll('.handle');
            if (!handles || handles.length < 2) return;


            new Sortable(sortableWrapper, {
                multiDrag: true,
                selectedClass: "sortable-selected",
                animation: 150,
                handle: ".handle",
                helper: 'clone',
                filter: ".no-handle",
                onEnd: () => {
                    const vars = self.variablePickerStates.type === 'variable' ? self.vueState.globalVariablesCategories : self.vueState.colorPalette;
                    const items = canvas.querySelectorAll('.brxc-variable-picker__category:not(.no-handle)');
                    items.forEach((item, index) => {
                        const target = Array.from(vars).find(el => el && el.hasOwnProperty('id') && el.id === item.dataset.id);
                        if (!target) return;

                        self.helpers.moveArr(vars, vars.indexOf(target), index);
                    });

                    self.refreshVariablePickerList(false);
                },
            });
        }

    },
    openVariableModal: function(target, clickTarget, id, focus = false, type = 'variable'){
        const self = this;

        // Reset States & Search
        self.variablePickerStates.search = '';
        self.variablePickerStates.target = target;
        self.variablePickerStates.clickTarget = clickTarget;
        self.variablePickerStates.id = id;
        self.variablePickerStates.extendedCategories = []
        self.variablePickerStates.type = type;

        // Reset search
        const searches = document.querySelectorAll('#brxcVariableOverlay .brxc-overlay__search-box input[type="search"]');
        if(searches && searches.length > 0) {
            searches.forEach(search => {
                search.value = '';
            })
        }
        const wrapper = document.querySelector(id);
        wrapper.setAttribute('data-active', 'true');

        document.addEventListener('keydown', function(e) {
            (e.key === "Escape") ? self.closeModal(target, target.target, id) : '';
        });
        if(focus) focus.focus()

        // Resize
        const inner = wrapper.querySelector(`.brxc-overlay__inner`);
        const btn = wrapper.querySelector('.brxc-overlay__close-btn')
        inner.style.width = '';
        btn.style.left = '';
        btn.style.right = '';
        if (wrapper.classList.contains('left')) {
            self.calculatePanelWidth('left', inner, btn)
        } else if(wrapper.classList.contains('right')) {
            self.calculatePanelWidth('right', inner, btn)
        } 
        
        // Refresh panels
        const activePanel = wrapper.querySelector('.brxc-overlay__pannels-wrapper');
        activePanel.style.display = "none";
        setTimeout(()=> {activePanel.style.display = "flex"}, 0);


        // Populate the groups
        self.refreshVariablePickerList(true);
        
    },
    openVariableCategory: function(id){
        const self = this;
        self.cssVariablesStates.activeCategory = id;
        self.setCSSVariableManager();
        self.openModal(false, "#brxcCSSVariableManagerOverlay");
    },
    openColorCategory: function(id){
        const self = this;
        self.colorStates.activePalette = id;
        self.setColorManager();
        self.openModal(false, '#brxcColorManagerOverlay');
    },
    plainClassesStates: {
        search: '',
        existingClasses: [], 
        extendedCategories: [],
        target: false,
        id: false,
        
    },
    openPlainClassesModal: function(target, id){
        const self = this;
        self.plainClassesStates.search = '';
        self.plainClassesStates.extendedCategories = [];
        const wrapper = document.querySelector(id);
        const mostUsedCanvas = wrapper.querySelector('#plainClassesMostUsedCanvas');
        const saveBtn = wrapper.querySelector('#brxcSavePlainClasses');
        const cm = wrapper.querySelector('#brxcPlainClassesOverlay .CodeMirror').CodeMirror;
        const elementObj = self.helpers.getFinalObject(true);
        let finalClasses = [];
        if(elementObj.settings.hasOwnProperty('_cssGlobalClasses')) {
            elementObj.settings._cssGlobalClasses.forEach(cls => {
                const obj = Array.from(self.vueState.globalClasses).find(el => el && el.id === cls);
                if(!obj) return;
                finalClasses.push(obj.name);
            })
        }
        self.plainClassesStates.existingClasses = finalClasses;

        const existingClasses = finalClasses.length === 0 ? '' : finalClasses.join(' ') + ' ';
        cm.setValue(existingClasses);
        wrapper.setAttribute('data-active', 'true');

        cm.on("keyup", function (cm, event) {
            self.plainClassesRefreshHighlight();
        });

        document.addEventListener('keydown', function(e) {
            (e.key === "Escape") ? self.closeModal(target, target.target, id) : '';
        });

        // Resize
        const inner = wrapper.querySelector(`.brxc-overlay__inner`);
        const btn = wrapper.querySelector('.brxc-overlay__close-btn')
        inner.style.width = '';
        btn.style.left = '';
        btn.style.right = '';
        if (wrapper.classList.contains('left')) {
            self.calculatePanelWidth('left', inner, btn)
        } else if(wrapper.classList.contains('right')) {
            self.calculatePanelWidth('right', inner, btn)
        } 

        // Refresh panels
        const activePanel = wrapper.querySelector('.brxc-overlay__pannels-wrapper');
        if(activePanel){
            activePanel.style.display = "none";
            setTimeout(()=> {activePanel.style.display = "flex"}, 0);
        }
        
        // Most used Classes;
        let content = '<div class="brxc-overlay__action-btn-wrapper">';
        const mostUsedClasses = self.mostUsedClasses();
        
        if(mostUsedClasses.length > 0){
            content += `<div id="brxcMostUsed"><span>Most Used: </span>${mostUsedClasses.slice(0, 10)
                .filter(el => self.vueGlobalProp.$_getGlobalClass(el))
                .map(el => `<a data-value="${self.vueGlobalProp.$_getGlobalClass(el).name}">.${self.vueGlobalProp.$_getGlobalClass(el).name}</a>`)
                .join('<span>, </span>')}</div>`
        }
        
        content += "</div>";
        mostUsedCanvas.innerHTML = content;

        // // reset values
        
        self.plainClassesRender(true, cm);

        // Event Listeners for Most Used
        const btns = mostUsedCanvas.querySelectorAll('#brxcMostUsed a');
        btns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const value = btn.dataset.value;
                const existing = cm.getValue();
                cm.setValue(`${existing} ${value}`);
                if(e.shiftKey){
                    self.plainClassesRefreshHighlight();
                } else {
                    self.savePlainClasses(saveBtn, cm.getValue());
                }
            })
        })
        
        // Search

        const searchTerm = document.querySelector('#plainClassesSearchWrapper input');
        searchTerm.value = '';
        searchTerm.addEventListener('keyup', () => {
            self.plainClassesStates.search = searchTerm.value;
            self.plainClassesRender(false);
        })


        setTimeout(() => {
            cm.focus();
            cm.setCursor(cm.lineCount(), 0);
        }, 50)
    },

    plainClassesToggleExtandCats: function(event,id){
        const self = this;
        event.preventDefault();
        event.stopPropagation();
        const isIncluded = self.plainClassesStates.extendedCategories.includes(id);
        if(isIncluded){
            self.plainClassesStates.extendedCategories = self.plainClassesStates.extendedCategories.filter(el => el && el !== id);
        } else {
            self.plainClassesStates.extendedCategories.push(id);
        }
        self.plainClassesRender(false);
    },
    plainClassesRender: function(firstRun = false){
        const self = this;
        const overlay = document.querySelector('#brxcPlainClassesOverlay');
        const saveBtn = overlay.querySelector('#brxcSavePlainClasses');
        const cm = overlay.querySelector('.CodeMirror').CodeMirror;
        const searchCanvas = overlay.querySelector('#plainClassesSearchResultsCanvas');
        searchCanvas.innerHTML = self.classesPopulateGroups(firstRun);

        // Event Listeners
        const categories = searchCanvas.querySelectorAll('.brxc-overlay__action-btn-wrapper');
        categories.forEach(category => {
            category.addEventListener('click', handleEvent);
            category.addEventListener('keyup', handleEvent);
        });

        function handleEvent(e) {
            e.stopPropagation();
            e.preventDefault();

            const target = e.target.closest('[data-value]');
            if (!target) return;

            if (e.type === 'keyup' && e.key !== 'Enter') return;

            const newClass = target.dataset.value;
            const existingClasses = cm.getValue().split(' ');
            if(existingClasses.includes(newClass)){
                const index = existingClasses.indexOf(newClass);
                existingClasses.splice(index, 1);
            } else {
                existingClasses.push(newClass);
            }
            cm.setValue(`${existingClasses.join(' ')}`);

            // Check if the Shift key is pressed
            if (e.shiftKey) {
                self.plainClassesRefreshHighlight();
                const searchTerm = document.querySelector('#plainClassesSearchWrapper input');
                if (searchTerm) {
                    searchTerm.focus();
                    searchTerm.setSelectionRange(0, searchTerm.value.length);
                }
            } else {
                self.savePlainClasses(saveBtn, cm.getValue());
            }
        }

        //Drag and drop

        const sortableWrapper = searchCanvas.querySelector('#sortableWrapper');
        const handles = sortableWrapper.querySelectorAll('.handle');
        if (!handles || handles.length < 2) return;


        new Sortable(sortableWrapper, {
            multiDrag: true,
            selectedClass: "sortable-selected",
            animation: 150,
            handle: ".handle",
            helper: 'clone',
            filter: ".no-handle",
            onEnd: () => {
                const vars = self.vueState.globalClassesCategories;
                const items = searchCanvas.querySelectorAll('.brxc-variable-picker__category:not(.no-handle)');
                items.forEach((item, index) => {
                    const target = Array.from(vars).find(el => el && el.hasOwnProperty('id') && el.id === item.dataset.id);
                    if (!target) return;

                    self.helpers.moveArr(vars, vars.indexOf(target), index);
                });

                self.plainClassesRender(false);
            },
        });
    },
    toggleExpandClassCategory: function(e,id){
        e.preventDefault();
        e.stopPropagation();
        const self = this;
        const obj = self.helpers.getClassCategoryObjById(id);
        if(!obj) return;

        if(obj.hasOwnProperty('defaultExpanded')){
            delete obj['defaultExpanded'];
        } else {
            obj['defaultExpanded'] = true;
        };

        self.plainClassesRender();
    },
    classesPopulateGroups: function(firstRun){
        const self = this;
        let content = '<div id="sortableWrapper">';
        let isExpanded = false;
        let isExpandedDefault = false;
        let arr = self.vueState.globalClasses;
        if(self.plainClassesStates.search !== '') arr = arr.filter(el => el && el.name.includes(self.plainClassesStates.search));
        self.vueState.globalClassesCategories.forEach(group => {
            const clsArr = Array.from(arr).filter(el => el && el.category === group.id);
            isExpandedDefault = group.hasOwnProperty('defaultExpanded');
            if(firstRun && group.hasOwnProperty('defaultExpanded')) self.plainClassesStates.extendedCategories.push(group.id);
            isExpanded = self.plainClassesStates.extendedCategories.includes(group.id) || self.plainClassesStates.search !== '';
            if(self.plainClassesStates.search === '' || clsArr.length > 0){
                content += `<div class="brxc-variable-picker__category" data-id="${group.id}" onclick="ADMINBRXC.plainClassesToggleExtandCats(event,'${group.id}')">`; 
                content += `<label class="brxc-input__label has-tooltip${isExpanded ? ' expanded' : ''}">`
                if(self.plainClassesStates.search === '') content += `<div class="handle"><i class="fas fa-grip-vertical"></i></div>`;
                content += `<div class="title">${group.name} <span class="brxc-variable-count">(${clsArr.length})</span></div>`;
                content += `<div class="show-in-manager" data-balloon="Open in the Class Manager" data-balloon-pos="top" onclick="ADMINBRXC.states.classManagerActiveCategory = '${group.id}';ADMINBRXC.openClassManager('global');"><i class="fas fa-external-link-alt"></i></div>`;
                content += `<div class="default-expand${isExpandedDefault ? ' expanded' : ''}" data-balloon="${isExpandedDefault ? ' Expanded' : 'Collapsed'} by default" data-balloon-pos="top" onclick="ADMINBRXC.toggleExpandClassCategory(event,'${group.id}')"><i class="fas fa-expand-alt"></i></div>`;
                if(self.plainClassesStates.search === '') content += `<div class="brxc-collapse-icon down" data-balloon="${isExpanded ? 'Collapse' : 'Expand'}" data-balloon-pos="top-right"><i class="fas fa-chevron-${isExpanded ? 'down' : 'right'}"></i></div>`
                content += `</label>`;
                content += `<div class="brxc-overlay__action-btn-wrapper isotope-container">`;
                if (isExpanded && clsArr && clsArr.length > 0){
                    clsArr.forEach(cls => {
                        const isLocked = self.vueGlobalProp.$_isLocked(cls.id);
                        const existingClass = self.plainClassesStates.existingClasses.includes(cls.name);
                        content += `<div class="brxc-overlay__action-btn isotope-selector${existingClass ? ' active' : ''}" data-value="${cls.name}" tabindex="0">${isLocked ? `<i class="fas fa-lock"></i>`: ''}.${cls.name}</div>`;
                    })
                } else if(isExpanded && (!clsArr || clsArr.length < 1)){
                    content += `<p class="brxc-variable-picker__category-empty" data-control="info">This category is empty.</p>`
                }
                content += `</div></div>`;
            }
            
        })
        content += `</div>`; // end sortable wrapper
        const uncategorizedVars = Array.from(arr).filter(el => el && self.helpers.isClassUncategorized(el));
        if(uncategorizedVars.length > 0){
            isExpanded = self.plainClassesStates.extendedCategories.includes('uncategorized') || self.plainClassesStates.search !== '';
            content += `<div class="brxc-variable-picker__category no-handle" onclick="ADMINBRXC.plainClassesToggleExtandCats(event,'uncategorized')">`; 
            content += `<label class="brxc-input__label has-tooltip${isExpanded ? ' expanded' : ''}">`
            if(self.plainClassesStates.search === '') content += `<div class="handle" style="opacity: 0;"><i class="fas fa-grip-vertical"></i></div>`;
            content += `<div class="title">Uncategorized <span class="brxc-variable-count">(${uncategorizedVars.length})</span></div>`;
            content += `<div class="show-in-manager" data-balloon="Open in CSS Variable Manager" data-balloon-pos="top" onclick="ADMINBRXC.states.classManagerActiveCategory = 'Uncategorized';ADMINBRXC.openClassManager('global');"><i class="fas fa-external-link-alt"></i></div>`;
            if(self.plainClassesStates.search === '') content += `<div class="brxc-collapse-icon down" data-balloon="${isExpanded ? 'Collapse' : 'Expand'}" data-balloon-pos="top-right"><i class="fas fa-chevron-${isExpanded ? 'down' : 'right'}"></i></div>`
            content += `</label>`;
            content += `<div class="brxc-overlay__action-btn-wrapper isotope-container">`;
            if(isExpanded && uncategorizedVars.length > 0){
                uncategorizedVars.forEach(cls => {
                    const isLocked = self.vueGlobalProp.$_isLocked(cls.id);
                    const existingClass = self.plainClassesStates.existingClasses.includes(cls.name);
                    content += `<div class="brxc-overlay__action-btn isotope-selector${existingClass ? ' active' : ''}" data-value="${cls.name}" tabindex="0">${isLocked ? `<i class="fas fa-lock"></i>`: ''}.${cls.name}</div>`;
                })
            }
        }
        
        content += `</div></div>`
        
        return content;
            
    },
    plainClassesRefreshHighlight: function(){
        const self = this;
        const cm = document.querySelector('#brxcPlainClassesOverlay .CodeMirror').CodeMirror;
        const existingClasses = cm.getValue().split(' ');
        self.plainClassesStates.existingClasses = existingClasses;
        const actives = document.querySelectorAll('#brxcPlainClassesOverlay .brxc-overlay__action-btn.isotope-selector.active');
        actives.forEach(el => el.classList.remove('active'));
        existingClasses.forEach(cls => {
            const target = document.querySelector(`#brxcPlainClassesOverlay .brxc-overlay__action-btn.isotope-selector[data-value="${cls}"]`);
            if(!target) return;
            target.classList.add('active');
        }) 

    },
    openAIModal: function(prefix, global = false, target, id){
        const self = this;

        if (global === false){
            // Completion
            const chatMore = document.querySelector('#brxcopenAIOverlay #' + prefix + 'ChatMore');
            const existingInsertBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'InsertContent');
            const existingReplaceBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'ReplaceContent');
            if(existingInsertBtn) existingInsertBtn.remove();
            if(existingReplaceBtn) existingReplaceBtn.remove();
            chatMore.insertAdjacentHTML(
                'afterend',
                '<div id="' + prefix + 'InsertContent" class="brxc-overlay__action-btn"><span>Insert Content</span></div><div id="' + prefix + 'ReplaceContent" class="brxc-overlay__action-btn primary"><span>Replace Content</span></div>'
            );

            const insertBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'InsertContent');
            insertBtn.addEventListener('click', () =>{
                const value = document.querySelector('#brxcopenAIOverlay input[name="openai-results"]:checked + label .message.assistant').textContent;
                target.value += value.replaceAll(/\n/g,'<br>');
                const event = new Event('input', {
                    bubbles: true,
                    cancelable: true,
                });
                target.dispatchEvent(event);
                self.closeModal(target, target.target, id);
                self.vueGlobalProp.$_showMessage('AI Content Inserted');
            })
            const replaceBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'ReplaceContent');
            replaceBtn.addEventListener('click', () =>{
                const value = document.querySelector('#brxcopenAIOverlay input[name="openai-results"]:checked + label .message.assistant').textContent;
                target.value = value.replaceAll(/\n/g,'<br>');
                const event = new Event('input', {
                    bubbles: true,
                    cancelable: true,
                });
                target.dispatchEvent(event);
                self.closeModal(target, target.target, id);
                self.vueGlobalProp.$_showMessage('AI Content Inserted');
            })

            // Edit
            const editTextArea = document.querySelector('#brxcopenAIOverlay #' + prefix + 'EditText');
            const editbtnwrapper = document.querySelector('#brxcopenAIOverlay #' + prefix + 'InsertEditContentWrapper')
            const existingInsertEditBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'InsertEditContent');
            const existingReplaceEditBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'ReplaceEditContent');
            if(existingInsertEditBtn) existingInsertEditBtn.remove();
            if(existingReplaceEditBtn) existingReplaceEditBtn.remove();
            editTextArea.value = target.value.replaceAll('<br>', '\n');
            editbtnwrapper.innerHTML += '<div id="' + prefix + 'InsertEditContent" class="brxc-overlay__action-btn"><span>Insert Content</span></div>';
            editbtnwrapper.innerHTML += '<div id="' + prefix + 'ReplaceEditContent" class="brxc-overlay__action-btn primary"><span>Replace Content</span></div>';
            const insertEditBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'InsertEditContent');
            insertEditBtn.addEventListener('click', () =>{
                const value = document.querySelector('#brxcopenAIOverlay input[name="openai-edit-results"]:checked + label .message.assistant').textContent;
                target.value += value.replaceAll(/\n/g,'<br>');
                const event = new Event('input', {
                    bubbles: true,
                    cancelable: true,
                });
                target.dispatchEvent(event);
                self.closeModal(target, target.target, id);
                //self.showMessage('AI Content Inserted')
                self.vueGlobalProp.$_showMessage('AI Content Inserted');
            })
            const replaceEditBtn = document.querySelector('#brxcopenAIOverlay #' + prefix + 'ReplaceEditContent');
            replaceEditBtn.addEventListener('click', () =>{
                const value = document.querySelector('#brxcopenAIOverlay input[name="openai-edit-results"]:checked + label .message.assistant').textContent;
                target.value = value.replaceAll(/\n/g,'<br>');
                const event = new Event('input', {
                    bubbles: true,
                    cancelable: true,
                });
                target.dispatchEvent(event);
                self.closeModal(target, target.target, id);
                //self.showMessage('AI Content Inserted')
                self.vueGlobalProp.$_showMessage('AI Content Inserted');
            })
        }

        // Open modal
        const wrapper = document.querySelector(id);
        wrapper.setAttribute('data-active', 'true');
        document.addEventListener('keydown', function(e) {
            (e.key === "Escape") ? self.closeModal(target, target.target, id) : '';
        });
    },
    openExtendClassModal: function(target,id){
        const self = this;
        const select = document.querySelector('#brxcExtendModal #brxc-extendcategoryOptions');
        const elementObj = self.helpers.getFinalObject(true);
        select.value = elementObj.name;
        const wrapper = document.querySelector(id);
        wrapper.setAttribute('data-active', 'true');
        document.addEventListener('keydown', function(e) {
            (e.key === "Escape") ? self.closeModal(target, target.target, id) : '';
        });
    },
    openFindReplaceModal: function(target,global, id){
        const self = this;
        const wrapper = document.querySelector(id);
        const posRadios = document.querySelectorAll('#brxcFindReplaceModal [name=brxc-findreplacePosition]');
        const select = document.querySelector('#brxcFindReplaceModal #brxc-findreplacecategoryOptions');
        const alert = document.querySelector('#brxcFindReplaceModal .alert');
        const elementObj = self.helpers.getFinalObject(true);

        if (global){
            select.value = 'all';
            const pageRadio = document.querySelector('#brxcFindReplaceModal #brxc-findreplace-page');
            pageRadio.dispatchEvent(new MouseEvent('click'));
            posRadios.forEach(radio => {
                radio.setAttribute('disabled', true);
            })
            alert.classList.add('active');

        } else {
            select.value = elementObj.name;
            const SiblingRadio = document.querySelector('#brxcFindReplaceModal #brxc-findreplace-siblings');
            SiblingRadio.dispatchEvent(new MouseEvent('click'));
            posRadios.forEach(radio => {
                radio.removeAttribute('disabled');
            })
            alert.classList.remove('active');
        }
        wrapper.setAttribute('data-active', 'true');
        document.addEventListener('keydown', function(e) {
            (e.key === "Escape") ? self.closeModal(target, target.target, id) : '';
        });
    },
    generateGlobalClass: function(prefix,name, cat, id = false){
        const self = this;
        const newId = id !== false ? id : self.vueGlobalProp.$_generateId();
        const obj = {
            id: prefix + newId,
            name: name,
            settings: {},
        }
        if(cat && typeof self.vueState.globalClassesCategories !== "undefined"){
            if(self.helpers.getClassCategoryIdByName(cat)){
                obj.category = self.helpers.getClassCategoryIdByName(cat);
            } else {
                const catId = self.vueGlobalProp.$_generateId();
                self.vueState.globalClassesCategories.push({
                    id: catId,
                    name: cat,
                })
                obj.category = catId;
            }
        }
        self.vueState.globalClasses.push(obj)
        self.populateClassCategories();

        return id;
    },
    importedClasses: function(){
        const self = this;
        let settingsHaveChanged = false;
        let existingClassesId = [];
        const globalClasses = self.vueState.globalClasses;
        const importedClasses = self.globalSettings.importedClasses;
        if (importedClasses.length > 0){
            importedClasses.forEach(e => {
                globalClasses.forEach((item) => { 
                    if (item.name === e) { 
                        existingClassesId.push({id: item.id,name: item.name});
                    }
                }); 
            })

            const importedClassesToCreate = importedClasses.filter(str => str && !existingClassesId.some(obj => obj && obj.hasOwnProperty('name') && obj.name === str));
            if (importedClassesToCreate.length > 0){
                importedClassesToCreate.forEach( e => {
                    self.generateGlobalClass('brxc_imported_',e,false);
                    settingsHaveChanged = true;

                })
            }
        }

        //Remove classes

        for (let i = 0; i < globalClasses.length; i++) { 
            const obj = globalClasses[i]; 
            const isImported = obj.id.includes('brxc_imported');  
            const isIncluded = importedClasses.includes(obj.name);
            if (isImported && isIncluded) {
                continue;
            } 
            if (isImported && !isIncluded) { 
                self.vueState.globalClasses.splice(i, 1);
                settingsHaveChanged = true;
                i--; 
            }
        }

        // Update DB
        if (settingsHaveChanged === true) {
            self.helpers.saveChanges('globalClasses');
            self.helpers.saveChanges('globalClassesLocked');
        }
    },
    importedGrids: function(){
        const self = this;

        // Grids utility classes are disabled
        if(!self.helpers.isClassesAndStylesTabActive() || !self.globalSettings.generalCats.classesAndStyles.includes('grids')){
            const existingGrids = Array.from(self.vueState.globalClasses).filter(el => el && el.hasOwnProperty('id') && el.id.startsWith('brxc_grid_'));
            if(existingGrids && Array.isArray(existingGrids) && existingGrids.length > 0){
                existingGrids.forEach(cls => {
                    const index = self.vueState.globalClasses.indexOf(cls);
                    if(index > -1) self.vueState.globalClasses.splice(index, 1);

                    if(self.vueState.globalClassesLocked.includes(cls.id)) self.vueState.globalClassesLocked.splice(self.vueState.globalClassesLocked.indexOf(cls.id), 1);
                })
                self.helpers.saveChanges('globalClasses');
                self.helpers.saveChanges('globalClassesLocked');
            }
            return;
        }

        let settingsHaveChanged = false;
        const grids = self.globalSettings.gridClasses;
        if (grids.length > 0){
            grids.forEach(e => {
                const classFound = Array.from(self.vueState.globalClasses).find(el => el && el.hasOwnProperty('name') && el.name === e);

                // Create Class
                if(!classFound){
                    const newId = `brxc_grid_${self.helpers.formatForClasses(e)}`;
                    self.vueState.globalClasses.push({
                        id: newId,
                        name: self.helpers.formatForClasses(e),
                        settings:{},
                    })
                    if(!self.vueState.globalClassesLocked.includes(newId)) self.vueState.globalClassesLocked.push(newId);
                    settingsHaveChanged = true;
                    
                }
            })
        }
        
        //Remove classes
        const removedClasses = Array.from(self.vueState.globalClasses).filter(el => el && el.hasOwnProperty('id') && el.hasOwnProperty('name') && el.id.startsWith('brxc_grid_') && !grids.includes(el.name));
        if(removedClasses && Array.isArray(removedClasses) && removedClasses.length > 0){
            removedClasses.forEach(cls => {
                const index = self.vueState.globalClasses.indexOf(cls);
                if(index > -1) self.vueState.globalClasses.splice(index, 1);

                if(self.vueState.globalClassesLocked.includes(cls.id)) self.vueState.globalClassesLocked.splice(self.vueState.globalClassesLocked.indexOf(cls.id), 1);
            })
            settingsHaveChanged = true;
        }

        // Update DB
        if (settingsHaveChanged === true) {
            self.helpers.saveChanges('globalClasses');
            self.helpers.saveChanges('globalClassesLocked');
        }

        
    },
    savePlainClasses: function(target,classes) {
        const self = this;
        let finalClasses = []
        let newClasses = [];
        const globalClasses = self.vueState.globalClasses;
        const elementObj = self.helpers.getFinalObject(true);
        if (classes) {
           newClasses = classes.split(/\s+/).filter(word => word.trim() !== '').filter((value, index, array) => array.indexOf(value) === index);
        }
  
        if (newClasses.length > 0){
            newClasses.forEach(e => {
                const existingClass = Array.from(globalClasses).find(el => el && el.hasOwnProperty('id') && el.hasOwnProperty('name') && el.name === e);
                if(existingClass) {
                    finalClasses.push(existingClass.id);
                    return;
                }

                const id = self.vueGlobalProp.$_generateId();
                self.generateGlobalClass('', e, false, id);
                finalClasses.push(id)
            })
        }
        elementObj.settings._cssGlobalClasses = [...new Set(finalClasses)];

        setTimeout(self.closeModal(target, target.target, '#brxcPlainClassesOverlay'), 300);
        self.vueGlobalProp.$_showMessage('Classes updated!');
    },
    resetClasses: function(target){
        const self = this;
        self.savePlainClasses(target, '');
        const elementObj = self.helpers.getFinalObject(true);
        if (typeof elementObj.settings !== "undefined" && elementObj.settings.hasOwnProperty('_cssGlobalClasses')) delete elementObj.settings._cssGlobalClasses;
        self.closeModal(target, target.target, '#brxcPlainClassesOverlay');
        self.vueGlobalProp.$_showMessage('Classes reset successfully!');
    },
    mostUsedClasses: function(){
        const self = this;

        const counts = {};
        const contentArray = self.helpers.getContent() || [];
        const inputArray = [].concat(...contentArray.filter(el => el.settings.hasOwnProperty('_cssGlobalClasses')).map(el => [...el.settings._cssGlobalClasses]));
        
        inputArray.forEach((element) => {
            counts[element] = (counts[element] || 0) + 1;
        });

        const sortedArray = inputArray.sort((a, b) => counts[b] - counts[a]);

        return [...new Set(sortedArray)];
    },
    closeModal: function(event, target, id, closeAllBtns = false){
        const self = this;
        if( event.target !== target ) {
            return;
        }
        if (typeof event.preventDefault === 'function') event.preventDefault();
        if (typeof event.stopPropagation === 'function') event.stopPropagation();
        const wrapper = document.querySelector(id);
        wrapper.removeAttribute('data-active');
        if(closeAllBtns === true) return;

        // Variable Picker
        if( id === "#brxcVariableOverlay"){
            const btns = wrapper.querySelectorAll('.brxc-overlay__action-btn.active');
            btns.forEach(btn => { btn.classList.remove('active');})
        }

        // Advanced CSS
        if( id === "#brxcCSSOverlay"){
            self.disableSelectorPicker();
        }

    },
    closeTemplateModal: function(){
        const self = this;
        const overlay = document.querySelector('#brxcRemoteTemplatesOverlay');
        document.body.removeAttribute('data-quick-remote-template');
        overlay.removeAttribute('data-active');
        Object.values(self.globalSettings.globalFeatures).includes('zoom-out') ? self.zoomOut(false,true) : '';
    },
    addLorem: function(target, btn) {
        const self = this;
        let used = parseInt(btn.dataset.used);
        let tempArr;
        let arr;
        (self.globalSettings['loremIpsumtype'] === 'human') ? tempArr = ADMINBRXC.globalSettings.customDummyContent.split('\n') : tempArr = ADMINBRXC.loremSentences;
        (used === tempArr.length) ? arr = tempArr : arr = tempArr.slice(used);
        
        target.value = `${target.value} ${arr[0]}`;
        
        (used === tempArr.length) ? btn.setAttribute('data-used', 1) : btn.setAttribute('data-used', used + 1);
        const event = new Event('input', {
            bubbles: true,
            cancelable: true,
        });
          
        target.dispatchEvent(event);
    },
    completionAPIRequest: function(prefix, global, overlay, target, history, n, json, type){
        const self = this;
        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce
            },
            success: function(response) {
                const post = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'Authorization' : 'Bearer '+ response,
                        },
                      body: JSON.stringify(json)
                    });
                    const content = await rawResponse.json();
                    if(content.error){
                        self.insertErrorMessage(prefix, global, overlay, content.error.message);
                        target.classList.remove('disable');
                    } else {
                        for(i=0; i<n;i++){
                            if(type === "chat"){
                                self.insertAIResponse(prefix, global, overlay, content.choices[i].message.content.trim(), i);
                            } else if(type === "edit"){
                                self.insertAIEditResponse(prefix, global, overlay, content.choices[i].message.content.trim(), i);
                            } else if(type === "code"){
                                self.insertAICodeResponse(prefix, global, overlay, content.choices[i].message.content.trim(), i);
                            }
                        }
                        target.classList.remove('disable');
                        history['assistant'] = content;
                        self.aihistory.push(history);
                    }
                };
                post();
            },
            error: function(response){
                console.log('Something went wrong with the OpenAI AJAX request: ' + response);
                target.classList.remove('disable');
            }
        });

    },
    whisperAPIRequest: function(prefix, global, overlay, target, history, audioBlob, ext, callback){
        const self = this;

        const formData = new FormData();
        formData.append('file', audioBlob, `audio.${ext}`);
        formData.append('model', 'whisper-1');
        formData.append('language', language);
        formData.append('temp', temp);

        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce
            },
            success: function(response) {
                const post = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization' : 'Bearer '+ response,
                        },
                    body: formData
                    });
                    const content = await rawResponse.json();
                    if(content.error){
                        self.insertErrorMessage(prefix, global, overlay, content.error.message);
                        target.classList.remove('disable');
                    } else {
                        callback(content.text);
                        target.classList.remove('disable');
                        history['assistant']['text'] = content.text;
                        self.aihistory.push(history);
                    }
                };
                post();
            },
            error: function(response){
                console.log('Something went wrong with the OpenAI AJAX request: ' + response);
                target.classList.remove('disable');
            }
        });

    },
    TTSAPIRequest: function(prefix, global, overlay, target, history, input, voice, speed, callback){
        const self = this;
        const audioPlayer = document.querySelector('#brxcAudioPlayer');
        const finalVoice = voice || 'alloy';
        const finalSpeed = speed || 1;
        let json = {
            "model": "tts-1-hd", 
            "input": input,
            "voice": finalVoice,
            "speed": finalSpeed,
            "response_format": "mp3",
        };
        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce
            },
            success: function(response) {
                callback(response, json);
            },
            error: function(response){
                console.log('Something went wrong with the OpenAI AJAX request: ' + response);
                target.classList.remove('disable');
            }
        });

    },
    generateAudioTranscription: function(prefix, target, global, overlay, language, temp){
        const self = this;
        const fileInput = document.querySelector('#brxcTTSInput');
        let history = [];

        target.classList.add('disable');
        function handleFileInput() {
            if (fileInput.files.length > 0) {
                const audioFile = fileInput.files[0];
                const filename = audioFile.name
                let last_dot = filename.lastIndexOf('.')
                let ext = filename.slice(last_dot + 1)
        
                // Read the contents of the selected file as a Blob
                const reader = new FileReader();
        
                reader.onload = function (loadEvent) {
                    const audioBlob = new Blob([loadEvent.target.result], { type: audioFile.type });

                    // API Request
                    history['user'] = {
                        date: Date.now(),
                        type: 'audio',
                        language: language,
                        temperature: temp,
                        message: 'Requested Audio Transcription.',
                    }  
                    history['assistant'] = {
                        text: '',
                    } 
                    self.whisperAPIRequest(prefix, global, overlay, target, history, language, temp, audioBlob, ext,  function (transcription) {
                        // Handle the transcription result, e.g., display it on the UI
                        const canvas = document.querySelector('#brxcTTSCanvas');
                        let content =  `<div class="brxc-ai-response-wrapper remove-on-reset">
                                            <input type="radio" id="brxc3SIfHu" name="global-openai-results">
                                            <label for="brxc3SIfHu" class="brxc-input__label">
                                                <p>OpenAI Assistant</p>
                                                <pre name="global-openai-prompt-response" class="message assistant" id="global-openaiPromptResponse">
                                                    <code>${transcription}</code>
                                                </pre>
                                            </label>
                                        </div>`;
                        canvas.innerHTML = content;
                    });
                };
        
                reader.readAsArrayBuffer(audioFile);
            }
        }
        handleFileInput()
    },
    generateAudioSpeech: function(prefix, target, global, overlay, input, voice, speed){
        const self = this;
        const audioPlayer = document.querySelector('#brxcAudioPlayer');
        let history = [];

        target.classList.add('disable');
        
        self.TTSAPIRequest(prefix, global, overlay, target, history, input, voice, speed, function (response, json) {
            var oHttp = new XMLHttpRequest();
                oHttp.open("POST", "https://api.openai.com/v1/audio/speech");
                oHttp.setRequestHeader("Accept", "audio/mp3");
                oHttp.setRequestHeader("Content-Type", "application/json");
                oHttp.setRequestHeader("Authorization", "Bearer " + response);

                oHttp.onload = function () {
                    if (oHttp.readyState === 4) {

                        var oBlob = new Blob([this.response], { "type": "audio/mp3" });
                        var audioURL = window.URL.createObjectURL(oBlob);
                        audioPlayer.src = audioURL;
                        audioPlayer.play();
                        target.classList.remove('disable');
                    }
                };

                oHttp.responseType = "arraybuffer";
                oHttp.send(JSON.stringify(json));
        });
    },
    getAIResponse: function(prefix, target, global = false, overlay, voiceTones, customToneVal, temp = 0, maxTokens = 15, n = 1, topP = 1, pres = 0, freq = 0, model){
        const self = this;
        target.classList.add('disable');
        let message = [];
        let history = [];
        let tones = [];
        let tone = '';
        if (voiceTones.length > 0){
            if(customToneVal && Array.from(voiceTones).filter(el => el && el.dataset.tone == 'custom').length > 0 && voiceTones.length === 1){
                tone = customToneVal;
            } else {
                let customTone = '';
                if(customToneVal && Array.from(voiceTones).filter(el => el && el.dataset.tone == 'custom').length > 0){
                    customTone = ' ' + customToneVal;
                };
                Array.from(voiceTones).filter(el => {
                    if (el.dataset.tone != 'custom'){
                        tones.push(el.dataset.tone);
                    }
                });
                tone = 'Adjust the tone of the text to be ' + tones.join(" and ") + '.' + customTone;
            }
            message.push({"role": "system", "content": tone});
        }
        const fmessages = document.querySelectorAll(overlay + ' .brxc-overlay__pannel.completion .message');
        fmessages.forEach(fmessage => {
            if(fmessage.classList.contains('user')){
                message.push({"role": "user", "content": fmessage.value});
            } else {
                message.push({"role": "assistant", "content": fmessage.textContent});
            }
        })
        history['user'] = {
                date: Date.now(),
                type: 'completion',
                system: tone,
                message: message[message.length - 1].content,
                maxTokens: maxTokens,
                choices: n,
                temperature: temp,
                top_p: topP,
                presence_penalty: pres,
                frequency_penalty: freq,
        }

        let json = {
            "model": model, 
            "messages": message,
            "max_tokens": maxTokens,
        };

        if (n != 1) json.n = n;
        if (temp != 1) json.temperature = Number.parseFloat(temp);
        if (topP != 1) json.top_p = Number.parseFloat(topP);
        if (pres != 0) json.presence_penalty = Number.parseFloat(pres);
        if (freq != 0) json.frequency_penalty = Number.parseFloat(freq);

        self.completionAPIRequest(prefix, global, overlay, target, history, n, json, 'chat');
    },
    getEditAIResponse: function(prefix, target, global = false, overlay, voiceTones, customToneVal, temp = 0, maxTokens, n = 1, topP = 1, pres = 0, freq = 0, model){
        const self = this;
        target.classList.add('disable');
        const instruction = document.querySelector(overlay + ' .brxc-overlay__pannel.edit .instruction').value;
        let message = [];
        let history = [];
        let tones = [];
        let tone = 'You are an helpful assistant.';
        if (voiceTones.length > 0){
            Array.from(voiceTones).filter(el => {
                if (el.dataset.tone != 'custom'){
                    tones.push(el.dataset.tone);
                }
            });
            tone += 'Adjust the tone of the text to be ' + tones.join(" and ") + '.';
        }
        message.push({"role": "system", "content": tone});

        const fmessages = document.querySelectorAll(overlay + ' .brxc-overlay__pannel.edit .message');
        fmessages.forEach(fmessage => {
            if(fmessage.classList.contains('user')){
                message.push({"role": "user", "content": `Here is the content: "${fmessage.value}". Here are the instructions: "${instruction}."`});
            } else if (fmessage.classList.contains('assistant')){
                message.push({"role": "assistant", "content": fmessage.textContent});
            }
        })
        history['user'] = {
                date: Date.now(),
                type: 'completion',
                system: tone,
                message: message[message.length - 1].content,
                maxTokens: maxTokens,
                choices: n,
                temperature: temp,
                top_p: topP,
                presence_penalty: pres,
                frequency_penalty: freq,
        }

        let json = {
            "model": model, 
            "messages": message,
            "max_tokens": maxTokens,
        };

        if (n != 1) json.n = n;
        if (temp != 1) json.temperature = Number.parseFloat(temp);
        if (topP != 1) json.top_p = Number.parseFloat(topP);
        if (pres != 0) json.presence_penalty = Number.parseFloat(pres);
        if (freq != 0) json.frequency_penalty = Number.parseFloat(freq);

        self.completionAPIRequest(prefix, global, overlay, target, history, n, json, 'edit');
    },
    getImageAIResponse: function(prefix, target,global = false, overlay, n = 1, size = "256x256"){
        const self = this;
        target.classList.add('disable');
        const prompt = document.querySelector(overlay + ' .brxc-overlay__pannel.image .message.input').value;
        let history = [];
        history['user'] = {
            date: Date.now(),
            type: 'images',
            message: prompt,
            choices: parseInt(n),
            sizes: size,
        }
        const api = () => {
            jQuery.ajax({
                type: 'POST',
                url: openai_ajax_req.ajax_url,
                data: {
                    action: 'openai_ajax_function',
                    nonce: openai_ajax_req.nonce
                },
                success: function(response) {
                    const post = async () => {
                        const rawResponse = await fetch('https://api.openai.com/v1/images/generations', {
                          method: 'POST',
                          headers: {
                              'Content-Type': 'application/json',
                              'Authorization' : 'Bearer '+ response,
                            },
                          body: JSON.stringify({
                            "prompt": prompt,
                            "n": n,
                            "size": size,
                            "response_format": "b64_json"
                            })
                        });
                        const content = await rawResponse.json();
                        if(content.error){
                            self.insertErrorMessage(prefix, global, overlay, content.error.message);
                            target.classList.remove('disable');
                        } else {
                            self.insertAIImagesResponse(prefix, global, overlay, content.data, n);
                            target.classList.remove('disable');
                            history['assistant'] = content;
                            self.aihistory.push(history);
                        }
                    };
                    post();
                },
                error: function(response){
                    console.log('Something went wrong with the OpenAI ImageAJAX request: ' + response);
                    target.classList.remove('disable');
                }
            });
        }
        api();
    },
    getCodeAIResponse: function(prefix, target, global = false, overlay, temp = 0, maxTokens, n = 1, topP = 1, pres = 0, freq = 0, model){
        const self = this;
        target.classList.add('disable');
        //const input = "/* Write The following request using CSS only (No HTML, Javavascript, SCSS or SASS). The request: " + document.querySelector(overlay + ' .brxc-overlay__pannel.code .input').value + " */";
        let history = [];
        let message = [{"role": "system", "content": "You are an helpful assistant and a CSS Expert. You just write vanilla CSS codes only (No HTML, Javavascript). Your entire response need to be valid CSS code, because the result is automatically inserted in CSS stylesheet."}];
        const fmessages = document.querySelectorAll(overlay + ' .brxc-overlay__pannel.code .message');
        fmessages.forEach(fmessage => {
            if(fmessage.classList.contains('user')){
                message.push({"role": "user", "content": `/* The following request is meant to be pasted in a CSS file AS IT, so comment any text accordingly. Here is the request: ${fmessage.value} */`});
            }
        })
        history['user'] = {
            date: Date.now(),
            type: 'code',
            message: message[message.length - 1].content,
            maxTokens: 4000,
            choices: n,
            temperature: temp,
            top_p: topP,
            presence_penalty: pres,
            frequency_penalty: freq,
        }

        let json = {
            "model": model, 
            "messages": message,
            "max_tokens": maxTokens,
        };

        if (n != 1) json.n = n;
        if (temp != 1) json.temperature = Number.parseFloat(temp);
        if (topP != 1) json.top_p = Number.parseFloat(topP);
        if (pres != 0) json.presence_penalty = Number.parseFloat(pres);
        if (freq != 0) json.frequency_penalty = Number.parseFloat(freq);

        self.completionAPIRequest(prefix, global, overlay, target, history, n, json, 'code');
    },
    insertErrorMessage: function(prefix, global, overlay, response){
        const self = this;
  
        const wrapper = document.querySelector(overlay + ' .brxc-overlay__error-message-wrapper');
        let inner = `<div class="brxc-ai-response-wrapper remove-on-reset">`;
        inner += `<div name="${prefix}-prompt-response" class="error-message" id="${prefix}ErrorMsg"><i class="bricks-svg ti-close" onClick="this.parentElement.parentElement.remove()"></i>OpenAI API returned an error with the following message: "${response}"</div></div>`;

        wrapper.innerHTML = inner;
        
    },
    saveAIImagetoMediaLibrary: function(target,imageUrl) {
        target.classList.add('disable');
        const api = () => {
            jQuery.ajax({
                type: 'POST',
                url: openai_ajax_req.ajax_url,
                data: {
                    action: 'openai_save_image_to_media_library',
                    nonce: openai_ajax_req.nonce,
                    image_url: imageUrl,
                },
                success: function(response) {
                    target.classList.remove('disable');
                    target.textContent = 'Image saved successfully!';
                    setTimeout(() => {
                            target.textContent = 'Save to Media Library';
                    }, 1000)
                },
                error: function(response) {
                    target.classList.remove('disable');
                    target.textContent = 'Error - Something went wrong!';
                    setTimeout(() => {
                            target.textContent = 'Save to Media Library';
                    }, 1000)
                },
            });
        }
        api();
    },
    downloadAIImage: function (src){
        const a = document.createElement("a");
        a.href = src;
        a.download = "AI-Image.png";
        a.click();
        a.remove();
    },
    resizeResourceImg: function(target){
        const panel = target.closest('.brxc-overlay__pannel');
        const img = panel.querySelector('.brxc-overlay__img img');
        img.style.scale = parseFloat(target.value);
    },
    movePanel: (wrapper, value) => {
        wrapper.style.transform = 'translateX(' + value + ')';
    },
    insertAIResponse: function (prefix, global, overlay, response, n){
        const self = this;
        const randClass = self.randomize(6);
        const wrapper = document.querySelector(overlay + ' .brxc-overlay__pannel.completion #' + prefix + 'InsertContentWrapper')
        const generateWrapper = document.querySelector(overlay + ' .brxc-overlay__pannel.completion #' + prefix + 'GenerateContentWrapper');
        generateWrapper.classList.toggle('active');
        let inner = `<div class="brxc-ai-response-wrapper remove-on-reset"><input type="radio" id="brxc${randClass}" name="openai-results"><label for="brxc${randClass}" class="brxc-input__label">`;
        if (n === 0 ) {
            inner += "<p>OpenAI Assistant</p>";
        }
        inner += `<pre name="${prefix}-prompt-response" class="message assistant" id="${prefix}PromptResponse"><code>${response}</code></pre></label></div>`;

        wrapper.insertAdjacentHTML(
            'beforebegin',
            inner
        );
        const radios = document.querySelectorAll('input[name="openai-results"]')
        radios[radios.length - 1].checked = true;
    },
    insertAIEditResponse: function (prefix, global, overlay, response, n){
        const self = this;
        const randClass = self.randomize(6);
        const wrapper = document.querySelector(overlay + ' .brxc-overlay__pannel.edit #' + prefix + 'InsertEditContentWrapper');
        const generateWrapper = document.querySelector(overlay + ' .brxc-overlay__pannel.edit #' + prefix + 'GenerateEditContentWrapper');
        generateWrapper.classList.toggle('active');
        let inner = `<div class="brxc-ai-response-wrapper remove-on-reset"><input type="radio" id="brxc${randClass}" name="${prefix}-edit-results"><label for="brxc${randClass}" class="brxc-input__label">`;
        if (n === 0 ) {
            inner += "<p>OpenAI Assistant</p>";
        }
        inner += `<pre name="${prefix}-prompt-response" class="message assistant" id="${prefix}PromptResponse"><code>${response}</code></pre></label></div>`;
        wrapper.insertAdjacentHTML(
            'beforebegin',
            inner
        );
        const radios = document.querySelectorAll('input[name="' + prefix + '-edit-results"]')
        radios[radios.length - 1].checked = true;
    },
    insertAIImagesResponse: function (prefix, global, overlay, response, n){
        const self = this;
        const wrapper = document.querySelector(overlay + ' .brxc-overlay__pannel.image #' + prefix + 'InsertImagesContentWrapper')
        const generateWrapper = document.querySelector(overlay + ' .brxc-overlay__pannel.image #' + prefix + 'GenerateImagesContentWrapper');
        generateWrapper.classList.toggle('active');
        inner = `<div class="brxc-ai-response-wrapper remove-on-reset">
                 <label class="brxc-input__label">OpenAI Assistant</label>
                 <div class='brxc__img-wrapper'>`;
        for(i = 0; i<n; i++){
            const randClass = self.randomize(6);
            inner += `<input type="radio" id="brxc${randClass}" name="${prefix}-images-results">
                  <label for="brxc${randClass}" class="brxc-input__label">
                    <img src="data:image/png;base64,${response[i].b64_json}" alt="" class="brxc__image" />
                  </label>`;         
        }
        inner += "</div></div>";
        wrapper.insertAdjacentHTML(
            'beforebegin',
            inner
        );
        const radios = document.querySelectorAll('input[name="' + prefix + '-images-results"]')
        radios[radios.length - 1].checked = true;
    },
    chatMoreAIResponse: function (prefix, global = false, overlay){
        const wrapper = document.querySelector(overlay + ' #' + prefix + 'InsertContentWrapper')
        wrapper.insertAdjacentHTML(
            'beforebegin',
            `<label for="${prefix}PromptText" class="brxc-input__label remove-on-reset">User Prompt (Required)</label><textarea name="${prefix}-prompt-text" id="${prefix}PromptText" class="${prefix}-prompt-text message user remove-on-reset" placeholder="Type your prompt text here..." cols="30" rows="3" spellcheck="false"></textarea>`
        );
        const container = document.querySelector(overlay + ' .brxc-overlay__pannel.completion')
        const btns = document.querySelector(overlay + ' .brxc-overlay__pannel.completion #' + prefix + 'GenerateContentWrapper')
        btns.classList.toggle('active');
        container.insertBefore(btns, wrapper);

    },
    resetAIresponses: (resets, removes, generate) => {
        resets.forEach(reset => {reset.value = ''});
        removes.forEach(el => {el.remove()});
        const generateWrapper = generate;
        generateWrapper.classList.add('active');
    },
    toggleCustomToneVoice: (prefix, custom) => {
        let input = document.querySelector('#' + prefix + 'System');
        if ( custom.checked==true ) {
            input.style.display = 'block';
        } else {
            input.style.display = 'none';
        }

    },
    toggleRadioVisibility: function(){
        const radios = document.querySelectorAll('[name="brxc-extend-styles"]');
        const target = document.querySelector('#brxc-extend-css-property');
        const eraseClass = document.querySelector('#brxc-extend-erase-classes');
        radios.forEach(radio => {
            radio.addEventListener('change', () =>{
                const radio = document.querySelector('#brxc-extend-style');
                (radio.checked == true) ? target.style.display = 'block' : target.style.display = 'none';
                (radio.checked == true) ? eraseClass.style.display = 'none' : eraseClass.style.display = 'block';
            })
        })

    },
    mounAIHistory: function(prefix, overlay){
        const self = this;

        const canvas = document.querySelector(overlay + ' .brxc-overlay__pannel.history .brxc-canvas');

        if (self.aihistory.length === 0) return canvas.innerHTML = "<p class='brxc__no-record'>No records yet. Please come back here after you generated some AI content.</p>"
        // wrapper
        canvas.classList.remove('empty');
        let inner = '<div class="isotope-wrapper--late" data-gutter="20" data-filter-layout="fitRows" style="--col:1">';
        //search
        inner += '<div class="brxc-overlay__search-box"><input type="search" class="iso-search" name="typography-search" placeholder="Type here to filter the history list" data-type="textContent"><div class="iso-search-icon"><i class="bricks-svg ti-search"></i></div><div class="iso-reset"><i class="bricks-svg ti-close"></i></div></div>';
        //container
        inner += '<div class="isotope-container">';
        if(self.aihistory.length < 1) return;
        const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });
        for(let i=0; i<self.aihistory.length; i++){
            const diff = self.aihistory[i]['user']['date'] - Date.now();
            let unit = "second";
            let divider = 1000;
            if (diff / 1000 < -59) {
                unit = "minute";
                divider = 60000;
            }
            if (diff / 1000 / 60 < -59) {
                unit = "hour";
                divider = 3600000;
            }
            if (diff / 1000 / 60 / 60 < -23) {
                unit = "day";
                divider = 86400000;
            }
            const time = rtf.format(Math.round(diff / divider), unit);
            inner += `
            <div class="brxc-ai-response-wrapper isotope-selector brxc-isotope__col">
                <input type="radio" id="brxcHistoryUser${i}" name="openai-results">
                <label for="brxcHistoryUser${i}" class="brxc-input__label">
                    <div class="brxc-history__header-wrapper">
                        <div class="brxc-history__header-wrapper--left">
                            <span><i class="fas fa-user"></i>You <span class="brxc__light">(${time})</span></span>
                        </div>
                        <div class="brxc-history__header-wrapper--right">`;
                            if(self.aihistory[i]['user']['type']){
                                inner += `
                                <div class="brxc-history__header-block" data-balloon="Category" data-balloon-pos="top">
                                    <i class="bricks-svg fas fa-tag"></i>
                                    <span>${self.aihistory[i]['user']['type']}</span>
                                </div>`;
                            }
                            if(self.aihistory[i]['user']['choices']){
                                inner += `
                                <div class="brxc-history__header-block" data-balloon="Choices" data-balloon-pos="top">
                                    <i class="bricks-svg fas fa-list-ul"></i>
                                    <span>${self.aihistory[i]['user']['choices']}</span>
                                </div>`;
                            }
                            if (self.aihistory[i]['user']['maxTokens']){
                                inner += `<div class="brxc-history__header-block" data-balloon="Max Tokens" data-balloon-pos="top">
                                    <i class="bricks-svg fas fa-traffic-light"></i>
                                    <span>${self.aihistory[i]['user']['maxTokens']} tokens</span>
                                </div>`;
                            }
                            if (typeof self.aihistory[i]['assistant']['usage'] != 'undefined'){
                                if(self.aihistory[i]['assistant']['usage']['prompt_tokens']){
                                inner += `<div class="brxc-history__header-block" data-balloon="Tokens used" data-balloon-pos="top">
                                    <i class="bricks-svg fas fa-dollar-sign"></i>
                                    <span>${self.aihistory[i]['assistant']['usage']['prompt_tokens']} tokens</span>
                                </div>`;
                                }
                            }
                        inner +=`</div>
                    </div>`;
                    
                    inner +=` <div name="${prefix}-prompt-response" class="message assistant">${self.aihistory[i]['user']['message']}</div>`;
                    
                inner +=`</label>`;
                if(self.aihistory[i]['user']['instruction']){
                    inner += `
                    <input type="radio" id="brxcHistoryInstruction${i}" name="openai-results">
                    <label for="brxcHistoryInstruction${i}" class="brxc-input__label">
                        <div name="${prefix}-prompt-response" class="message assistant">${self.aihistory[i]['user']['instruction']}</div>
                    </label>`;
                }
            inner += `</div>`;
            inner += '<div class="brxc-ai-response-wrapper isotope-selector brxc-isotope__col">';
            if(typeof self.aihistory[i]['assistant']['choices'] != 'undefined'){  
                for(let j=0; j<self.aihistory[i]['assistant']['choices'].length; j++){
                    
                    inner += `
                        <input type="radio" id="brxcHistoryAssistant${i + "c" +  j}" name="openai-results">
                        <label for="brxcHistoryAssistant${i + "c" +  j}" class="brxc-input__label">
                            <div class="brxc-history__header-wrapper">
                                <div class="brxc-history__header-wrapper--left">`
                                if(j===0) inner +=`<span><i class="fas fa-robot"></i>AI assistant <span class="brxc__light">(${time})</span></span>`;
                                inner +=`</div>
                                <div class="brxc-history__header-wrapper--right">`;
                                    if(j===0 && self.aihistory[i]['user']['temperature']){
                                        inner += `
                                        <div class="brxc-history__header-block" data-balloon="Temperature" data-balloon-pos="top">
                                            <i class="bricks-svg fas fa-temperature-empty"></i>
                                            <span>${self.aihistory[i]['user']['temperature']}</span>
                                        </div>`;
                                    }
                                    if(j===0 && self.aihistory[i]['user']['top_p']){
                                        inner += `
                                        <div class="brxc-history__header-block" data-balloon="Top Probability" data-balloon-pos="top">
                                            <i class="bricks-svg fas fa-arrow-up-1-9"></i>
                                            <span>${self.aihistory[i]['user']['top_p']}</span>
                                        </div>`;
                                    }
                                    if(j===0 && self.aihistory[i]['user']['presence_penalty']){
                                        inner += `
                                        <div class="brxc-history__header-block" data-balloon="Presence Penalty" data-balloon-pos="top">
                                            <i class="bricks-svg fas fa-signal"></i>
                                            <span>${self.aihistory[i]['user']['presence_penalty']}</span>
                                        </div>`;
                                    }
                                    if(j===0 && self.aihistory[i]['user']['frequency_penalty']){
                                        inner += `
                                        <div class="brxc-history__header-block" data-balloon="Frequency Penalty" data-balloon-pos="top">
                                            <i class="bricks-svg fas fa-wave-square"></i>
                                            <span>${self.aihistory[i]['user']['frequency_penalty']}</span>
                                        </div>`;
                                    }
                                    if (j===0 && typeof self.aihistory[i]['assistant']['usage'] != 'undefined' && self.aihistory[i]['assistant']['usage']['completion_tokens']){
                                        inner += `
                                        <div class="brxc-history__header-block" data-balloon="Tokens used" data-balloon-pos="top">
                                            <i class="bricks-svg fas fa-dollar-sign"></i>
                                            <span>${self.aihistory[i]['assistant']['usage']['completion_tokens']} tokens</span>
                                        </div>`;
                                    }
                                    inner += `</div>
                            </div>`;
                            if(self.aihistory[i]['user']['type'] === "completion" || self.aihistory[i]['user']['type'] === "code" || self.aihistory[i]['user']['type'] === "edit"){
                                inner += `<div name="${prefix}-prompt-response" class="message assistant">${self.aihistory[i]['assistant']['choices'][j]['message']['content'].trim()}</div>`;
                            } else {
                                inner += `<div name="${prefix}-prompt-response" class="message assistant">${self.aihistory[i]['assistant']['choices'][j]['text'].trim()}</div>`;
                            }
                        inner += '</label>';
                    
                }
            }
            if(self.aihistory[i]['user']['type'] === "images"){
                inner += `
                <input type="radio" id="brxcHistoryAssistant${i}" name="openai-results">
                <label for="brxcHistoryAssistant${i}" class="brxc-input__label">
                <div class="brxc-history__header-wrapper">
                    <div class="brxc-history__header-wrapper--left">
                        <span>AI assistant <span class="brxc__light">(${time})</span></span>
                    </div>
                </div>
                <div name="${prefix}-prompt-response" class="message assistant">I successfully generated ${self.aihistory[i]['user']['choices']} image(s)</div>`;
            }
            if(self.aihistory[i]['user']['type'] === "audio"){
                inner += `
                <input type="radio" id="brxcHistoryAssistant${i}" name="openai-results">
                <label for="brxcHistoryAssistant${i}" class="brxc-input__label">
                <div class="brxc-history__header-wrapper">
                    <div class="brxc-history__header-wrapper--left">
                        <span>AI assistant <span class="brxc__light">(${time})</span></span>
                    </div>`;
                    if(self.aihistory[i]['user']['temperature']){
                        inner += `
                        <div class="brxc-history__header-wrapper--right">
                            <div class="brxc-history__header-block" data-balloon="Temperature" data-balloon-pos="top">
                                <i class="bricks-svg fas fa-temperature-empty"></i>
                                <span>${self.aihistory[i]['user']['temperature']}</span>
                            </div>
                        </div>`;
                    }
                inner += `</div>
                <div name="${prefix}-prompt-response" class="message assistant">${self.aihistory[i]['assistant']['text']}</div>`;
            }
            inner += '</div>';
        }
        //end of container and wrapper
        inner += '</div></div>';

        canvas.innerHTML = inner;


        let filterRes = true;
        let filterSearch = true;
        let qsRegex
        let isotopeGutter;
        let isotopeLayoutHelper;
        const isotopeWrappers = document.querySelectorAll(overlay + ' .isotope-wrapper--late')
        isotopeWrappers.forEach(wrapper => {
            const isotopeContainers = wrapper.querySelectorAll('.isotope-container');
            isotopeContainers.forEach(isotopeContainer => {
                const isotopeSelector = wrapper.querySelectorAll('.isotope-selector');
                const isoSearch = wrapper.querySelector('input[type="search"].iso-search');
                const isoSearchType = isoSearch.dataset.type;
                const isoSearchReset = wrapper.querySelector('.iso-reset');
                if (wrapper.dataset.gutter) {
                    isotopeGutter = parseInt(wrapper.dataset.gutter);
                    wrapper.style.setProperty('--gutter', isotopeGutter + 'px');
                    isotopeSelector.forEach(elm => elm.style.paddingBottom = isotopeGutter + 'px');
                } else {
                    isotopeGutter = 0;
                };

                if (wrapper.dataset.filterLayout) {
                    isotopeLayoutHelper = wrapper.dataset.filterLayout;
                } else {
                    isotopeLayoutHelper = 'fitRows';
                };
                

                // init Isotope
                const isotopeOptions = {
                    itemSelector: '.isotope-selector',
                    layoutMode: isotopeLayoutHelper,
                    transitionDuration: 0,
                    filter: function(itemElem1, itemElem2) {
                        const itemElem = itemElem1 || itemElem2;
                        if(isoSearchType === "textContent") {
                            return qsRegex ? itemElem.textContent.match(qsRegex) : true;
                        } else {
                            filterSearch = qsRegex ? itemElem.getAttribute('title').match(qsRegex) : true;
                            return filterRes;
                        }
                    },
                };


                // Set the correct layout
                switch (isotopeLayoutHelper) {
                    case 'fitRows':
                    isotopeOptions.fitRows = {
                        gutter: isotopeGutter
                    };
                    break;
                    case 'masonry':
                    isotopeOptions.masonry = {
                        gutter: isotopeGutter
                    };
                    break;
                }

                // Search Filter
                const iso = new Isotope(isotopeContainer, isotopeOptions);
                
                if (isoSearch) {
                    isoSearch.addEventListener('keyup', self.debounce(() => {
                        qsRegex = new RegExp(isoSearch.value, 'gi');
                        iso.arrange();
                    }, 100));
                }
                if (isoSearchReset) {
                    isoSearchReset.onclick = () => {
                        isoSearch.value = '';
                        const clickEvent = new Event('keyup');
                        isoSearch.dispatchEvent(clickEvent);
                    }
                }



            })
            
        })
    },
    initGridGuide: function() {
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        const xGridWrapper = document.createElement('section');
        xGridWrapper.classList.add(...['brxc-grid-guide__wrapper','brxe-section']);
        const xGridContainer = document.createElement('div');
        xGridContainer.classList.add('brxe-container');
        const div = '<div></div>';
        xGridContainer.innerHTML += div.repeat(12);
        xGridWrapper.appendChild(xGridContainer);
        x.document.body.after(xGridWrapper);
    },
    gridGuideActive: false,
    toggleTopbarIconState: function(cls, state){
        const self = this;
        const btn = document.querySelector(`#bricks-toolbar li${cls}`);
        if(!btn) return;
        state === true ? btn.classList.add('enabled') : btn.classList.remove('enabled');
    },
    gridGuide: function() {
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        let xGridWrapper = x.document.querySelector('.brxc-grid-guide__wrapper')
        self.gridGuideActive === true ? self.gridGuideActive = false : self.gridGuideActive = true;
        self.gridGuideActive === true ? xGridWrapper.classList.add('active') : xGridWrapper.classList.remove('active');
        self.toggleTopbarIconState('.grid-guide', self.gridGuideActive);
    },
    setGridGuideOptions: function(item){
        const self = this;
        const defaultObj = {
            col: 12,
            gap: "2rem",
            color: "#ff000024",
        }
        item.classList.contains('open') ? item.classList.remove('open') : item.classList.add('open');
        if(item.classList.contains('open')){
            const wrapper = document.createElement('div');
            wrapper.setAttribute('id', 'brxc-grid-guide-options__wrapper');
            let content = '';
            content += `<ul><div class="header"><span class="title">Grid Guide Options</span><span class="bricks-svg-wrapper save" data-balloon="Save" data-balloon-pos="top"><i class="fas fa-floppy-disk"></i></span><span class="bricks-svg-wrapper close" data-balloon="Close" data-balloon-pos="top"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M400,145.49l-33.49,-33.49l-110.51,110.51l-110.51,-110.51l-33.49,33.49l110.51,110.51l-110.51,110.51l33.49,33.49l110.51,-110.51l110.51,110.51l33.49,-33.49l-110.51,-110.51l110.51,-110.51Z" fill="currentColor"></path></svg></span></div>`;
            content += `<li class="head"><div class="empty"></div><span class="title-col">Columns</span><span class="title-gap">Gap</span><span class="title-color">Color</span></li>`;
            self.vueState.breakpoints.forEach(bp => {
                const arr = self.globalSettings.generalCats.gridGuide ? self.globalSettings.generalCats.gridGuide : [];
                const existing = arr.find(el => el && el.device === bp.key);
                const obj = existing ? existing : defaultObj;
                content += `<li data-device="${bp.key}">
                                <div class="input-grid-guide-device" data-balloon="${bp.label}" data-balloon-pos="top-left">${self.helpers.bpIcons(bp.icon)}</div>
                                <input type="number" min="1" max="12" value="${obj.col}"class="input-grid-guide col">
                                <input type="text" value="${obj.gap}" class="input-grid-guide gap">
                                <div class="input-grid-guide color-wrapper"><div style="background-color:${obj.color}" class="input-grid-guide color" data-color="${obj.color}"></div></div>
                            </li>`
            })
            content += `</ul>`
            wrapper.innerHTML = content
            const toolbar = document.querySelector('.brx-body.main')
            toolbar.appendChild(wrapper)
        } else{
            const wrapper = document.querySelector('#brxc-grid-guide-options__wrapper');
            wrapper?.remove();
            return;
        }

        // Close popup
        const wrapper = document.querySelector('#brxc-grid-guide-options__wrapper');
        const close = wrapper?.querySelector('.close');
        close?.addEventListener('click', () => {
            wrapper?.remove();
            item.classList.remove('open')
        })

        // Save
        const save = wrapper?.querySelector('.save');
        save?.addEventListener('click', () => {
            self.saveGridGuide();
        })

        // Color Picker
        const colors = wrapper.querySelectorAll('.input-grid-guide.color');
        colors.forEach(el => {
            let picker = new ColorPicker(el, el.dataset.color);
            el.addEventListener('colorChange', self.debounce((event) => {
                const color = event.detail.color.hsla;
                el.setAttribute('data-color', color);
                self.generateGridGuideArr();
                self.generateGridGuideCSS();
            }, 100))
        })

        // generate css
        const inputs = wrapper.querySelectorAll('input');
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                self.generateGridGuideArr();
                self.generateGridGuideCSS();
            })
        })
        
    },
    saveGridGuide: function(){
        const self = this;
        const obj = self.globalSettings.generalCats.gridGuide;
        jQuery.ajax({
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'save_grid_guide_ajax_function',
                nonce: openai_ajax_req.nonce,
                grid: obj,
            },
            method: "POST",
            success: function(data) {
                self.vueGlobalProp.$_showMessage('Grid options saved successfully!')
            },
            error: function(data) {
                self.vueGlobalProp.$_showMessage('Something went wrong - Grid options not saved.')
            }
        });
    },
    generateGridGuideArr: function(){
        const self = this;
        const wrapper = document.querySelector('#brxc-grid-guide-options__wrapper');
        if(!wrapper) return;
        const rows = wrapper.querySelectorAll('li:not(.head)');
        const arr = [];
        
        rows.forEach(row => {
            const col = row.querySelector('input[type="number"]').value;
            const gap = row.querySelector('input[type="text"]').value;
            const color = row.querySelector('.input-grid-guide.color').dataset.color;
            arr.push({
                device: row.dataset.device,
                col: col,
                gap: gap,
                color: color,
            })
        })
        self.globalSettings.generalCats.gridGuide = arr;
        return arr;
    },
    generateGridGuideCSS: function(){
        const self = this;
        let css = '';
        let arr = self.globalSettings.generalCats.gridGuide;
        const defaultObj = {
            col: 12,
            gap: "2rem",
            color: "#ff000024",
        }

        // Default values
        if(!arr){
            arr = [];
            self.vueState.breakpoints.forEach(bp => {
                defaultObj.device = bp.key;
                arr.push(defaultObj);
            })
            self.globalSettings.generalCats.gridGuide = JSON.stringify(arr);
        }
        if(typeof self.globalSettings.generalCats.gridGuide === "string") self.globalSettings.generalCats.gridGuide = JSON.parse(self.globalSettings.generalCats.gridGuide);
        arr = self.globalSettings.generalCats.gridGuide;
        self.vueState.breakpoints.forEach((bp,index) => {
            const existing = arr.find(el => el && el.device === bp.key)
            const item = existing ? existing : defaultObj;
            if(index === 0){
                css += `.brxc-grid-guide__wrapper>.brxe-container {
                    grid-template-columns: repeat(${item.col},1fr);
                    gap: ${item.gap};
                }
                .brxc-grid-guide__wrapper.active>.brxe-container>div {
                    background-color: ${item.color};
                }`;
            } else {
                const media = self.vueGlobalProp.$_isMobileFirst._value ? 'min' : 'max';
                const mediaValue = self.vueState.breakpoints[index].width;
                css += ` @media screen and (${media}-width: ${mediaValue}px){
                    .brxc-grid-guide__wrapper>.brxe-container {
                        grid-template-columns: repeat(${item.col},1fr);
                        gap: ${item.gap};
                    }
                    .brxc-grid-guide__wrapper.active>.brxe-container>div {
                        background-color: ${item.color};
                    }
                }`;
            }
        })
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        let xStylesheet = x.document.querySelector('#brxc-grid-guide-css');
        if(!xStylesheet){
            const el = document.createElement('style');
            el.id = 'brxc-grid-guide-css';
            const xHead = x.document.head;
            xHead.appendChild(el);
        }
        xStylesheet = x.document.querySelector('#brxc-grid-guide-css');
        xStylesheet.innerHTML = css;
    },
    xCodeActive: false,
    XCode: function() {
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        const els = x.document.querySelectorAll('body main *, body footer *, body header *, body .brx-popup.builder *');
        self.xCodeActive === true ? self.xCodeActive = false : self.xCodeActive = true;
        if(self.xCodeActive){
            els.forEach(el=> {
                el.classList.add('x-mode-enabled');
            })
        } else {
            els.forEach(el=> {
                el.classList.remove('x-mode-enabled');
            })
        }
        self.toggleTopbarIconState('.x-mode', self.xCodeActive);
    },
    contrastActive: false,
    contrast: function() {
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        self.contrastActive === true ? self.contrastActive = false : self.contrastActive = true;
        if(self.contrastActive){
            contrast.check();
        } else {
            const failedEls = x.document.querySelectorAll('.brxc-contrast-failed');
            failedEls.forEach(el => el.classList.remove('brxc-contrast-failed'))
        }
        self.toggleTopbarIconState('.constrast', self.contrastActive);
    },
    darkmodeActive: false,
    darkMode: function (){
        const self = this;
        self.darkmodeActive === true ? self.darkmodeActive = false : self.darkmodeActive = true;
        self.colorStates.colorManagerMode === 'light' ? self.colorStates.colorManagerMode = 'dark' : self.colorStates.colorManagerMode = 'light';
        self.generateColorCSS();
        self.generateBuilderCSS();
        self.setColorManager();
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        //x.document.body.classList.toggle('brxc-dark');
        const html = x.document.documentElement;
        (html && self.colorStates.colorManagerMode === 'light') ? html.setAttribute('data-theme', 'light') : html.setAttribute('data-theme', 'dark')
        self.toggleTopbarIconState('.darkmode', self.darkmodeActive);

    },
    addMenuItemtoToolbar: (classes, balloonText, balloonPosition, onClickFunction, iconHTML, toolbar, insertBeforeEl, position = 'before') => {
        const li = document.createElement('li');
        li.classList.add(classes);
        li.setAttribute('data-balloon', balloonText);
        li.setAttribute('data-balloon-pos', balloonPosition);
        li.setAttribute('onClick',onClickFunction)
        const span = document.createElement('span');
        span.classList.add('bricks-svg-wrapper');
        span.innerHTML += iconHTML;
        li.appendChild(span);
        if(position === 'before') toolbar.insertBefore(li,insertBeforeEl);
        if(position === 'after') insertBeforeEl.parentNode.insertBefore(li, insertBeforeEl.nextSibling);
    },
    addIconToFields: (tag, classes, attrArr, balloonText, balloonPosition, onClickFunction, dataUsed, htmlEl, target, appendMethod) => {
        const li = document.createElement(tag);
        li.classList.add(...classes.split(' '));
        if(balloonText) li.setAttribute('data-balloon', balloonText);
        if(balloonPosition) li.setAttribute('data-balloon-pos',balloonPosition);
        if(attrArr && attrArr.length > 0){
            attrArr.forEach(attr => {
                const label = attr[0];
                const value = attr[1];
                li.setAttribute(label, value);
            })
        }
        // if (attr) li.setAttribute(attr, attrValue);
        li.setAttribute('onclick', onClickFunction);
        (dataUsed === true) ? li.setAttribute('data-used', 0) : '';
        li.innerHTML = htmlEl;
        if(appendMethod === 'after'){
            target ? target.after(li) : console.log('No target to append child.') ;
        } else if (appendMethod === 'before'){
            target ? target.before(li) : console.log('No target to append child.') ;
        } else if (appendMethod === 'child'){
            target ? target.appendChild(li) : console.log('No target to append child.') ;
        } 
    },
    addDynamicVariableIcon: function() {
        const self = this;
        setTimeout(() => {
            self.fields['CSSVariabe']['includedFields'].forEach(field => {
                let elements;
                if (typeof field === 'string') {
                    elements = Array.from(document.querySelectorAll(field));
                } else {
                    // Get elements with the selector
                    const filteredElements = Array.from(document.querySelectorAll(field.selector));
        
                    // Check if they have any of the specified child elements
                    elements = filteredElements.filter(el =>
                        el && field.hasChild.some(child => child && el.querySelector(child))
                    );
                }
        
                const wrappers = elements.filter(
                    item => item && !item.parentNode.closest(self.fields['CSSVariabe']['excludedFields'])
                );
                if (wrappers.length < 1) return;
                wrappers.forEach(wrapper => {
                    const condition1 = self.globalSettings.classFeatures.variablePickerType === "icon" || self.globalSettings.classFeatures.variablePickerType === "both";
                    const condition2 = self.globalSettings.classFeatures.variablePickerType === "mouse" || self.globalSettings.classFeatures.variablePickerType === "both";
                    if(condition1){
                        const modal = wrapper.querySelector('.brxc-toggle-modal');
                        if (modal) return;
                        
                        self.addIconToFields(
                            'div',
                            'brxc-toggle-modal',
                            false,
                            'Select CSS Variable',
                            'top-right',
                            'ADMINBRXC.openVariableModal(event.target.nextElementSibling, event.target.nextElementSibling, "#brxcVariableOverlay", document.querySelector("#brxcVariableOverlay input.iso-search") )',
                            false,
                            "<span>v</span>",
                            wrapper.querySelector("input[type='text']"),
                            'before'
                        );
                    } 
                    
                    if(condition2){
                        const input = wrapper.querySelector("input[type='text']");
                        if(input.dataset.picker === "true") return;

                        input.setAttribute('data-picker', 'true');
                        input.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            self.openVariableModal(input,input, "#brxcVariableOverlay", document.querySelector("#brxcVariableOverlay input.iso-search"), "variable");
                        })
                    }
                });
            });
        }, 100);
    },
    addDynamicColorListener: function() {
        const self = this;
        setTimeout(() => {
            self.fields['colors']['includedFields'].forEach(field => {
                const elements = Array.from(document.querySelectorAll(field));
                if (elements.length < 1) return;
                
                elements.forEach(wrapper => {
                    const input = wrapper.querySelector(".bricks-control-preview");
                    if(input.dataset.picker === "true") return;

                    input.setAttribute('data-picker', 'true');
                    input.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const isOpen = input.parentElement.querySelector('.color-inputs .raw .color-input input');
                        if(!isOpen) input.click();
                        setTimeout(() => {
                            const rawInput = input.parentElement.querySelector('.color-inputs .raw .color-input input');
                            if(!rawInput){
                                self.vueGlobalProp.$_showMessage('ERROR: PLEASE RETRY!')
                            } else {
                                self.openVariableModal(rawInput, input, "#brxcVariableOverlay", document.querySelector("#brxcVariableOverlay input.iso-search"), "color");
                            }
                        },0)
                    })
                });
            });
        }, 150);
    },
    strictEditorState: false,
    setStrictEditorView: function() {
        const self = this;
        if(!self.helpers.isElementActive()) return;
        if(self.strictEditorState !== true || self.vueState.activePanelTab !== "content") {
            const existingCSS = document.querySelector('#brxcFullAccessStyles');
            if(existingCSS) existingCSS.remove();
            let icons = document.querySelectorAll('.brxc-toggle-strict-editor');
            icons.forEach(icon => icon.remove())
            icons = document.querySelectorAll('.brxc-toggle-strict-editor-disabled');
            icons.forEach(icon => icon.remove())
            return;
        };

        const elementObj = self.helpers.getFinalObject(true);
        
        setTimeout(() => {
            const controls = self.vueGlobalProp.$_getElementConfig(elementObj.name).controls;
            const existingCSS = document.querySelector('#brxcFullAccessStyles');

            // Create style
            if(!existingCSS){
                const style = document.createElement('style');
                style.id = 'brxcFullAccessStyles';
                style.innerHTML =`[data-controlkey]{position: relative;}.control-inner:not(.control-inner .control-inner) > *:not(.has-setting, .brxc-toggle-strict-editor, label + [data-control]), .control > .description{margin-left: 22px;}.bricks-panel-controls .control{margin-right: 32px!important;}`;
                document.head.appendChild(style);
            }

            // Loop through all controls
            for(const key of Object.keys(controls)){
                if(controls[key].tab === "content" && !controls[key].hasOwnProperty('css')) {
                    // Query Target
                    const target = document.querySelector(`#bricks-panel-element [data-controlkey="${key}"] .control:not(.control-separator) .control-inner`);
                    if(!target) continue;

                    // Remove existing Icon
                    const icon = target.querySelector('.brxc-toggle-strict-editor');
                    if (icon) icon.remove();

                    const isFullAccess = controls[key].hasOwnProperty('fullAccess') && controls[key].fullAccess === true ? true : false
                    const toggle = isFullAccess === true ? `<div><i class="fas fa-toggle-off"></i></div>` : `<div><i class="fas fa-toggle-on"></i></div>`;
                    const balloon = isFullAccess === true ? 'Global Control OFF' : 'Global Control ON';

                    // Add Icon
                    self.addIconToFields(
                        'div',
                        'brxc-toggle-strict-editor',
                        false,
                        balloon,
                        'top-left',
                        `ADMINBRXC.toggleFullAccess('${key}')`,
                        false,
                        toggle,
                        target,
                        'child'
                    );

                    // Remove existing Icon
                    const iconVisible = target.querySelector('.brxc-toggle-strict-editor-disabled');
                    if (iconVisible) iconVisible.remove();

                    if(!isFullAccess){
                        const obj = elementObj.settings;

                        function isDisabled(){
                            return obj.hasOwnProperty('fullAccessDisable') && Array.isArray(obj.fullAccessDisable) && obj.fullAccessDisable.includes(key) === true ? true : false;
                        }

                        const isFullAccessDisable = isDisabled() ? true : false
                        const toggleVisible = isFullAccessDisable === true ? `<div><i class="fas fa-eye-slash"></i></div>` : `<div><i class="fas fa-eye"></i></div>`;
                        const balloonVisible = isFullAccessDisable === true ? 'Control Disabled' : 'Control Enabled';

                        // Add Icon
                        self.addIconToFields(
                            'div',
                            'brxc-toggle-strict-editor-disabled',
                            false,
                            balloonVisible,
                            'top-right',
                            `ADMINBRXC.toggleFullAccessVisibility('${key}')`,
                            false,
                            toggleVisible,
                            target,
                            'child'
                        );
                    }
                }
            }
        }, 100)     
    },
    toggleFullAccess: function(ctrlKey){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        const name = elementObj.name;
        const control = self.vueGlobalProp.$_getElementConfig(name).controls[ctrlKey];
        const newValue = control.hasOwnProperty('fullAccess') && control.fullAccess === true ? 'false' : 'true';
        newValue === 'true' ? control.fullAccess = true : delete control.fullAccess;
        self.saveFullAccessBuilder(name, ctrlKey, newValue);
        self.vueState.rerenderControls = Date.now();

    },
    toggleFullAccessVisibility: function(ctrlKey){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        const obj = elementObj.settings;

        function isDisabled(){
            return obj.hasOwnProperty('fullAccessDisable') && Array.isArray(obj.fullAccessDisable) && obj.fullAccessDisable.includes(ctrlKey) === true ? true : false;
        }

        if(isDisabled()){
            const index = obj.fullAccessDisable.indexOf(ctrlKey);
            obj.fullAccessDisable.splice(index, 1);
        } else {
            if(!obj.hasOwnProperty('fullAccessDisable')) obj.fullAccessDisable = [];
            obj.fullAccessDisable.push(ctrlKey)
        }

        self.vueState.rerenderControls = Date.now();

    },
    saveFullAccessBuilder: function(name, key, value){
        const self = this;
        if(!self.globalSettings.generalCats.hasOwnProperty('fullAccess')) self.globalSettings.generalCats.fullAccess = {};
        if(!self.globalSettings.generalCats.fullAccess.hasOwnProperty(name)) self.globalSettings.generalCats.fullAccess[name]= {};
        self.globalSettings.generalCats.fullAccess[name][key] = value;
    },
    saveFullAccessOptions: function(){
        const self = this;
        const obj = self.globalSettings.generalCats.fullAccess;
        jQuery.ajax({
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'save_full_access_ajax_function',
                nonce: openai_ajax_req.nonce,
                fullAccess: obj,
            },
            method: "POST",
            success: function(data) {
                self.vueGlobalProp.$_showMessage('Strict Editor settings saved successfully!')
            },
            error: function(data) {
                self.vueGlobalProp.$_showMessage('Something went wrong - Strict Editor settings not saved.')
            }
        });
    },
    autoformatControlValues: function(){
        const self = this;
        const controls = document.querySelectorAll('[data-controlkey]')
        controls.forEach(control => {
            if(self.helpers.isCSSControlKey(control.dataset.controlkey) !== true) return; 
            const inputs = control.querySelectorAll('input[type="text"]');
            if(inputs.length < 1) return;
            inputs.forEach(input => {
                input.addEventListener('blur', () => {
                    self.autoformat(input, control);
                    const evt = new Event('input');
                    input.dispatchEvent(evt);
                })
            })
            
        })
    },

    autoformat: function(input, control){
        const self = this;
        
        let values, operators;
        const rootFontSize = self.helpers.getRootFontSize();

        // Clamp()
        if(
            Object.values(self.globalSettings.autoFormatFunctions).includes("clamp") &&
            input.value.includes('|') &&
            Number.isFinite(Number(input.value.split('|')[0])) &&
            Number.isFinite(Number(input.value.split('|')[1]))
        ){
            const arr = input.value.split('|');
            const minSize = parseInt(arr[0]);
            const maxSize = parseInt(arr[1]);
            const minWidthPx = (arr[2] && typeof parseInt(arr[2]) === "number") ? parseInt(arr[2]) : false;
            const maxWidthPx = (arr[3] && typeof parseInt(arr[3]) === "number") ? parseInt(arr[3]) : false;
            input.value = self.helpers.clampBuilder(minSize, maxSize, minWidthPx, maxWidthPx);

            return;
        }

        // Autoclose Brackets for Variables
        if(Object.values(self.globalSettings.autoFormatFunctions).includes("close-var-bracket") && !input.value.includes('clamp(')){
            const countOpenBrackets = self.helpers.countCharacter(input.value, '(');
            const countCloseBrackets = self.helpers.countCharacter(input.value, ')');
            if(countOpenBrackets !== countCloseBrackets){
                values = input.value.split(' ');
                for (let i = 0; i < values.length; i++) {
                    const value = values[i];
                    if (value.includes('var(') && !(value.endsWith(')') || value.endsWith(')!important'))) {
                        values[i] = `${value})`;
                    }
                }
                input.value = values.join(' ');
            }
        }

        // Var()
        if(Object.values(self.globalSettings.autoFormatFunctions).includes("var") && !input.value.includes('clamp(')){
            values = input.value.split(' ');
            for (let i = 0; i < values.length; i++) {
                const value = values[i];
                if (!value.includes('var(') && value.includes('--') && !(value.endsWith(')') || value.endsWith(')!important'))) {
                    values[i] = `${value.replace('--', 'var(--')})`;
                }
            }
            input.value = values.join(' ');
        }

        // Px to rem
        if(Object.values(self.globalSettings.autoFormatFunctions).includes("px-to-rem") && !input.value.includes('clamp(')){
            if(input.value.includes('r:') ){
                values = input.value.split(' ');
                for (let i = 0; i < values.length; i++) {
                    if(values[i].includes("r:") ){
                        const valueToConvert = values[i].split(':')[1].replace('px','');
                        values[i] = `${(valueToConvert / rootFontSize).toFixed(3).toString().replace(/(\.[0-9]*[1-9])0+$|\.0*$/, '$1')}rem`;
                    }
                }
                input.value = values.join(' ');
            }
        }

        // Min()
        if(Object.values(self.globalSettings.autoFormatFunctions).includes("min") && !input.value.includes('clamp(')){
            if(input.value.includes(' < ') ){
                values = input.value.split(' ');
                for (let i = 0; i < values.length; i++) {
                    if(values[i] === "<" && values[i-1] && values[i+1]){
                        const min = values[i-1];
                        const max = values[i+1];
                        values[i] = `min(${min},${max})`;
                        values[i-1] = '';
                        values[i+1] = '';
                    }
                }
                input.value = values.join(' ').replace(/ min\(([^)]*)\) /g, "min($1)");
            }
        }

        // Max()
        if(Object.values(self.globalSettings.autoFormatFunctions).includes("max") && !input.value.includes('clamp(')){
            if(input.value.includes(' > ') ){
                values = input.value.split(' ');
                for (let i = 0; i < values.length; i++) {
                    if(values[i] === ">" && values[i-1] && values[i+1]){
                        const min = values[i-1];
                        const max = values[i+1];
                        values[i] = `max(${min},${max})`;
                        values[i-1] = '';
                        values[i+1] = '';
                    }
                }
                input.value = values.join(' ').replace(/ max\(([^)]*)\) /g, "max($1)");
            }  
        }
        
        // Calc()
        const excludedControls = ['_gridItemColumnSpan', '_gridItemRowSpan'];
        if(Object.values(self.globalSettings.autoFormatFunctions).includes("calc") && !input.value.includes('clamp(') && (control === "custom" || !excludedControls.includes(control.dataset.controlkey))){
            operators = [' + ',' - ',' * ',' / '];
            function formatCalc(expression) {
                const containsOperator = operators.some(operator => operator && expression.includes(operator));
                if (expression.startsWith('calc(') || expression.startsWith('clamp(') ) {
                return expression;
                }

                if (containsOperator) {
                return `calc(${expression})`;
                }
            
                return expression;
            }

            input.value = formatCalc(input.value);
        }
    },
    setTextShortcutsWrapper: function(){
        const self = this;
        const panel = document.querySelector("#bricks-panel-element");

        if(
            self.vueState.activePanel === "element"
            && self.vueState.activePanelTab === "content"
            && (
                Object.values(self.globalSettings.elementFeatures).includes("lorem-ipsum") // lorem
                || self.helpers.isAIActive() && self.globalSettings.isAIApiKeyEmpty === "0" // AI
            )
        ){
            setTimeout(() => {
                self.fields['loremIpsum']['includedFields'].forEach(field => {
                    let elements;
                    if (typeof field === 'string') {
                        elements = Array.from(document.querySelectorAll(field));
                    } else {
                        const filteredElements = Array.from(document.querySelectorAll(field.selector));
                        elements = filteredElements.filter(el =>
                            el && el.querySelector(field.hasChild)
                        );
                    }
        
                    const wrappers = elements.filter(
                        item => item &&
                            !item.parentNode.querySelector(self.fields['loremIpsum']['excludedFields']) &&
                            !item.parentNode.closest(self.fields['loremIpsum']['excludedFields'])
                    );
                    if (wrappers.length < 1) return;
                    let padding = 30;
                    if (Object.values(self.globalSettings.elementFeatures).includes("lorem-ipsum")) padding += 25;
                    if (self.helpers.isAIActive() && self.globalSettings.isAIApiKeyEmpty === "0") padding += 25;
                    wrappers.forEach(wrapper => {
                        if(!wrapper.querySelector('.brxc-icon-wrapper')){
                            const div = document.createElement('DIV');
                            div.classList.add('brxc-icon-wrapper');
                            wrapper.appendChild(div);
                            const input = wrapper.querySelector('input');
                            if (input) input.style.paddingRight = `${padding}px`;
                        } 
                        
                    })
                })
            }, 50)
        }
    },
    addDynamicLoremIcon: function() {
        const self = this;
        setTimeout(() => {
            self.fields['loremIpsum']['includedFields'].forEach(field => {
                let elements;
                if (typeof field === 'string') {
                    elements = Array.from(document.querySelectorAll(field));
                } else {
                    // Get elements with the selector
                    const filteredElements = Array.from(document.querySelectorAll(field.selector));
    
                    // Check if they have the specified child element
                    elements = filteredElements.filter(el =>
                        el && el.querySelector(field.hasChild)
                    );
                }
    
                const wrappers = elements.filter(
                    item => item &&
                        !item.parentNode.querySelector(self.fields['loremIpsum']['excludedFields']) &&
                        !item.parentNode.closest(self.fields['loremIpsum']['excludedFields'])
                );
                if (wrappers.length < 1) return;
                wrappers.forEach(wrapper => {
                    //setTimeout(() => {
                        const inputs = wrapper.querySelectorAll('.brxc-toggle-lorem');
                        if (inputs.length > 0) return;
                        const textWrapper = wrapper.querySelector('.brxc-icon-wrapper')
                        if (!textWrapper) return;
                        self.addIconToFields(
                            'div',
                            'brxc-toggle-lorem',
                            false,
                            'Add Dummy Content',
                            'top-right',
                            'ADMINBRXC.addLorem(event.target.parentElement.parentElement.querySelector("textarea,input"), this)',
                            true,
                            "<div class='lorem-wrapper'><div class='lorem-line lorem-line-1'></div><div class='lorem-line lorem-line-2'></div><div class='lorem-line lorem-line-3'></div>",
                            textWrapper,
                            'child'
                        );
                    //},10)
                });
            });
        }, 55);
    },
    addDynamicAIIcon: function() {
        const self = this;
        setTimeout(() => {
            self.fields['openAI']['includedFields'].forEach(field => {
                let elements;
                if (typeof field === 'string') {
                    elements = Array.from(document.querySelectorAll(field));
                } else {
                    // Get elements with the selector
                    const filteredElements = Array.from(document.querySelectorAll(field.selector));
    
                    // Check if they have the specified child element
                    elements = filteredElements.filter(el =>
                        el && el.querySelector(field.hasChild)
                    );
                }
    
                const wrappers = elements.filter(
                    item => item &&
                        !item.parentNode.querySelector(self.fields['openAI']['excludedFields']) &&
                        !item.parentNode.closest(self.fields['openAI']['excludedFields'])
                );
                if (wrappers.length < 1) return;
                wrappers.forEach(wrapper => {
                    const inputs = wrapper.querySelectorAll('.brxc-toggle-ai');
                    if (inputs.length > 0) return;
                    const textWrapper = wrapper.querySelector('.brxc-icon-wrapper')
                    if (!textWrapper) return;
                    self.addIconToFields(
                        'div',
                        'brxc-toggle-ai',
                        false,
                        'Add AI Content',
                        'top-right',
                        'ADMINBRXC.openAIModal("openai",false,event.target.parentElement.parentElement.querySelector("textarea,input"), "#brxcopenAIOverlay" )',
                        false,
                        "<div class='ai-wrapper'><span class='ai-text'>AI</span></div>",
                        textWrapper,
                        'child'
                    );
                });
            });
        }, 60);
    },
    // addSpacingIcon: function(){
    //     const self = this;
    //     setTimeout(() => {
    //         const controls = document.querySelectorAll('.control.control-spacing');
    //         if(controls.length < 1) return;
    //         controls.forEach(control => {
    //             const linkIcon = control.querySelector('.link-all');
    //             if(!linkIcon) return;
    //             const wrapper = linkIcon.parentElement;
    //             const existingIcon = wrapper.querySelector('.brxc-toggle-spacing');
    //             if(existingIcon) return;
    //             self.addIconToFields(
    //                 'div',
    //                 'brxc-toggle-spacing',
    //                 false,
    //                 'Expand Fields',
    //                 'top-right',
    //                 'ADMINBRXC.expandSpacingControls(event)',
    //                 false,
    //                 "<div class='ai-wrapper'><i class='fas fa-arrows-left-right'></i></div>",
    //                 wrapper,
    //                 'child'
    //             );
    //             if(self.globalSettings.defaultSpacingControls) control.classList.add('expanded');
    //         });
    //     }, 60)
    // },
    // expandSpacingControls: function(event){
    //     const control = event.target.closest('.control-spacing');
    //     if (!control) return;
    //     control.classList.contains('expanded') ? control.classList.remove('expanded') : control.classList.add('expanded');
    // },
    headerIconsState: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        const action = document.querySelector('#bricks-panel-element .actions');
        const elementObj = self.helpers.getFinalObject(true);
        const activeElSettings = self.helpers.isClassActive() ? self.vueState.globalClasses.find(el => el && el.id === self.vueState.activeClass.id)?.settings :  elementObj.settings;
        const isActive = (string, obj) => {
            for (const key in obj) {
                if (JSON.parse(JSON.stringify(key)).indexOf(string) !== -1) {
                  return true;
                }
            }
            return false;
        }
        const states = ['hover', 'before', 'active', 'focus', 'after'];
        states.forEach(state => {
            const item = action.querySelector(`.brxc-header-icon.brxc-header-icon__${state}`);
            if(!item) return;
            item.classList.remove('highlight');
            if(isActive(`:${state}`, activeElSettings)) item.classList.add('highlight');
        })

        //css Icon
        const cssIcon = action.querySelector(`.brxc-header-icon.brxc-header-icon__css-shortcut`);
        if(!cssIcon) return;
        //cssIcon.classList.remove('highlight');

        let hasSettings = false;
        for(const key of Object.keys(activeElSettings)){
            if(key.startsWith('_cssCustom')) hasSettings = true;
        }
        hasSettings ? cssIcon.classList.add('highlight') : cssIcon.classList.remove('highlight');

    },
    addPanelHeaderIcons: function(){
        const self = this;

        // Const
        const wrapper = document.querySelector('#bricks-panel-inner #bricks-panel-header ul.actions')
        if (!wrapper) return;

        const icons = wrapper.querySelectorAll('li.brxc-header-icon');

        // Component
        if(self.helpers.isComponentPanelOpen()){
            icons.forEach(icon => icon.remove());
            return;
        }

        if(!self.helpers.isElementActive()) return;

        const elementObj = self.helpers.getFinalObject(true);

        const extendIcon = wrapper.querySelector('.brxc-header-icon__extend');
        const findReplaceIcon = wrapper.querySelector('.brxc-header-icon__find-replace');
        const cssIcon = wrapper.querySelector('.brxc-header-icon__css-shortcut');
        const styleOverviewIcon = wrapper.querySelector('.brxc-header-icon__style-overview');
        const openClassIcon = wrapper.querySelector('.brxc-header-icon__show-class-manager');
        const modifiedModeIcon = wrapper. querySelector('.brxc-header-icon__modified-mode')
        const goToParentIcon = wrapper.querySelector('.brxc-header-icon__parent');
        const pseudoState = self.vueState.pseudoClassActive;

        // Remove Icons
        if(openClassIcon) openClassIcon.remove();
        if(goToParentIcon) goToParentIcon.remove();
        if(modifiedModeIcon) modifiedModeIcon.remove();


        // Active State
        icons.forEach(icon => {
            icon.classList.remove('active');
            icon.dataset.balloon === pseudoState ? icon.classList.add('active') : '';
        });

        // Extend Styles & Classes
        if (!extendIcon && Object.values(self.globalSettings.elementShortcutIcons).includes("extend-classes")) {
            wrapper ? self.addIconToFields('li','brxc-header-icon brxc-header-icon__extend', false, 'Extend Classes & Styles', 'bottom-right', 'ADMINBRXC.openExtendClassModal(event,"#brxcExtendModal")', true, '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="bricks-svg" viewBox="0 96 960 960"><path d="M145 1022v-95h670v95H145Zm337-125L311 726l58-59 72 72V413l-72 72-58-59 171-171 172 171-59 59-72-72v326l72-72 59 59-172 171ZM145 225v-95h670v95H145Z"/></svg></span>', wrapper, 'child') : '';
        }

        // Find & replace
        if (!findReplaceIcon && Object.values(self.globalSettings.elementShortcutIcons).includes("find-and-replace")) {
            wrapper ? self.addIconToFields('li','brxc-header-icon brxc-header-icon__find-replace', false, 'Find & Replace Styles', 'bottom-right', 'ADMINBRXC.openFindReplaceModal(event,false, "#brxcFindReplaceModal")', true, '<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 96 960 960" class="bricks-svg"><path xmlns="http://www.w3.org/2000/svg" d="M138 484q18-110 103.838-182T440 230q75 0 133 30.5t98 82.5v-98h72v239H503v-71h100q-27-42-70.5-65T440 325q-72.187 0-130.093 43.5Q252 412 234 484h-96Zm674 492L615 780q-34 27-78 43.5T440.217 840Q367 840 308.5 813 250 786 209 734v93h-72V588h240v71H271q28.269 41.15 72.541 64.075Q387.812 746 440 746q72.102 0 127.444-44.853T642 588h96q-5 33-19 65.5T684 713l197 196-69 67Z"/></svg></span>', wrapper, 'child') : '';
        }

        
        // Pseudo Icons
        if(Object.values(self.globalSettings.elementShortcutIcons).includes("pseudo-shortcut") && self.globalSettings.shortcutsIcons.length > 0){
            if (Object.values(self.globalSettings.shortcutsIcons).includes('hover')){
                if(!self.vueState.pseudoClasses.includes(':hover')) self.vueState.pseudoClasses.push(':hover')
                const hoverIcon = document.querySelector('#bricks-panel-inner #bricks-panel-header ul.actions .brxc-header-icon__hover');
                if (!hoverIcon) {
                    self.addIconToFields('li','brxc-header-icon brxc-header-icon__hover', false, ':hover', 'bottom-right', 'ADMINBRXC.setHeaderState("li.brxc-header-icon__hover", ":hover");', true, '<span class="bricks-svg-wrapper"><i class="fas fa-arrow-pointer"></i></span>', wrapper, 'child');
                }
            }
            if (Object.values(self.globalSettings.shortcutsIcons).includes('before')){
                if(!self.vueState.pseudoClasses.includes(':before')) self.vueState.pseudoClasses.push(':before')
                const beforeIcon = document.querySelector('#bricks-panel-inner #bricks-panel-header ul.actions .brxc-header-icon__before');
                if (!beforeIcon) {
                    self.addIconToFields('li','brxc-header-icon brxc-header-icon__before', false, ':before', 'bottom-right', 'ADMINBRXC.setHeaderState("li.brxc-header-icon__before", ":before");', true, '<span class="bricks-svg-wrapper"><svg class="bricks-svg" viewBox="0 0 24 24"><path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"></path></svg></span>', wrapper, 'child');
                }
            }
            if (Object.values(self.globalSettings.shortcutsIcons).includes('after')){
                if(!self.vueState.pseudoClasses.includes(':after')) self.vueState.pseudoClasses.push(':after')
                const afterIcon = document.querySelector('#bricks-panel-inner #bricks-panel-header ul.actions .brxc-header-icon__after');
                if (!afterIcon) {
                    self.addIconToFields('li','brxc-header-icon brxc-header-icon__after', false, ':after', 'bottom-right', 'ADMINBRXC.setHeaderState("li.brxc-header-icon__after", ":after");', true, '<span class="bricks-svg-wrapper"><svg class="bricks-svg" viewBox="0 0 24 24"><path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"></path></svg></span>', wrapper, 'child');
                }
            }
            if (Object.values(self.globalSettings.shortcutsIcons).includes('active')){
                if(!self.vueState.pseudoClasses.includes(':active')) self.vueState.pseudoClasses.push(':active')
                const activeIcon = document.querySelector('#bricks-panel-inner #bricks-panel-header ul.actions .brxc-header-icon__active');
                if (!activeIcon) {
                    self.addIconToFields('li','brxc-header-icon brxc-header-icon__active', false, ':active', 'bottom-right', 'ADMINBRXC.setHeaderState("li.brxc-header-icon__active", ":active");', true, '<span class="bricks-svg-wrapper"><i class="fas fa-toggle-on"></span>', wrapper, 'child');
                }
            }
            if (Object.values(self.globalSettings.shortcutsIcons).includes('focus')){
                if(!self.vueState.pseudoClasses.includes(':focus')) self.vueState.pseudoClasses.push(':focus')
                const focusIcon = document.querySelector('#bricks-panel-inner #bricks-panel-header ul.actions .brxc-header-icon__focus');
                if (!focusIcon) {
                    self.addIconToFields('li','brxc-header-icon brxc-header-icon__focus', false, ':focus', 'bottom-right', 'ADMINBRXC.setHeaderState("li.brxc-header-icon__focus", ":focus");', true, '<span class="bricks-svg-wrapper"><i class="fas fa-crosshairs"></span>', wrapper, 'child');
                }
            }
        }

        // CSS Shortcut
        if(!cssIcon && Object.values(self.globalSettings.elementShortcutIcons).includes("css-shortcut")){
            wrapper ? self.addIconToFields('li',`brxc-header-icon brxc-header-icon__css-shortcut`, false, 'Element\s CSS', 'bottom-right', 'ADMINBRXC.cssShortcut()', true, '<span class="bricks-svg-wrapper"><i class="fab fa-css3-alt"></i></span>', wrapper, 'child') : '';
        }

        // Style Overview
        if (!styleOverviewIcon && Object.values(self.globalSettings.elementShortcutIcons).includes("style-overview-shortcut")) {
            wrapper ? self.addIconToFields('li','brxc-header-icon brxc-header-icon__style-overview', false, 'Open in Style Overview', 'bottom-right', `ADMINBRXC.styleOverviewInit(ADMINBRXC.helpers.getFinalObject(true),true);ADMINBRXC.openModal(false, "#brxcStyleOverviewOverlay", document.querySelector("#brxcStyleOverviewOverlay input[type=search]"));`, true, '<span class="bricks-svg-wrapper"><i class="fas fa-table-list"></span>', wrapper, 'child') : '';
        }

        // Modified Mode
        if (Object.values(self.globalSettings.elementShortcutIcons).includes("modified-mode")) {
            self.addIconToFields('li',`brxc-header-icon brxc-header-icon__modified-mode${self.modifiedModeStates.active? ' active' : ''}`, false, 'Modified Mode', 'bottom-right', `ADMINBRXC.toggleModifiedMode()`, true, '<span class="bricks-svg-wrapper"><i class="ti-settings"></span>', wrapper, 'child');
        }

        // Open in Class Manager
        if (self.helpers.isClassActive() && Object.values(self.globalSettings.elementShortcutIcons).includes("class-manager-shortcut")) {
            self.addIconToFields('li','brxc-header-icon brxc-header-icon__show-class-manager', false, 'Show Class in Manager', 'bottom-right', `ADMINBRXC.openClassInManager('${self.vueState.activeClass.id}')`, true, '<span class="bricks-svg-wrapper"><i class="ion-md-options"></span>', wrapper, 'child');
        }

        // Go to Parent
        if (Object.values(self.globalSettings.elementShortcutIcons).includes("parent-shortcut") && typeof elementObj !== "undefined" && elementObj.hasOwnProperty('parent') && elementObj.parent != 0) {
            self.addIconToFields('li','brxc-header-icon brxc-header-icon__parent', false, 'Go to Parent Element', 'bottom-right', 'ADMINBRXC.goToParentElement()', true, '<span class="bricks-svg-wrapper"><i class="fas fa-arrow-turn-up"></span>', wrapper, 'child');
        }
    },
    modifiedModeStates: {
        active: 0,
    },
    modifiedMode: function(){
        const self = this;
        if(!self.modifiedModeStates.active) return;

        self.vueState.searchControlModified = true;
    },
    toggleModifiedMode: function(){
        const self = this;
        self.modifiedModeStates.active = !self.modifiedModeStates.active;
        if(!self.modifiedModeStates.active){
            self.vueState.searchControlModified = false;
        }
        self.vueState.rerenderControls = Date.now();
    },
    openClassInManager: function(classId){
        const self = this;
        self.states.classManagerActiveClass = classId;
        const obj = self.vueGlobalProp.$_getGlobalClass(classId);
        self.states.classManagerActiveCategory = obj && obj.hasOwnProperty('category') && obj.category ? obj.category : 'All';
        self.openClassManager("global");
    },
    cssShortcut: function(){
        const self = this;

        // Remove panels
        self.vueState.showConditions = false;
        self.vueState.showInteractions = false;

        // Set panel
        self.vueState.activePanelTab = "style";
        setTimeout(() => self.vueState.activePanelGroup = "_css", 10);
    },
    goToParentElement: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        const parentId = self.vueState.activeElement.parent;
        const isComponent = self.vueGlobalProp.$_getComponentById(parentId);

        if(typeof isComponent === "object"){
            document.querySelector('#bricks-structure .structure-item').click();
        } else {
            self.vueState.activeId = parentId; 
        }
    },
    setHeaderState: function(target, text) {
        const self = this;
        if(!self.helpers.isElementActive()) return;
        const icons = document.querySelectorAll('#bricks-panel-header ul.actions li')
        const icon = document.querySelector('#bricks-panel-header ' + target);

        // Remove panels
        self.vueState.showConditions = false;
        self.vueState.showInteractions = false;

        // If icon is active
        if (icon.classList.contains('active')){
            self.vueState.pseudoClassPopup = false;
            icons.forEach(li => li.classList.remove('active'));
            return;
        }

        // If Icon is inactive
        icons.forEach(li => li.classList.remove('active'));
        icon.classList.add('active');
        const pseudoList = self.vueState.pseudoClasses;
        let isPseudoMatching = false;
        for(var i=0; i<pseudoList.length; i++) {
            if(pseudoList[i].indexOf(text)!=-1) {
                isPseudoMatching = true;
            }
        }
        if (isPseudoMatching === true){
            self.vueState.pseudoClassPopup = true;
            self.vueState.pseudoClassActive = text
        }
    },
    setDynamicColorOnHover: function(){
        const self = this;

        if(!self.helpers.isElementActive()) return;

        const elementObj = self.helpers.getFinalObject(true);
        if(!elementObj || !elementObj.hasOwnProperty('settings')) return;

        function setColor(actives) {
            const controls = [['typography', 'color'], ['background', 'backgroundColor'], ['border', 'borderColor']];
        
            self.fields['colorsOnHover']['includedFields'].forEach(field => {
                const colors = document.querySelectorAll(field);
        
                colors.forEach(color => {
                    color.addEventListener('mouseenter', () => {
                        controls.forEach(control => {
                            const closestControl = color.closest(`[data-control=${control[0]}]`);
                            if (closestControl) {
                                const rgb = window.getComputedStyle(color.childNodes[0], null).getPropertyValue('background-color');
                                applyColor(actives, control[1], rgb);
                            }
                        });
                    });
        
                    color.addEventListener('mouseleave', () => {
                        controls.forEach(control => {
                            const closestControl = color.closest(`[data-control=${control[0]}]`);
                            if (closestControl) {
                                applyColor(actives, control[1], '');
                            }
                        });
                    });
                });
            });
        }
        
        function applyColor(actives, property, value) {
            if (Array.isArray(actives)) {
                actives.forEach(active => {
                    active.style[property] = value;
                });
            } else {
                actives.style[property] = value;
            }
        }

        const active = FRAMEBRXC.vueGlobalProp.$_getElementNode(elementObj);
        if(!active) return;
        setTimeout(()=> setColor(active),0)
        
    },
    setDynamicClassOnHover: function () {
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        
        if (!self.helpers.isElementActive() || !self.vueState.showElementClasses) {
          const previewStyle = x.document.querySelector('#at-preview-global-classes');
          if (previewStyle) {
            previewStyle.remove();
          }
          return;
        }
        
        const elementObj = self.helpers.getFinalObject(true);
        if (!elementObj || !elementObj.hasOwnProperty('settings')) {
          return;
        }

        const previewStyle = x.document.querySelector('#at-preview-global-classes') || document.createElement('style');
        previewStyle.id = 'at-preview-global-classes';
        
        const globalClasses = self.vueState.globalClasses;
        
        if (!Array.isArray(globalClasses) || globalClasses.length < 1) {
            if (previewStyle.parentNode) {
                previewStyle.parentNode.removeChild(previewStyle);
            } 
        
            return;
        }
        
        const filteredClasses = globalClasses.filter(el => el && el.hasOwnProperty('settings') && Object.keys(el.settings).length > 0);
        
        if (filteredClasses.length > 0) {
            
            let css = '';
            filteredClasses.forEach(cls => {
                let tempCSS = self.vueGlobalProp.$_generateCss("globalClass", cls, [elementObj.name]);
                css += tempCSS;
            });

            previewStyle.innerHTML = css;
            x.document.head.appendChild(previewStyle);
        } else if (previewStyle.parentNode) {
            previewStyle.parentNode.removeChild(previewStyle);
        }

        function previewClass(actives, singleClass, clsName){
            singleClass.onmouseenter = () => {
                actives.forEach(active => {
                    active.classList.add(clsName);
                })
            };
            
            singleClass.onmouseleave = () => {
                actives.forEach(active => {
                    active.classList.remove(clsName);
                })
            };
            
            singleClass.onclick = () => {
                actives.forEach(active => {
                    active.classList.remove(clsName);
                })
            };
           
            
        }

        setTimeout(() => {
            const actives = [FRAMEBRXC.vueGlobalProp.$_getElementNode(elementObj)];
            
            const titleArr = document.querySelectorAll('div.bricks-control-popup > div.css-classes > h6');
            if (titleArr.length < 1) {
                return;
            }
            
            const title = titleArr[titleArr.length - 1];
            
            if (!title) {
                return;
            }
            
            const ul = title.nextElementSibling;
            const globalClasses = ul.querySelectorAll('li');
            
            globalClasses.forEach(singleClass => {
                const cls = singleClass.querySelector('.name');
                
                if (!cls) {
                    return;
                }
                
                const clsName = cls.textContent.substring(1);
                
                if (!clsName) {
                    return;
                }
                
                previewClass(actives, singleClass, clsName)
            });
        }, 0);
    
            
    },

    setIsotope: function(selector) {
        const self = this;
        let filterRes = true;
        let filterSelector = "*";
        let filterSearch = true;
        let qsRegex
        let isotopeGutter;
        let isotopeLayoutHelper;
        const base = document.querySelector(selector);
        if(!base) return;
        const isotopeWrappers = base.querySelectorAll('.isotope-wrapper')
        if(!isotopeWrappers || isotopeWrappers.length < 1) return;
        isotopeWrappers.forEach(wrapper => {
            const isotopeContainers = wrapper.querySelectorAll('.isotope-container');
            if(!isotopeContainers || isotopeContainers.length < 0) return;

            isotopeContainers.forEach(isotopeContainer => {
                const isotopeSelector = wrapper.querySelectorAll('.isotope-selector');
                const isoSearch = wrapper.querySelector('input[type="search"].iso-search');
                const isoSearchType = isoSearch.dataset.type;
                const isoSearchReset = wrapper.querySelector('.iso-reset');
                if (wrapper.dataset.gutter) {
                    isotopeGutter = parseInt(wrapper.dataset.gutter);
                    wrapper.style.setProperty('--gutter', isotopeGutter + 'px');
                    isotopeSelector.forEach(elm => elm.style.paddingBottom = isotopeGutter + 'px');
                } else {
                    isotopeGutter = 0;
                };

                if (wrapper.dataset.filterLayout) {
                    isotopeLayoutHelper = wrapper.dataset.filterLayout;
                } else {
                    isotopeLayoutHelper = 'fitRows';
                };
                

                // init Isotope
                const isotopeOptions = {
                    itemSelector: '.isotope-selector',
                    layoutMode: isotopeLayoutHelper,
                    transitionDuration: 0,
                    filter: function(itemElem1, itemElem2) {
                        const itemElem = itemElem1 || itemElem2;
                        if(isoSearchType === "textContent") {
                            return qsRegex ? itemElem.textContent.match(qsRegex) : true;
                        } else {
                            filterSearch = qsRegex ? itemElem.getAttribute('title').match(qsRegex) : true;
                            filterRes = filterSelector != '*' ? itemElem.dataset.filter.includes(filterSelector) : true;
                            return filterSearch && filterRes;
                        }
                    },
                };


                // Set the correct layout
                switch (isotopeLayoutHelper) {
                    case 'fitRows':
                    isotopeOptions.fitRows = {
                        gutter: isotopeGutter
                    };
                    break;
                    case 'masonry':
                    isotopeOptions.masonry = {
                        gutter: isotopeGutter
                    };
                    break;
                }

                // Search Filter
                const iso = new Isotope(isotopeContainer, isotopeOptions);
                
                if (isoSearch) {
                    isoSearch.addEventListener('keyup', self.debounce(() => {
                        qsRegex = new RegExp(isoSearch.value, 'gi');
                        iso.arrange();
                    }, 100));
                }
                if (isoSearchReset) {
                    isoSearchReset.onclick = () => {
                        isoSearch.value = '';
                        const clickEvent = new Event('keyup');
                        isoSearch.dispatchEvent(clickEvent);
                    }
                }

                // Buttons Filters
                const filtersElem = wrapper.querySelectorAll(".filterbtn");
                if (filtersElem.length > 0) {
                    filtersElem.forEach(elem => elem.addEventListener("click", function (event) {
                        event.preventDefault();
                        var filterValue = event.target.getAttribute("data-filter");
                        filterSelector = filterValue;
                        iso.arrange();
                    }));
                };

                const radioButtonGroup = (buttonGroup) => {
                    buttonGroup.addEventListener("click", function (event) {
                    filtersElem.forEach(btn => btn.classList.remove("active"));
                    event.target.classList.add("active");
                    });
                };

                for (var i = 0, len = filtersElem.length; i < len; i++) {
                    var buttonGroup = filtersElem[i];
                    radioButtonGroup(buttonGroup);
                };

                // Hide if empty
                iso.on('arrangeComplete', (event) => {
                    if (event.length === 0 ) {
                        isotopeContainer.style.display = "none";
                        (isotopeContainer.previousElementSibling) ? isotopeContainer.parentElement.style.display = "none" : '';
                    } else {
                        isotopeContainer.style.display = "flex";
                        (isotopeContainer.previousElementSibling) ? isotopeContainer.parentElement.style.display = "block" : '';
                    }
                })



            })
            
        })
    },
    openInnerWindow: (wrapper) => {
        wrapper.classList.toggle('inner');
    },
    setInnerContent: (el) => {
        const imgCanvas = document.querySelector('#brxcResourcesOverlay .brxc-overlay__pannel-2 .brxc-overlay__img');
        const titleCanvas = document.querySelector('#brxcResourcesOverlay .brxc-overlay__pannel-2 .brxc-overlay__header-title');
        const srcImg = el.childNodes[1].src;
        const titleText = el.getAttribute('title');
        imgCanvas.innerHTML = '<img src="' + srcImg + '" class="inner__img">';
        titleCanvas.textContent = titleText;
    },
    copytoClipboardSimple: function(text, successMsg) {
        const self = this;
        if (window.isSecureContext && navigator.clipboard) {
           navigator.clipboard.writeText(text);
           self.vueGlobalProp.$_showMessage(successMsg)
        } else {
            self.unsecuredCopyToClipboardSimple(text, successMsg);
        }
     },
     unsecuredCopyToClipboardSimple: function(text, successMsg) {
        const self = this;
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.focus({
           preventScroll: true
        });
        textArea.select();
        try {
           document.execCommand('copy');
           self.vueGlobalProp.$_showMessage(successMsg);
        } catch (err) {
            alert('Unable to copy to clipboard - Use a secure environment.')
        }
        document.body.removeChild(textArea);
     },
    copytoClipboard: function(btn,target, copytext, resestText) {
        const self = this;
        if (window.isSecureContext && navigator.clipboard) {
           navigator.clipboard.writeText(target);
           btn.textContent = copytext;
           setTimeout(() => {
                btn.textContent = resestText;
           }, 1000)
        } else {
            self.unsecuredCopyToClipboard(btn,target,copytext, resestText);
        }
     },
     unsecuredCopyToClipboard: (btn,text,copytext, resestText) => {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.focus({
           preventScroll: true
        });
        textArea.select();
        try {
           document.execCommand('copy');
           btn.textContent = copytext;
           setTimeout(() => {
                btn.textContent = resestText;
           }, 1000)
        } catch (err) {
            alert('Unable to copy to clipboard - Use a secure environment.')
        }
        document.body.removeChild(textArea);
     },
    codeMirrorOptions: (textarea) => {
        let builderTheme;
        (typeof bricksData["loadData"] !== "undefined" && bricksData["loadData"].hasOwnProperty("globalClasses") && bricksData["loadData"]['globalSettings'].hasOwnProperty("builderMode") && bricksData['loadData']['globalSettings']['builderMode'] === 'light') ? builderTheme = 'default' : builderTheme = 'one-dark';
        const obj = {
            value: '',
            mode: "css",
            theme: builderTheme,
            readOnly: false,
            styleActiveLine: true,
            tabSize: 2,
            lineNumbers: true,
            lineWrapping: !0,
            autoRefresh: true,
            autofocus: true,
            suppressErrorLogging: !1,
            autoCloseBrackets: true,
            matchBrackets: true,
            selfContain: true,
            comment: true,
            iewportMargin: Infinity,
            extraKeys: { Tab: "emmetExpandAbbreviation", Esc: "emmetResetAbbreviation", Enter: "emmetInsertLineBreak" },
        };
        if(textarea !== false) obj.value = textarea.value;
        return obj;
    },
    setCodeMirror: function() {
        const self = this;
        const PlainClasses = document.querySelector("#plainClassesInput");

        CodeMirror.hint.anyword = function (editor) {
            var list = self.vueState.globalClasses.map(el => `${el.name} `);
            var cursor = editor.getCursor();
            var currentLine = editor.getLine(cursor.line);
            var start = cursor.ch;
            var end = start;
            var reg = /[\w\-$]+/;
            while (end < currentLine.length && reg.test(currentLine.charAt(end))) ++end;
            while (start && reg.test(currentLine.charAt(start - 1))) --start;
            var curWord = start != end && currentLine.slice(start, end);
            var regex = new RegExp('^' + curWord, 'i');
            var result = {
                list: (!curWord ? list : list.filter(function (item) {
                    return item.match(regex);
                })).sort(),
                from: CodeMirror.Pos(cursor.line, start),
                to: CodeMirror.Pos(cursor.line, end)
            };

            return result;
        }
        const cssHinter = CodeMirror.hint.css;

        const cssVariablesCache = new Map();

        CodeMirror.hint.css = async function (editor) {
            const cursor = editor.getCursor();
            const token = editor.getTokenAt(cursor);
            const currentLine = editor.getLine(cursor.line);
            const curChar = currentLine.charAt(cursor.ch - 1);
            let start = cursor.ch;
            let end = start;
            const rex = /[\w\-$!]+/;
            
            while (end < currentLine.length && rex.test(currentLine.charAt(end))) ++end;
            while (start && rex.test(currentLine.charAt(start - 1))) --start;
            
            const curWord = start !== end && currentLine.slice(start, end);
            const dflt = cssHinter(editor);
            const result = dflt || { list: [] };
            result.to = CodeMirror.Pos(cursor.line, end);
            result.from = CodeMirror.Pos(cursor.line, start);
            var inner = CodeMirror.innerMode(editor.getMode(), token.state);
            const hintCondition = ["prop", "parens", "params"].includes(inner.state.state);
        
            // Handle the '@' character and async loading of recipes
            if (self.globalSettings.classFeatures.advancedCSSCommunityRecipes && !self.advancedCSSStates.communityRecipesLoaded && curChar === "@") {
                // Await the async task to ensure it completes before continuing
                await self.getCommunityRecipes(false);
                self.advancedCSSStates.communityRecipesLoaded = true;
            }
        
            // Process the hints depending on state
            if (inner.state.state === "at") {
                result.list = brxcAdvancedCSSDefault
                    .filter(el => el.typeLabel === "recipe" && el.status == 1 && el.label.includes(curWord) && el.contentCss && el.contentCss !== "")
                    .map(el => ({
                        "text": el.label,
                        "displayText": el.label,
                    }));
            } else if (hintCondition) {

                if(curWord && curWord.startsWith("$")){
                    sassVariables = self.advancedCSSStates.partialVariables.filter(variable => variable && variable.includes(curWord));
                    result.list = sassVariables.map(h => 
                        (typeof h === "string") 
                            ? { "text": h, "displayText": h }
                            : h
                    );
                } else {
                    let cssVariables = cssVariablesCache.get(curWord);
                
                    if (cssVariables === undefined) {
                        cssVariables = self.cssVariables.filter(variable => variable && variable.includes(curWord));
                        cssVariablesCache.set(curWord, cssVariables);
                    }
                    
                    result.list = result.list.concat(cssVariables);
                    result.list = result.list.map(h => 
                        (typeof h === "string") 
                            ? { "text": `${h}`, "displayText": h }
                            : h
                    );
                }
            } else {
                result.list = result.list.map(h => 
                    (typeof h === "string") 
                        ? { "text": `${h}: `, "displayText": h }
                        : h
                );
            }
            
            // Sort results
            result.list.sort((a, b) => {
                const textA = a.text.replace(':', '').toLowerCase();
                const textB = b.text.replace(':', '').toLowerCase();
                return textA.localeCompare(textB);
            });
        
            return result;
        };
        

        const htmlHinter = CodeMirror.hint.html; // Store the original hint function

        CodeMirror.hint.html = function (editor) {
            const cursor = editor.getCursor();
            const currentLine = editor.getLine(cursor.line);
        
            let start = cursor.ch;
            let end = start;
            
            // New regex to match words, optionally allowing < or /
            const rex = /<\/?|\/|<[\w\-$!]+|<\/[\w\-$!]+|[\w\-$!]+/;
        
            // Find end of the current "word" at the cursor
            while (end < currentLine.length && rex.test(currentLine.charAt(end))) ++end;
            // Find the beginning of the current "word" at the cursor
            while (start && rex.test(currentLine.charAt(start - 1))) --start;
        
            // Get the current word based on the updated rex
            const curWord = start !== end && currentLine.slice(start, end);
        
            // Get the default hint results from the original HTML hinter
            const dflt = htmlHinter(editor);
        
            // Create a result list, either from default hinter or empty list
            const result = dflt || { list: [] };

            // Set the start/end of the replacement range
            result.to = CodeMirror.Pos(cursor.line, end);
            result.from = CodeMirror.Pos(cursor.line, start);
        
            // Filter the list based on the current word typed by the user (curWord)
            if (curWord) {
                result.list = result.list.concat(Object.values(bricksData.elements)
                    .filter(el => !el.deprecated)
                    .map(el => `<b-${el.name}`)
                ).filter(item => {
                    const displayText = (typeof item === 'string') ? item : item.displayText;
                    return displayText.includes(curWord);
                });
            }
        
            return result;
        };

        CodeMirror.commands.autocomplete = function(cm) {
            var doc = cm.getDoc();
            var POS = doc.getCursor();
            var mode = CodeMirror.innerMode(cm.getMode(), cm.getTokenAt(POS).state).mode.name;
            if (mode == 'css' || mode === "myMode" || mode == "text/x-scss") {
                cm.showHint(
                    {
                        hint: CodeMirror.hint.css,
                        completeSingle: false,
                    }
                )
            } else if(mode == 'text/x-markdown') {
                cm.showHint(
                    {
                        hint: CodeMirror.hint.anyword,
                        completeSingle: false,
                    }
                )
            } else if(mode == 'cssVariables') {
                cm.showHint(
                    {
                        hint: CodeMirror.hint.cssVariables,
                        completeSingle: true,
                    }
                )
            } else if(mode === "xml"){
                cm.showHint(
                    {
                        hint: CodeMirror.hint.html,
                        completeSingle: false,
                    }
                )
            }
        };

        // Plain Classes
        [PlainClasses].forEach(textarea => {
            if (!textarea) return;
            const myCodeMirror = CodeMirror(function(elt) {
                textarea.parentNode.replaceChild(elt, textarea);
            }, self.codeMirrorOptions(textarea));

            
                document.querySelector('#brxcPlainClassesOverlay .CodeMirror').CodeMirror.getMode().name = "text/x-markdown";
                myCodeMirror.setOption('lineNumbers', false);
                myCodeMirror.setOption('autoCloseBrackets', false);
                myCodeMirror.setOption('matchBrackets', false);
                myCodeMirror.setOption('gutters', false);
                myCodeMirror.setOption('highlightSelectionMatches', false);
                myCodeMirror.setOption("placeholder",'Type your classes here...');
                myCodeMirror.on("keydown", function (cm, event) {
                    if (!cm.state.completionActive &&
                        ((event.key >= '0' && event.key <= '9') ||    // Digits 0-9
                         (event.key >= 'a' && event.key <= 'z') ||    // Letters a-z
                         event.key === '-') &&                        // Dash
                        !event.metaKey && !event.altKey && event.key !== '{' && event.key !== '}' &&
                        !event.ctrlKey) {
                        CodeMirror.commands.autocomplete(cm, null, { completeSingle: false });
                    } 
                    else if(event.key === "Enter"){
                        const saveBtn = document.querySelector('#brxcSavePlainClasses');
                        const existingHint = document.querySelector('.CodeMirror-hints');
                        if(!existingHint) self.savePlainClasses(saveBtn, cm.getValue());

                    }
                });
                myCodeMirror.on("beforeChange", function(cm, changeObj) {
                    var typedNewLine = changeObj.origin == '+input' && typeof changeObj.text == "object" && changeObj.text.join("") == "";
                    if (typedNewLine) {
                        return changeObj.cancel();
                    }
                
                    var pastedNewLine = changeObj.origin == 'paste' && typeof changeObj.text == "object" && changeObj.text.length > 1;
                    if (pastedNewLine) {
                        var newText = changeObj.text.join(" ");
                        return changeObj.update(null, null, [newText]);
                    }
                
                    return null;
                });
            

        });
    },
    // setNewCodeMirror: function(target){
    //     const self = this;
    //     const myCodeMirror = CodeMirror(function(elt) {
    //         target.parentNode.replaceChild(elt, target);
    //     }, self.codeMirrorOptions(target));
    // },
    addRootTag: function(event, closest){
        const self = this;
        const target = event.target;
        const controlKey = target.closest(closest);
        if(!controlKey) return;
        const cm = controlKey.querySelector('.CodeMirror[data-type="at"]')
        if(!cm) return;

        const value = cm.CodeMirror.getValue();
        const result = (value === '') ? '%root% {\n\t\n}' : value + '\n\n%root% {\n\t\n}';
        cm.CodeMirror.setValue(result);

        cm.CodeMirror.focus();
        self.helpers.setCursorToLastRowMinusOne(cm.CodeMirror);
    },
    beautifyCSS: function(closest){
        const self = this;
        const cm = document.querySelector(closest + ' .CodeMirror[data-type="at"]')
        if(!cm) return;

        // Return Value
        const dataOptions = { indent_size: 2 }
        const result = css_beautify(cm.CodeMirror.getValue(), dataOptions);
        cm.CodeMirror.setValue(result);
        var event = new Event('keyup');
        cm.CodeMirror.getInputField().dispatchEvent(event);
    },
    commentCode: function(closest){
        const self = this;
        const cm = document.querySelector(closest + ' .CodeMirror[data-type="at"]')
        if(!cm) return;

        self.helpers.commentCMCode(cm);
    },
    addComponentSelectors: function(closest){
        const self = this;

        const cm = document.querySelector(closest + ' .CodeMirror[data-type="at"]')
        if(!cm) return;

        // Function
        let existingSelector = [];
        let selector = false;
        const elementObj = self.helpers.getFinalObject(true);
        const dot = self.helpers.isComponentActive() ? '.' : '#';

        function createSelector(obj,existingSelector){
            if (obj.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(obj.settings._cssGlobalClasses) && obj.settings._cssGlobalClasses.length > 0) {
                const unlocked = [];
                const locked = [];
                obj.settings._cssGlobalClasses.forEach(el => {
                    (self.vueGlobalProp.$_isLocked(el)) ? locked.push(el) : unlocked.push(el);
                });
                const ids = (unlocked.length > 0) ? unlocked : locked;
                if (ids.length > 0) {
                    let classes = [] 
                    ids.forEach(id => {
                        const classObj = self.vueGlobalProp.$_getGlobalClass(id);
                        if(classObj && classObj.hasOwnProperty('name')){
                            classes.push(classObj.name);
                        }
                    })
                    selector = `.${classes.join('.')}`;
                } else {
                    selector = false;
                }
            } else {
                selector = `${dot}${self.vueGlobalProp.$_getElementId(obj)}`;
            } 
            if(selector === false || existingSelector.includes(selector)) return "";
            existingSelector.push(selector);
            return `${selector}{\n\t\n}\n\n`;
        }

        let css = "";

        function checkChildren(obj, first){
            if(first === true) existingSelector = [];
            css += createSelector(obj, existingSelector);
            if(obj.children.length < 1) return;
            obj.children.forEach(child =>{
                checkChildren(self.helpers.getElementObject(child), false);
            })
        }

        checkChildren(elementObj, true);

        const finalSelector = self.helpers.getFinalSelector();
        const calculatedValue = self.vueGlobalProp.$_replaceCustomCssRoot(finalSelector, '%root%', css)

        // Return Value
        const value = cm.CodeMirror.getValue();
        const result = (value === '') ? calculatedValue : value + `\n\n${calculatedValue}`;
        cm.CodeMirror.setValue(result);
        var event = new Event('keyup');
        cm.CodeMirror.getInputField().dispatchEvent(event);
        cm.CodeMirror.focus();
        self.helpers.setCursorToLastRowMinusOne(cm.CodeMirror);
    },
    variabilizeCSS: function(closest, selector){
        const self = this;
        const cm = document.querySelector(closest + ' .CodeMirror[data-type="at"]')
        if(!cm) return;

        const value = cm.CodeMirror.getValue();
        const result = (value === '') ? value : self.helpers.convertCSSToVariables(value, selector);
        
        // Advanced CSS
        if(selector === ":root"){
            return cm.CodeMirror.setValue(result);
        }

        // SuperPowerCSS
        const elementObj = self.helpers.getFinalObject();
        const finalSelector = self.helpers.getFinalSelector();

        // Apply Changes;
        setTimeout(() => {
            const target = self.globalSettings.superPowerCSSEnableSass === "1"? self.helpers.createTarget('_cssCustomSass') : self.helpers.createTarget('_cssCustom');
            elementObj.settings[target] = self.vueGlobalProp.$_replaceCustomCssRoot(finalSelector,'%root%', result);
            self.vueState.rerenderControls = Date.now();
        }, 100)
    },
    convertUXinCSS: function(closest){
        const self = this;
        let cm = document.querySelector(closest + ' .CodeMirror[data-type="at"]')
        if(!cm) return;
        
        const type = self.helpers.isClassActive() ? "globalClass" : "element";
        const structureObj = self.helpers.getFinalObject(true);
        const elementObj = self.helpers.getFinalObject();
        const finalSelector = self.helpers.getFinalSelector();

        let generatedCSS = self.vueGlobalProp.$_generateCss(type, elementObj, [structureObj.name]);
        if(self.helpers.isComponentActive()) generatedCSS = generatedCSS.replaceAll('#brxe-', '.brxe-')
        const previewCSS = generatedCSS.replaceAll(`.brxe-${structureObj.name}`, '');
        const beautifiedCSS = css_beautify(previewCSS, { indent_size: 2 });

        // Reset Styles
        self.helpers.resetStyles(elementObj);

        // Apply Changes;
        setTimeout(() => {
            elementObj.settings._cssCustom = self.vueGlobalProp.$_replaceCustomCssRoot(finalSelector,'%root%', beautifiedCSS);
            self.vueState.rerenderControls = Date.now();
        }, 100)
        
    },
    setGeneratedCSS: function(){
        const self = this;
        setTimeout(() => {

            if(!self.helpers.isElementActive() || (self.showControlSearch === false && self.vueState.activePanelTab !== "style") || (self.vueState.showControlSearch === false && self.vueState.activePanelGroup !== "_generated-code") || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;
        
            const panel = document.querySelector('#bricks-panel');

            // Mount CM
            const elmntTarget = panel.querySelector('[data-controlkey="_generatedCSS"]');
            if(!elmntTarget) return;

            const textAreaTarget = elmntTarget.querySelector('textarea');

            if(textAreaTarget){
                self.mountGeneratedCSSCM(textAreaTarget, false);

            } else {
                const observer = new MutationObserver(() => {
                    const textAreaTarget = elmntTarget.querySelector('textarea')
                    if (!textAreaTarget) {
                        return;
                    }
                    
                    self.mountGeneratedCSSCM(textAreaTarget, observer);
                })
                observer.observe(elmntTarget, { subtree: true, childList: true });
    
            }
        }, 125)
    },
    mountGeneratedCSSCM: function(textAreaTarget, observer){
        const self = this;

        function generateCSS(){
            const type = self.helpers.isClassActive() ? "globalClass" : "element";
            const elementObj = self.helpers.getFinalObject();
            if(!elementObj) return;
            
            let previewCSS = self.vueGlobalProp.$_generateCss(type, elementObj, [elementObj.name]).replaceAll(`.brxe-${elementObj.name}`, '');
            if(self.helpers.isComponentActive()) previewCSS = previewCSS.replaceAll('#brxe-', '.brxe-')
            const beautifiedCSS = css_beautify(previewCSS, { indent_size: 2 });
            const finalCode = beautifiedCSS === "" ? "/* No Style applied */" : beautifiedCSS;
            return finalCode;
        }

        if(textAreaTarget.dataset.mounted === "true") return;
        textAreaTarget.setAttribute("data-mounted", "true");
        const options = self.codeMirrorOptions(false);
        options.readOnly = true;
        options.styleActiveLine = true;
        options.autofocus = false
        options.search = { bottom: false };
        const MyCM = CodeMirror.fromTextArea(textAreaTarget, options)
        MyCM.setValue(generateCSS());
        
        if(observer) observer.disconnect();


    },
    setGeneratedHTML: function(){
        const self = this;
        setTimeout(() => {

            if(!self.helpers.isElementActive() || (self.showControlSearch === false && self.vueState.activePanelTab !== "style") || (self.vueState.showControlSearch === false && self.vueState.activePanelGroup !== "_generated-code") || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;
        
            const panel = document.querySelector('#bricks-panel');

            // Mount CM
            const elmntTarget = panel.querySelector('[data-controlkey="_generatedHTML"]');
            if(!elmntTarget) return;

            const textAreaTarget = elmntTarget.querySelector('textarea');
            const parseHTMLbtn = panel.querySelector('[data-controlkey="_generatedHTMLApply"] button');

            if(textAreaTarget && parseHTMLbtn){
                self.mountGeneratedHTMLCM(textAreaTarget, false);
                self.setParseHTMLbtn(parseHTMLbtn);

            } else {
                const observer = new MutationObserver(() => {
                    const textAreaTarget = elmntTarget.querySelector('textarea')
                    const parseHTMLbtn = panel.querySelector('[data-controlkey="_generatedHTMLApply"] button');
                    if (!textAreaTarget || !parseHTMLbtn) {
                        return;
                    }
                    
                    self.mountGeneratedHTMLCM(textAreaTarget, observer);
                    self.setParseHTMLbtn(parseHTMLbtn);
                })
                observer.observe(elmntTarget, { subtree: true, childList: true });
    
            }
        }, 125)
    },
    getGeneratedHTMLMultipleElements: function(elementID){
        const self = this;
        function generateHTML(elementArr){
            return new Promise((resolve, reject) => {
                jQuery.ajax({
                    url: openai_ajax_req.ajax_url,
                    data: {
                        action: 'generated_html_multiple_elements_ajax_function',
                        nonce: openai_ajax_req.nonce,
                        elements: elementArr,
                    },
                    method: "POST",
                    success: function (response) {
                        resolve(
                            console.log(response.data)
                        );
                    },
                    error: function (data) {
                        reject('Something went wrong.');
                    }
                });
            });
        }
        function createArray(id, arr = []){
            let obj = self.helpers.getElementObject(id);
            arr.push(obj);
            if (obj.hasOwnProperty('children') && Array.isArray(obj.children) && obj.children.length > 0) {
                obj.children.forEach(childrenId => {
                    createArray(childrenId, arr);
                })
            }
            return arr;
        }

        const elements = createArray(elementID);
        generateHTML(elements);
    },
    mountGeneratedHTMLCM: function(textAreaTarget, observer){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);

        function generateHTML(){
            return new Promise((resolve, reject) => {
                jQuery.ajax({
                    url: openai_ajax_req.ajax_url,
                    data: {
                        action: 'generated_html_ajax_function',
                        nonce: openai_ajax_req.nonce,
                        element: elementObj,
                    },
                    method: "POST",
                    success: function (response) {
                        resolve(
                            MyCM.setValue(response.data)
                        );
                    },
                    error: function (data) {
                        reject('Something went wrong.');
                    }
                });
            });
        }

        if(textAreaTarget.dataset.mounted === "true") return;
        textAreaTarget.setAttribute("data-mounted", "true");
        const options = self.codeMirrorOptions(false);
        options.mode = "htmlmixed";
        options.readOnly = false;
        options.styleActiveLine = true;
        options.autofocus = false
        options.search = { bottom: false };
        options.autoCloseTags = true;
        const MyCM = CodeMirror.fromTextArea(textAreaTarget, options)
        generateHTML(MyCM);
        
        MyCM.on("keyup", function(cm, event) {
            event.stopPropagation();
            elementObj.settings._generatedHTML = cm.getValue();
        });
        
        
        if(observer) observer.disconnect();
    },
    setParseHTMLbtn: function(btn){
        const self = this;
        if(btn.dataset.mounted === "true") return;
        btn.setAttribute("data-mounted", "true");
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            let activeElement = self.helpers.getFinalObject(true);
            const customHTML = activeElement.settings.hasOwnProperty('_generatedHTML') ? activeElement.settings._generatedHTML : false;
            if(customHTML) {
                let tempDiv = document.createElement('div');
                tempDiv.innerHTML = customHTML;
                const element = tempDiv.firstElementChild;
                const elementConfig = self.vueGlobalProp.$_getElementConfig(activeElement.name);

                //Tagname
                const tagName = element.tagName.toLowerCase();
                if(tagName && tagName !== elementConfig.tag){
                    if(!elementConfig.controls.hasOwnProperty('tag')){
                        return self.vueGlobalProp.$_showMessage('ABORT: This element doesn\'t accept custom HTML tags');
                    }
                    // Exceptions
                    if(tagName === "img"){
                        //silence
                    } else {
                        if(tagName in elementConfig.controls.tag.options){
                            activeElement.settings.tag = tagName;
                        } else {
                            activeElement.settings.tag = "custom";
                            activeElement.settings.customTag = tagName;
                        }
                    }
                }

                const parsingStates =  {
                    includesIds: true,
                    excludeIds: 'brxe-',
                    includesClasses: true,
                    excludeClasses: 'brxe-',
                    createGlobalClasses: false,
                    includesTexts: true,
                    includesAttributes: true,
                    excludeAttributes: '',
                }

                //id
                activeElement = self.helpers.setIdFromParsedHTML(element, activeElement, parsingStates);

                //Classes
                activeElement = self.helpers.setClassesFromParsedHTML(element, activeElement, parsingStates);

                // Text
                activeElement = self.helpers.setTextFromParsedHTML(element, activeElement, elementConfig, parsingStates);

                // Attributes
                activeElement = self.helpers.setAttributesFromParsedHTML(element, activeElement, parsingStates);

                tempDiv.innerHTML = '';
                tempDiv = null;
                delete activeElement.settings._generatedHTML;
                self.vueState.forceRender = Date.now();

            };
        })
    },
    superPowerStates: {
        fullScreen: true,
        isActiveClass: false,
        selector: null,
        obj: null,
        mixins: '',
        sassInstances: [],
        hasValue: false,
        AIprompt : '',
        AIbackup: '',
        editAI: false,
        isAIRunning: false,
        showBookmark: false,
        searchBookmark: '',
        
    },
    setSuperPowerCSS: function(){
        const self = this;
        setTimeout(() => {
            if(!self.helpers.isElementActive() || (self.showControlSearch === false && self.vueState.activePanelTab !== "style") || (self.vueState.showControlSearch === false && self.vueState.activePanelGroup !== "_css") || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;
        
            const panel = document.querySelector('#bricks-panel');

            // Mount CM
            const elmntTarget = panel.querySelector('[data-controlkey="_cssSuperPowerCSS"]');
            if(!elmntTarget) return;

            const textAreaTarget = elmntTarget.querySelector('textarea')
            const description = elmntTarget.querySelector('.description');

            if(textAreaTarget){
                self.mountSuperPowerCSSCM(textAreaTarget, false);
                if(description) self.addFullSizeCSSState();

            } else {
                const observer = new MutationObserver(() => {
                    const textAreaTarget = elmntTarget.querySelector('textarea');
                    if (!textAreaTarget) {
                        return;
                    }
                    
                    self.mountSuperPowerCSSCM(textAreaTarget, observer);
    
                    const description = elmntTarget.querySelector('.description');
                    if(description) self.addFullSizeCSSState();
                })
                observer.observe(elmntTarget, { subtree: true, childList: true });
    
            }
        }, 125)
    },
    
    mountSuperPowerCSSCM: function(textAreaTarget, observer){
        const self = this;
        if(textAreaTarget.dataset.mounted === "true") return;
        textAreaTarget.setAttribute("data-mounted", "true");
        self.setSuperPowerCSSObject();
        const options = self.codeMirrorOptions(false);
        options.mode = self.globalSettings.superPowerCSSEnableSass === "1" ? 'text/x-scss' : 'css';
        options.readOnly = false;
        options.styleActiveLine = true;
        options.autoCloseBrackets = true;
        options.matchBrackets = true;
        options.selfContain = true;
        options.autofocus = false
        options.search = { bottom: false };
        options.profile = "xhtml";
        const MyCM = CodeMirror.fromTextArea(textAreaTarget, options);
        emmetCodeMirror(MyCM);
        MyCM.getWrapperElement().setAttribute("data-type", "at");
        MyCM.setOption('gutters', []);
        self.updateSuperPowerCSS(MyCM);
        // Expand
        setTimeout(() => {
            if(bricksData.disablePanelAutoExpand === "" && self.vueState.activePanelGroup === "_css") self.vueState.isPanelExpanded = true;
            self.addIconsToSuperpowerCSS();
            self.addMessageToSuperpowerCSS();
            self.populateCSSVariables();
            self.addListenersToSuperPowerCSS(MyCM, textAreaTarget);
            MyCM.scrollIntoView({ line: MyCM.lineCount() - 1, ch: 0 });
            MyCM.scrollIntoView({ line: 0, ch: 0 });
            if(observer) observer.disconnect();
            self.superPowerStates.AIbackup = '';
            self.superPowerStates.editAI = false;
            self.superPowerStates.AIprompt = '';
            self.superPowerStates.searchBookmark = '';
            self.superPowerCSSAIMount(textAreaTarget, MyCM, 'css');
            
        },120);

        setTimeout(() => {
            MyCM.refresh();
        },300)
    },
    superPowerCSSAIMount: function(textarea, cm, type){
        const self = this;
        if(!self.helpers.isAIActive()) return;
        
        const existing = textarea.parentElement.querySelector('#brxcSuperPowerCSSAIpromptContainer');
        if(existing) existing.remove();
        const parent = textarea.parentElement
        const AIprompt = document.createElement('DIV');
        AIprompt.id = "brxcSuperPowerCSSAIpromptContainer"
        let content = '';
        content += `<div id="brxcSuperPowerCSSAIpromptWrapper">
                        <div id="brxcSuperPowerCSSAIEdit"${self.superPowerStates.editAI ? ' class="active"' : ''} data-balloon="Edit existing code" data-balloon-pos="top-left"><i class="fas fa-edit"></i></div>
                        <textarea id="brxcSuperPowerCSSAIprompt" placeholder="Message AI">${self.superPowerStates.AIprompt}</textarea>
                        <div id="brxcSuperPowerCSSAIPlus"${self.superPowerStates.showBookmark ? ' class="active"' : ''} data-balloon="Choose a global prompt" data-balloon-pos="top-right"><i class="fas fa-bookmark"></i></div>
                        <div id="brxcSuperPowerCSSAISendRequest"${self.superPowerStates.isAIRunning ? ' class="disable"' : ' onclick="ADMINBRXC.superPowerCSSAIRequest(this);"'} data-balloon="Send" data-balloon-pos="top-right"><i class="fas fa-arrow-up"></i></div>`
    if(self.superPowerStates.AIbackup !== '') content += `<div id="brxcSuperPowerCSSAIUndo" data-balloon="Undo AI changes" data-balloon-pos="top-right"><i class="fas fa-undo"></i></div>`
    if(self.superPowerStates.showBookmark) {
        self.superPowerStates.searchBookmark = ''
        content += `<div id="brxcSuperPowerCSSAIPopup" class="bricks-control-popup bottom">
                        <div class="css-classes">
                            <h6 class="title"><span>Global AI Prompts</span></h6>
                            <ul id="brxcPrompListLiCanvas">
                                ${(Array.isArray(brxcPromptManager) ? brxcPromptManager.filter(el => el.category === type).map(obj => `
                                    <li data-id="${obj.id}">
                                        <span class="name">${obj.label}</span>
                                    </li>`).join('') : '')}
                            </ul>
                        </div>
                        <div class="input-wrapper">
                            <input type="text" autocomplete="off" spellcheck="false" placeholder="Search for a prompt ..." oninput="ADMINBRXC.superPowerStates.searchBookmark = this.value;ADMINBRXC.superPowerCSSUpdateBookmarkList();">
                        </div>
                    </div>`;
        }
        content +=`</div>`; // end wrapper


        AIprompt.innerHTML = content;
        parent.appendChild(AIprompt);

        // Listeners
        const inputText = parent.querySelector('#brxcSuperPowerCSSAIprompt');
        if(inputText){
            self.helpers.textAreaAutoGrow(inputText, '30px')
            inputText.addEventListener('keyup', (e) => {
                self.superPowerStates.AIprompt = e.target.value;
                self.helpers.textAreaAutoGrow(e.target, '30px')
            })
        }

        const editBtn = parent.querySelector('#brxcSuperPowerCSSAIEdit');
        if(editBtn){
            editBtn.addEventListener('click', () => {
                self.superPowerStates.editAI = !self.superPowerStates.editAI;
                self.superPowerCSSAIMount(textarea, cm, 'css');
            })
        }

        const bookmark = parent.querySelector('#brxcSuperPowerCSSAIPlus');
        if(bookmark){
            bookmark.addEventListener('click', () => {
                self.superPowerStates.showBookmark = !self.superPowerStates.showBookmark;
                self.superPowerCSSAIMount(textarea, cm, 'css');
            })
        }

        const popup = parent.querySelector('#brxcSuperPowerCSSAIPopup');
        if(popup){
            popup.addEventListener('click', (e) => {
                if(e.target.dataset.id){
                    self.superPowerCSSPlusSelect(e.target.dataset.id);
                }
            })
        }

        const undo = parent.querySelector('#brxcSuperPowerCSSAIUndo');
        if(undo){
            undo.addEventListener('click', (e) => {
                cm.setValue(self.superPowerStates.AIbackup);
                self.superPowerStates.AIbackup = '';
                self.superPowerCSSAIMount(textarea, cm, 'css');
            })
        }

    },
    superPowerCSSUpdateBookmarkList: function(){
        const self = this;
        const parent = document.querySelector('#brxcPrompListLiCanvas');
        Array.from(parent.children).forEach(item => {
            if(self.superPowerStates.searchBookmark === '' || item.textContent.toLowerCase().includes(self.superPowerStates.searchBookmark.toLowerCase())){
                item.style.display = 'flex';
            } else {
                item.style.display = 'none';
            }
        })
    },
    superPowerCSSPlusSelect: function(id){
        const self = this;
        const obj = brxcPromptManager.find(el => el.id === id);
        self.superPowerStates.AIprompt = obj.prompt;
        self.superPowerStates.showBookmark = false;

        const textarea = document.querySelector('#bricks-panel [data-controlkey="_cssSuperPowerCSS"] textarea');
        const cm = document.querySelector('#bricks-panel [data-controlkey="_cssSuperPowerCSS"] .CodeMirror').CodeMirror;
        self.superPowerCSSAIMount(textarea, cm, 'css');
    },
    superPowerCSSAIRequest: function(currentElement){
        const self = this;
        const elmntTarget = document.querySelector('#bricks-panel [data-controlkey="_cssSuperPowerCSS"]');
        if(!elmntTarget) return;

        const cm = currentElement.closest('[data-controlkey="_cssSuperPowerCSS"]').querySelector('.CodeMirror').CodeMirror;
        if(!cm) return;

        const textAreaTarget = elmntTarget.querySelector('textarea')
        let cssString = cm.getValue();
        const promptRequest = currentElement.parentElement.querySelector('textarea').value;
        const type = self.superPowerStates.sassInstances.length === 0 ? "css" : "scss";
        let systemtContent = '';
        if(self.superPowerStates.editAI){
            systemtContent = `You are an expert ${type} developer. You will receive a ${type} string, a user prompt, and a target selector. Your task is to edit or improve the existing ${type} string based on the prompt. The target selector that is provided represents the root selector of the component you're modifiying. Return only the raw ${type} code without any additional comments, explanations, or text. The output must be valid, executable ${type} code, with no formatting, comments, or non-${type} elements. Don't start with "${type}". Do not include any text that is not part of a valid ${type} declaration. Example of expected output format: "${self.superPowerStates.selector}{color: red;}". Note that complex/compound selectors are allowed if required (example: "${self.superPowerStates.selector} img, ${self.superPowerStates.selector} > div + p{color: red;}").`
        } else {
            systemtContent = `You are an expert ${type} developer. You will receive an existing ${type} string for context, a user prompt, and a target selector. Your task is to generate new ${type} code based on the prompt and append it to the existing ${type} code. The target selector that is provided represents the root selector of the component you're modifiying. Do not repeat or modify the existing ${type} code. Output only the new rules without any additional comments, explanations, or text. Don't start with "${type}". The response should contain only valid, executable ${type} declarations and nothing else. Example of expected output format: "${self.superPowerStates.selector}{color: red;}". Note that complex/compound selectors are allowed if required (example: "${self.superPowerStates.selector} img, ${self.superPowerStates.selector} > div + p{color: red;}").`
        }

        const requestBody = {
            model: self.globalSettings.defaultAIModel,
            stream: true,
            messages: [
                {
                    role: "system",
                    content: systemtContent,
                },
                {
                    role: "user",
                    content: `Target Selector:"${self.superPowerStates.selector}\n"Existing ${type}:"${cssString}"\nUser Request:"${promptRequest}"`
                }
            ]
        };

        self.superPowerStates.AIprompt = '';
        self.superPowerStates.isAIRunning = true;
        self.superPowerCSSAIMount(textAreaTarget, cm, 'css')

        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce
            },
            success: function(response) {
                const fetchDescription = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization' : 'Bearer ' + response,
                        },
                        body: JSON.stringify(requestBody)
                    });
 
                    if(!rawResponse.ok){
                        const statusText = rawResponse.status === 401 ? "Unauthorized. Double-check you correctly inserted the OpenAI API key inside the Theme Settings." : rawResponse.statusText;
                        self.superPowerStates.isAIRunning = false;
                        self.superPowerCSSAIMount(textAreaTarget, cm, 'css')
                    } else {
                        // Create a reader to read the streamed response
                        const reader = rawResponse.body.getReader();
                        const decoder = new TextDecoder();
                        let newCssCode = `/* CSS generated by AI on: ${new Date().toLocaleString()} */\n\n`;
                        let index = 0;
                        self.superPowerStates.AIbackup = cssString;
                
                        // Function to handle each chunk of data
                        const processChunk = async () => {
                            const { done, value } = await reader.read();
                            if (done) {
                                // All chunks have been read
                                return;
                            }
                
                            // Decode and parse the JSON chunk
                            const chunkText = decoder.decode(value);


                            // Split the chunk text into lines and process each one
                            const lines = chunkText.split('\n').filter(line => line.trim() !== '');
                            for (let line of lines) {
                                // Check if the line starts with "data: "
                                if (line.startsWith("data: ")) {
                                    const jsonLine = line.replace("data: ", "").trim();
                                    if (jsonLine !== "[DONE]") {
                                        try {
                                            // Parse the JSON and get the new CSS content
                                            const parsedData = JSON.parse(jsonLine);
                                            if (parsedData.choices && parsedData.choices[0].delta && parsedData.choices[0].delta.content) {
                                                let cssChunk = parsedData.choices[0].delta.content;
                                
                                                // Remove any code block symbols and formatting hints
                                                cssChunk = cssChunk.replace(/```/g, '');
                                                // Append the clean CSS content
                                                if (!(index === 0 && cssChunk.toLowerCase() === type)) {
                                                    newCssCode += cssChunk;
                                                }

                                                // Apply the new CSS live to the document
                                                const cmValue = self.superPowerStates.editAI ? newCssCode : cssString + newCssCode;
                                                const finalValue = self.vueGlobalProp.$_replaceCustomCssRoot(self.superPowerStates.selector, '%root%', cmValue);
                                                cm.setValue(css_beautify(finalValue, { indent_size: 2 }));
                                            }
                                        } catch (e) {
                                            console.error('Failed to parse JSON chunk:', e, jsonLine);
                                            self.superPowerStates.isAIRunning = false;
                                            self.superPowerCSSAIMount(textAreaTarget, cm, 'css')
                                        }
                                    } else {
                                        self.superPowerStates.isAIRunning = false;
                                        self.superPowerCSSAIMount(textAreaTarget, cm, 'css')
                                    }
                                    index++;
                                }
                            }
                
                            // Continue reading the next chunk
                            processChunk();
                        };
                
                        // Start processing chunks
                        await processChunk();
                    }
                };
                fetchDescription();
            },
            error: function(response){
                self.vueGlobalProp.$_showMessage('Something went wrong with the OpenAI AJAX request: ' + response);
            }
        }); 
    },
    setSuperPowerCSSObject: function(){
        const self = this;
        
        if (!self.helpers.isClassActive()) {
            self.superPowerStates.obj = self.helpers.getFinalObject(true);
            self.superPowerStates.isActiveClass = false;
            self.superPowerStates.selector = self.helpers.getFinalSelector();
        } else {
            self.superPowerStates.isActiveClass = true;
            self.superPowerStates.selector = `.${self.vueState.activeClass.name}`;
            self.superPowerStates.obj = self.helpers.getFinalObject();
        }

        self.compilePartials(self.advancedCSSStates);
        self.compilePartialsVariables(self.advancedCSSStates);
    },
    addIconsToSuperpowerCSS: function(){
        const self = this;
        const controlKey = document.querySelector('[data-controlkey="_cssSuperPowerCSS"]');
        let action = '';
        let existing = '';
        (controlKey) ? existing = controlKey.querySelector('.CodeMirror[data-type="at"]') : existing = false;
        (controlKey) ? action = controlKey.querySelector('.brxc-action') : action = false;
        (existing && !action) ? existing.insertAdjacentHTML('beforeBegin', '<div class="brxc-action"></div>') : '';
        action = controlKey.querySelector('.brxc-action')
        if(action){
            const options = {
                "wrapper": action,
                "selector": '[data-controlkey=_cssSuperPowerCSS]',
                "root": true,
                "comment": true,
                "fullscreen": true,
                "contextualSuperpowercss": {
                    "component-selectors": true,
                    "beautify-css": true,
                    "variabilize-css": true,
                    "extract-global-classes": true,
                    "extract-global-variables": true,
                    "convert-UX-values": true,
                    "fullsize": true,
                },
                "collapse": true,
                "rootSelector": '%root%',
            }
            self.superPowerCSSIcons(options);
        }
    },
    addMessageToSuperpowerCSS: function(){
        const self = this;
        const controlKey = document.querySelector('[data-controlkey="_cssSuperPowerCSS"]');
        let action = '';
        let existing = '';
        (controlKey) ? existing = controlKey.querySelector('.CodeMirror[data-type="at"]') : existing = false;
        (controlKey) ? action = controlKey.querySelector('.brxc-error-handling') : action = false;
        (existing && !action) ? existing.insertAdjacentHTML('afterend', '<div class="brxc-skip-remount brxc-error-handling"></div>') : '';
    },
    superPowerCSSIcons: function(options){
        const self = this;
        const optionKeys = Object.keys(options);

        // Root icon
        const iconRoot = options.wrapper.querySelector('.brxc-toggle-root');
        if(!iconRoot && optionKeys.includes('root') && options['root']){
            self.addIconToFields(
                'div',
                'brxc-toggle-root',
                false,
                'Add %root% {}',
                'bottom-right',
                `ADMINBRXC.addRootTag(event,'${options.selector}')`,
                true,
                `<span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" class="brxc__svg-path"><path d="M28.5 40v-3h6q1.05 0 1.775-.725Q37 35.55 37 34.5v-5q0-1.85 1.125-3.3 1.125-1.45 2.875-2v-.4q-1.75-.5-2.875-1.975T37 18.5v-5q0-1.05-.725-1.775Q35.55 11 34.5 11h-6V8h6q2.3 0 3.9 1.6t1.6 3.9v5q0 1.05.725 1.775Q41.45 21 42.5 21H44v6h-1.5q-1.05 0-1.775.725Q40 28.45 40 29.5v5q0 2.3-1.6 3.9T34.5 40Zm-15 0q-2.3 0-3.9-1.6T8 34.5v-5q0-1.05-.725-1.775Q6.55 27 5.5 27H4v-6h1.5q1.05 0 1.775-.725Q8 19.55 8 18.5v-5q0-2.3 1.6-3.9T13.5 8h6v3h-6q-1.05 0-1.775.725Q11 12.45 11 13.5v5q0 1.85-1.125 3.325T7 23.8v.4q1.75.55 2.875 2T11 29.5v5q0 1.05.725 1.775Q12.45 37 13.5 37h6v3Z"></path></svg></span>`,
                options.wrapper,
                'child'
            );
        }

        // Comment
        const iconComment = options.wrapper.querySelector('.brxc-toggle-comment');
        if(!iconComment && optionKeys.includes('comment') && options['comment']){
            self.addIconToFields(
                'div',
                'brxc-toggle-comment',
                false,
                'Comment Selected Code',
                'bottom-right',
                `ADMINBRXC.commentCode('${options.selector}')`,
                true,
                `<span class="bricks-svg-wrapper"><i class="fas fa-eye"></i></span>`,
                options.wrapper,
                'child'
            );
        }

        // Full screen
        const iconFullScreen = options.wrapper.querySelector('.brxc-toggle-fullscreen');
        if(!iconFullScreen && optionKeys.includes('fullscreen') && options['fullscreen']){
            self.addIconToFields(
                'div',
                'brxc-toggle-fullscreen',
                false,
                'Fullscreen',
                'bottom-right',
                `ADMINBRXC.addFullScreenCSS(event,'${options.selector}')`,
                true,
                `<span class="bricks-svg-wrapper"><i class="fas fa-display"></i></span>`,
                options.wrapper,
                'child'
            );
        }

        // Selector Picker
        const iconSelectorPicker = options.wrapper.querySelector('.brxc-selector-picker');
        const iconSelectorPickerClasses = self.selectorPickerState.active ? "brxc-toggle-selector-picker active" : "brxc-toggle-selector-picker";
        if(!iconSelectorPicker && optionKeys.includes('selector-picker') && options['selector-picker']){
            self.addIconToFields(
                'div',
                iconSelectorPickerClasses,
                false,
                'Selector Picker',
                'bottom-right',
                `ADMINBRXC.toggleSelectorPicker(event,'${options.selector}')`,
                true,
                `<span class="bricks-svg-wrapper"><i class="fas fa-crosshairs"></i></span>`,
                options.wrapper,
                'child'
            );
        }

        // advanced features
        const advancedFeatures = options.wrapper.querySelector('.brxc-toggle-advanced');
        if(!advancedFeatures && optionKeys.includes('contextualSuperpowercss') && options['contextualSuperpowercss']){
            self.addIconToFields(
                'div',
                'brxc-toggle-advanced',
                false,
                'Advanced Features',
                'bottom-right',
                `event.stopPropagation();ADMINBRXC.sscsOpenAdvancedFeatures(event,'${options.selector}', '${options.rootSelector}', '${JSON.stringify(options['contextualSuperpowercss'])}')`,
                true,
                `<span class="bricks-svg-wrapper"><i class="fas fa-ellipsis"></i></span>`,
                options.wrapper,
                'child'
            );
        }
        
        //Collapse
        const iconCollapse = options.wrapper.querySelector('.brxc-toggle-collapse');
        if(!iconCollapse && optionKeys.includes('collapse') && options['collapse']){
            let balloon = self.vueState.isPanelExpanded ? 'Collapse' : 'Expand';
            let icon = self.vueState.isPanelExpanded ? `<svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M217.9,256l127.1,-127c9.4,-9.4 9.4,-24.6 0,-33.9c-9.4,-9.4 -24.6,-9.3 -34,0l-144,143.9c-9.1,9.1 -9.3,23.7 -0.7,33.1l144.6,144.9c4.7,4.7 10.9,7 17,7c6.1,0 12.3,-2.3 17,-7c9.4,-9.4 9.4,-24.6 0,-33.9l-127,-127.1Z" fill="currentColor"></path></svg>` : `<svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M294.1,256l-127.1,-127c-9.4,-9.4 -9.4,-24.6 0,-33.9c9.4,-9.3 24.6,-9.3 34,0l144,143.9c9.1,9.1 9.3,23.7 0.7,33.1l-144.6,144.9c-4.7,4.7 -10.9,7 -17,7c-6.1,0 -12.3,-2.3 -17,-7c-9.4,-9.4 -9.4,-24.6 0,-33.9l127,-127.1Z" fill="currentColor"></path></svg>`; 
            self.addIconToFields(
                'div',
                'brxc-toggle-collapse',
                false,
                balloon,
                'bottom-right',
                `ADMINBRXC.addResizeCSS(this,'${options.selector}')`,
                true,
                icon,
                options.wrapper,
                'child'
            );
        }
    },
    addFullSizeCSSState: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.activePanelTab !== "style" || self.vueState.activePanelGroup !== "_css" ) return;
        
        const description = document.querySelector('body[data-superpower-css="true"] #bricks-panel-element [data-controlkey="_cssSuperPowerCSS"] .description');
        if(!description) return;
        self.superPowerStates.fullScreen === true ? description.style.display = "none" : description.style.display = "block";
    },
    addFullSizeCSS: function(){
        const self = this;
        self.superPowerStates.fullScreen === true ? self.superPowerStates.fullScreen = false : self.superPowerStates.fullScreen = true;
        self.vueState.rerenderControls = Date.now();

    },
    addResizeCSS: function(target,  closest){
        const self = this;
        self.vueState.isPanelExpanded = !self.vueState.isPanelExpanded;
        let balloon = self.vueState.isPanelExpanded ? 'Collapse' : 'Expand';
        let icon = self.vueState.isPanelExpanded ? `<svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M217.9,256l127.1,-127c9.4,-9.4 9.4,-24.6 0,-33.9c-9.4,-9.4 -24.6,-9.3 -34,0l-144,143.9c-9.1,9.1 -9.3,23.7 -0.7,33.1l144.6,144.9c4.7,4.7 10.9,7 17,7c6.1,0 12.3,-2.3 17,-7c9.4,-9.4 9.4,-24.6 0,-33.9l-127,-127.1Z" fill="currentColor"></path></svg>` : `<svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M294.1,256l-127.1,-127c-9.4,-9.4 -9.4,-24.6 0,-33.9c9.4,-9.3 24.6,-9.3 34,0l144,143.9c9.1,9.1 9.3,23.7 0.7,33.1l-144.6,144.9c-4.7,4.7 -10.9,7 -17,7c-6.1,0 -12.3,-2.3 -17,-7c-9.4,-9.4 -9.4,-24.6 0,-33.9l127,-127.1Z" fill="currentColor"></path></svg>`; 
        target.setAttribute('data-balloon', balloon);
        target.innerHTML = icon;

        //refresh
        const cm = document.querySelector(`${closest} .CodeMirror`).CodeMirror;
        if(!cm) return;
        setTimeout(() => {
            cm.refresh();
        },250)
    },
    addFullScreenCSS: function(event, closest){
        const self = this;
        const target = event.target;
        const controlKey = target.closest(closest);
        if(!controlKey) return;
        controlKey.classList.toggle('full-screen');

        const cm = controlKey.querySelector('.CodeMirror[data-type="at"]')
        if(!cm) return;

        cm.CodeMirror.refresh()

    },
    selectorPickerState: {
        active: false,
        cm: false
    },
    toggleSelectorPicker: function(event, closest){
        const self = this;
        const wrapper = document.querySelector('#brxcCSSOverlay');
        const target = event.target;
        const controlKey = target.closest(closest);
        if(!controlKey) return;
        const cm = controlKey.querySelector('.CodeMirror[data-type="at"]')
        if(!cm) return;

        self.selectorPickerState.active = !self.selectorPickerState.active;
        self.selectorPickerState.cm = self.selectorPickerState.active ? cm.CodeMirror : false;

        // Disable Selector Picker 
        if(!self.selectorPickerState.active){
            self.advancedCSSInit();

        // Enable Selector Picker
        } else {
            FRAMEBRXC.content.body.setAttribute('data-selector-picker', 'true');
            wrapper.setAttribute('data-selector-picker', 'true');
            target.classList.add('active');
        }
    },
    disableSelectorPicker: function(){
        const self = this;
        
        self.selectorPickerState.active = false;
        const wrapper = document.querySelector('#brxcCSSOverlay');
        FRAMEBRXC.content.body.removeAttribute('data-selector-picker');
        wrapper.removeAttribute('data-selector-picker');
    },
    selectorPickerInit: function() {
        const self = this;

        FRAMEBRXC.content.body.addEventListener('click', (event) => {
            if(!self.selectorPickerState.active || !self.selectorPickerState.cm) return;
            const existingValue = self.selectorPickerState.cm.getValue();
            let separator = '\n\n'
            if(existingValue === '' || existingValue.endsWith('\n\n')){
                separator = ''
            } else if(existingValue.endsWith('\n')){
                separator = '\n'
            }

            const selector = self.helpers.getCSSSelector(event.target);
            if(selector) self.selectorPickerState.cm.setValue(`${self.selectorPickerState.cm.getValue()}${separator}${selector} {\n  \n}`);
        })
        
    },
    sscsOpenAdvancedFeatures: function(event, closest, selector, json){
        const self = this;
        const rect = event.target.getBoundingClientRect();
        const existingModal = document.querySelector('#sscsOpenAdvancedFeatures');
        if(existingModal) existingModal.remove();

        const a = document.createElement('DIV');
        a.id = "sscsOpenAdvancedFeatures";
        a.classList.add('brxc-context-menu');
        a.classList.add('show');
        const options = JSON.parse(json);
        let fullSizeLabel = self.superPowerStates.fullScreen === false ? 'Hide Shortcuts Cheatsheet' : 'Show Shortcuts Cheatsheet';
        let content = `<ul>`
        options.hasOwnProperty('component-selectors') && options["component-selectors"] ? content += `<li ${self.helpers.isElementActive() ? `onclick="ADMINBRXC.addComponentSelectors('${closest}')"` : 'class="disabled"'}>Add Component Selectors</li>` : '';
        options.hasOwnProperty('beautify-css') && options["beautify-css"] ? content +=`<li onclick="ADMINBRXC.beautifyCSS('${closest}')"><span class="label">Beautify CSS</span><span class="shortcut">${self.vueState.isMac ? 'CMD + B' : 'CTRL + B'}</span></li>` : '';
        options.hasOwnProperty('variabilize-css') && options["variabilize-css"] ? content += `<li onclick="ADMINBRXC.variabilizeCSS('${closest}', '${selector}')">Variabilize CSS</li>` : '';
        options.hasOwnProperty('extract-global-classes') && options["extract-global-classes"] ? content += `<li onclick="ADMINBRXC.parseGlobalCSS('${closest}')">Extract Classes & Add them as Global Classes</li>` : '';
        options.hasOwnProperty('extract-global-variables') && options["extract-global-variables"] ? content += `<li onclick="ADMINBRXC.extractGlobalVariables('${closest}')">Extract Variables & Add them as Global Variables</li>` : '';
        options.hasOwnProperty('convert-UX-values') && options["convert-UX-values"] ? content += `<li onclick="ADMINBRXC.convertUXinCSS('${closest}')">Convert UX values to CSS</li>` : '';
        options.hasOwnProperty('fullsize') && options["fullsize"] ? content += `<li class="sep"></li><li onclick="ADMINBRXC.addFullSizeCSS()">${fullSizeLabel}</li>` : '';
        content +=`</ul>`;
        a.innerHTML = content;
        document.body.appendChild(a);
        const rectMenu = a.getBoundingClientRect();
        a.style.top = `${rect.top}px`;
        a.style.left = `max(0px, calc(${rect.left}px + ${rect.width}px - ${rectMenu.width}px))`;


        // Listeners
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        function openMenu() {
            window.addEventListener('click', windowClickListener);
            x.document.addEventListener('click', windowClickListener);
        }
        
        function closeMenu() {
            window.removeEventListener('click', windowClickListener);
            x.document.removeEventListener('click', windowClickListener);
            if(a) a.classList.remove('show');

        }
        
        function windowClickListener(event) {
            closeMenu();
        }
        openMenu();
    },
    destroySassInstances: function(type){
        const self = this;
        const arr = type === 'advancedCss' ? self.sassInstances : self.superPowerStates.sassInstances;
        arr.forEach(sassInstance => {
            sassInstance.destroy();
        })
        self.sassInstances.length = 0; 
    },
    createSassInstance: function(type){
        const self = this;
        const sass = new Sass();
        type === 'advancedCss' ? self.sassInstances.push(sass) : self.superPowerStates.sassInstances.push(sass);
        return sass;
    },
    addListenersToSuperPowerCSS: function(MyCM) {
        const self = this;
        const target = self.helpers.createTarget('_cssCustom');
        const targetSass = self.helpers.createTarget('_cssCustomSass');
        const metaKey = (e) => self.vueState.isMac ? e.metaKey : e.ctrlKey;
        let sass = false;
        if (self.globalSettings.superPowerCSSEnableSass === "1"){
            self.destroySassInstances();
            sass = self.createSassInstance();
        }

        function handleCSSChangePromise(cm, obj) {
            return new Promise(function(resolve, reject) {
                try {
                    handleCSSChange(cm, obj);
                    resolve();
                } catch (e) {
                    reject(e);
                }
            });
        }
        
        function saveChangesPromise(className) {
            return new Promise(function(resolve, reject) {
                try {
                    self.helpers.saveChanges(className);
                    resolve();
                } catch (e) {
                    reject(e);
                }
            });
        }

        function handleCSSChange(cm, settingsObj) {
            const newValue = self.vueGlobalProp.$_replaceCustomCssRoot('%root%', self.superPowerStates.selector, cm.getValue());
             if (newValue === "") {
                self.advancedCSSRemoveError(document.querySelector('[data-controlkey="_cssSuperPowerCSS"]'));
                 setTimeout(() => {
                     delete settingsObj.settings[target];
                     if (self.globalSettings.superPowerCSSEnableSass === "1") delete settingsObj.settings[targetSass];
                    
                 }, 10);
             } else {
                 if (self.globalSettings.superPowerCSSEnableSass === "1") {
                     const dataOptions = { indent_size: 2 };
                     settingsObj.settings[targetSass] = newValue;

                     // Compiled CSS
                     if(sass){
                        sass.compile(self.advancedCSSStates.partials+newValue, function(result) {
                            if (result.status === 0) {
                                self.advancedCSSRemoveError(document.querySelector('[data-controlkey="_cssSuperPowerCSS"]'));
                                const strippedComment = self.helpers.removeCommentedCSS(result.text) ? self.helpers.removeCommentedCSS(result.text) : false;
                                if(strippedComment){
                                    const vanillaCSS = css_beautify( strippedComment, dataOptions);
                                    settingsObj.settings[target] = vanillaCSS;
                                }

                            } else {
                               self.advancedCSSHandleError(result, document.querySelector('[data-controlkey="_cssSuperPowerCSS"]'))
                            }
                        });
                     }
                 } else {
                     // APPLY THE VALUE INSIDE THE ELEMENT/GLOBAL CLASS OBJECT
                     settingsObj.settings[target] = newValue;
                 }
             }

            // Add as modified
            if(self.superPowerStates.isActiveClass){
                self.helpers.saveChanges('globalClasses');
                if(self.vueState.globalChanges.modified.includes(self.vueState.activeClass.id)) self.vueState.globalChanges.modified.push(self.vueState.activeClass.id);
            } else if(self.helpers.isComponentActive()){
                self.helpers.saveChanges('components');
            } else {
                self.helpers.saveChanges(self.helpers.getTemplateType());
            }
        }
         MyCM.on("keydown", function (cm, event) {  
            // Save
            if(metaKey(event) && event.key === "s" ){
                event.preventDefault();
                event.stopPropagation();
                handleCSSChangePromise(cm, self.superPowerStates.obj)
                    .then(function() {
                        if (self.superPowerStates.isActiveClass) {
                            return saveChangesPromise('globalClasses');
                        } else {
                            return saveChangesPromise('content');
                        }
                    })
                    .then(function() {
                        self.vueGlobalProp.$_savePost();
                    })
                    .catch(function(error) {
                        self.vueGlobalProp.$_showMessage('Error while saving:', error);
                    });
                return;
            } 

            // Beautify
            if(metaKey(event) && event.key === "b" ){
                event.preventDefault();
                event.stopPropagation();
                return self.beautifyCSS(`[data-controlkey=_cssSuperPowerCSS]`)
            }

            // Search
            if(metaKey(event) && event.key === "f" ){
                event.preventDefault();
                event.stopPropagation();
                return cm.execCommand('find');
            }

            // Comments
            if(metaKey(event) && event.shiftKey && event.key === "7" ){
                return cm.toggleComment();
            }

            // Tabs
            if (event.key === 'Tab') {
                return self.helpers.replaceRWithRoot(MyCM, event)
               
            }

            // Autocomplete
             if (!cm.state.completionActive &&
                 ((event.key >= '0' && event.key <= '9') ||    // Digits 0-9
                     (event.key >= 'a' && event.key <= 'z') ||    // Letters a-z
                     event.key === '(' || event.key === '!' ||    // Opening parenthesis (
                     event.key === '-') &&                        // Dash
                 !event.metaKey && !event.altKey && event.key !== '{' && event.key !== '}' &&
                 !event.ctrlKey || event.key === '@' || event.key === '$') {
                 CodeMirror.commands.autocomplete(cm, null, { completeSingle: false });
                 return;
             }
         })
         const debouncedCSSChange = self.debounce(function(cm, activeObj) {
            handleCSSChange(cm, activeObj);
        }, 150);
        
        MyCM.on("change", function(cm, event) {
            debouncedCSSChange(cm, self.superPowerStates.obj);
        });
    },
    updateSuperPowerCSS: function(MyCM){
        const self = this;
        const activeEl = self.superPowerStates.obj;
        if(!activeEl || !activeEl.hasOwnProperty('settings')) return;
        
        const maybeSassTarget = self.helpers.createTarget('_cssCustomSass');
        let target = self.globalSettings.superPowerCSSEnableSass === "1" && activeEl.settings.hasOwnProperty(maybeSassTarget) ? maybeSassTarget : self.helpers.createTarget('_cssCustom');
        const settings = (activeEl.settings.hasOwnProperty(target)) ? activeEl.settings[target] : '';
        const finalValue = self.vueGlobalProp.$_replaceCustomCssRoot(self.superPowerStates.selector, '%root%', settings)
        MyCM.setValue(finalValue);
        if(finalValue !== '') self.superPowerStates.hasValue = true;
    },
    forceClassStlyesStates: {
        showLock: true,
        lastElementId: ''
    },
    forceClassStlyes: function (){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        const panel = document.querySelector('#bricks-panel-element');
        if(!panel) return;

        const contentControls = panel.querySelectorAll('.bricks-panel-controls ul.controls li');
        const elementObj = self.helpers.getFinalObject(true);
        if(!elementObj) return;

        if(contentControls.length > 0){
            const name = elementObj.name;
            contentControls.forEach(el => {
                const data = el.dataset.controlkey;
                if(bricksData.elements[name].controls[data] && bricksData.elements[name].controls[data].hasOwnProperty('css')) el.style.display = "block";
            })
        }
        const tabs = panel.querySelector('ul#bricks-panel-tabs');
        if (!tabs) return;

        if (self.helpers.isClassActive() || (self.globalSettings.classFeatures.lockIdWithClasses === "1" && !self.helpers.hasGlobalClass(elementObj.id) ) ) {
            self.forceClassStlyesStates.showLock = false;
            self.forceClassStlyesStates.lastElementId = '';
        } else if (self.forceClassStlyesStates.lastElementId !== elementObj.id){
            self.forceClassStlyesStates.showLock = true
            self.forceClassStlyesStates.lastElementId = elementObj.id;
        }
        const styleTab = tabs.querySelectorAll('li')[1];
        const icon = panel.querySelector('.disabled-style-icon');
        (icon) ? icon.remove() : '';

        panel.setAttribute("data-has-class", "true")
        styleTab.classList.remove('brxc-style-tab-disabled')

        //if state brxc.showLock is true
        if(self.forceClassStlyesStates.showLock === true) {
            if(contentControls.length > 0){
                const name = elementObj.name;
                contentControls.forEach(el => {
                    const data = el.dataset.controlkey;
                    if(bricksData.elements[name].controls[data] && bricksData.elements[name].controls[data].hasOwnProperty('css')) el.style.display = "none";
                })
            }
            panel.removeAttribute("data-has-class");
            self.vueState.activePanelTab = "content";
            styleTab.classList.add('brxc-style-tab-disabled')
            self.addIconToFields('div','disabled-style-icon', false, 'Click to unlock styling on ID level', 'top-right', false, false,  '<span class="bricks-svg-wrapper"><i class="fas fa-lock"></span>', tabs, 'child');
            const icon = panel.querySelector('.disabled-style-icon')
            icon.addEventListener('click', () =>{
                self.forceClassStlyesStates.showLock = false;
                icon.remove();
            })

        }

    },
    openClassContextualMenu: function(){
        const self = this;
        const menu = document.querySelector('#brxc-class-context-menu');
        const menuCanvas = document.querySelector('#brxc-class-context-menu-canvas');
        const icon = document.querySelector('.class-contextual-menu-icon');
        const shortcutPrefix = self.vueState.isMac ? 'CTRL + CMD' : 'CTRL + SHIFT';
        const activeObj = self.helpers.getFinalObject(true)
        let content = '';

        function isElementHidden(){
            const target = self.helpers.createTarget('_display');
            if(typeof activeObj === "undefined" || !activeObj.hasOwnProperty('settings') || !activeObj.settings.hasOwnProperty(target) || activeObj.settings[target] !== "none") {
                return false;
            }
            return true;
        }

        function isRootComponent(){
            if(activeObj.settings.hasOwnProperty('classConverterComponent') && activeObj.settings.classConverterComponent === true){
                return true;
            } 
            return false;
        }
        let globalContent = `<li class="sep"></li>
                                <li onclick="ADMINBRXC.openPlainClassesModal(event, &quot;#brxcPlainClassesOverlay&quot;)">
                                    <span class="label">Plain Classes</span>
                                    <span class="shortcut">${shortcutPrefix} + ${self.globalSettings.keyboardShortcuts.plainClasses}</span>
                                </li>
                                <li onclick="ADMINBRXC.openFindReplaceModal(event,false, &quot;#brxcFindReplaceModal&quot;)">
                                    <span class="label">Find &amp; Replace Styles</span>
                                    <span class="shortcut">${shortcutPrefix} + ${self.globalSettings.keyboardShortcuts.findAndReplace}</span>
                                </li>
                                <li onclick="ADMINBRXC.styleOverviewInit(ADMINBRXC.helpers.getFinalObject(true),true);ADMINBRXC.openModal(false, &quot;#brxcStyleOverviewOverlay&quot;, document.querySelector(&quot;#brxcStyleOverviewOverlay input[type=search]&quot;));">Style Overview</li>`
        globalContent += `<li onclick="ADMINBRXC.setClassConverter();ADMINBRXC.openModal(false, &quot;#brxcClassConverterOverlay&quot;)" ;'=""><span class="label">Class Converter</span><div class="buttons"><span class="action" data-balloon="${isRootComponent() ? 'Disable Root Component' : 'Enable Root Component'}" data-balloon-pos="top" onclick="event.stopPropagation();ADMINBRXC.rootClassComponentToggle()"><i class="fas fa-toggle-${isRootComponent() ? 'on' : 'off'}"></i></span></div></li>`;
        if(!self.helpers.isClassActive()){
            content += `<ul>`
            content += `<li onclick="ADMINBRXC.hideElement()"><span class="label">${isElementHidden() ? 'Show' : 'Hide'} Element</span>`;
            if(Object.values(self.globalSettings.defaultElementFeatures).includes('hide-remove-element')) {
                content += `<span class="bricks-svg-wrapper action frontend${activeObj.settings.hasOwnProperty('unrenderFrontend') && activeObj.settings.unrenderFrontend === true ? ' active' : ''}" data-balloon="Remove on Frontend" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.removeElementFrontend();ADMINBRXC.openClassContextualMenu();">F</span>`;
                content += `<span class="bricks-svg-wrapper action builder${activeObj.settings.hasOwnProperty('hideElement') && activeObj.settings.hideElement === true ? ' active' : ''}" data-balloon="Hide in Builder" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.hideElementBuilder();ADMINBRXC.openClassContextualMenu();">B</span>`;
                content += `<span class="bricks-svg-wrapper action settings ${self.hideElementStates.active === true ? ' active' : ''}" data-balloon="Floating Bar" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.hideElementStates.active = !ADMINBRXC.hideElementStates.active;ADMINBRXC.setHideFloatingBar();ADMINBRXC.openClassContextualMenu();"><i class="fa-solid fa-ellipsis"></i></span>`;
            }
            content += `</li>`;
        
            content += `<li class="sep"></li>
                    <li onclick="ADMINBRXC.exportIDStylestoClass()">Export ID Styles to Class</li>
                    <li onclick="ADMINBRXC.openExtendClassModal(event,&quot;#brxcExtendModal&quot;)">Extend Classes &amp; Styles</li>
                    <li class="sep"></li>
                    <li onclick="ADMINBRXC.copyAllClasses()">Copy All Classes</li>
                    <li onclick="ADMINBRXC.pasteAllClasses()">Paste All Classes</li>
                    <li onclick="ADMINBRXC.mergeClasses()">Merge All Classes</li>
                    <li onclick="ADMINBRXC.resetAllClasses()"class="delete">Reset All Classes</li>
                    <li class="sep"></li>
                    <li onclick="ADMINBRXC.openClassManager(&quot;component&quot;);">Component Class Manager</li>`
            content += globalContent;
            content += `</ul>`;
        } else {
            content += `<ul>`
            content += `<li onclick="ADMINBRXC.hideElement()"><span class="label">${isElementHidden() ? 'Show' : 'Hide'} Element</span>`;
            if(Object.values(self.globalSettings.defaultElementFeatures).includes('hide-remove-element')) {
                content += `<span class="bricks-svg-wrapper action frontend${activeObj.settings.hasOwnProperty('unrenderFrontend') && activeObj.settings.unrenderFrontend === true ? ' active' : ''}" data-balloon="Remove on Frontend" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.removeElementFrontend();ADMINBRXC.openClassContextualMenu();">F</span>`;
                content += `<span class="bricks-svg-wrapper action builder${activeObj.settings.hasOwnProperty('hideElement') && activeObj.settings.hideElement === true ? ' active' : ''}"" data-balloon="Hide in Builder" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.hideElementBuilder();ADMINBRXC.openClassContextualMenu();">B</span>`;
            }
            content += `</li>`;
            content +=`<li class="sep"></li>
                    <li onclick="ADMINBRXC.importIDStylestoClass()">Import ID Styles to Class</li>
                    <li onclick="ADMINBRXC.openExtendClassModal(event,&quot;#brxcExtendModal&quot;)">Extend Classes &amp; Styles</li>
                    <li class="sep"></li>
                    <li onclick="ADMINBRXC.cloneClass()">Clone Class</li>
                    <li onclick="ADMINBRXC.copytoClipboardSimple('${self.vueState.activeClass.name}','${self.vueState.activeClass.name} successfully copied to clipboard')">Copy ${self.vueState.activeClass.name} to Clipboard</li>
                    <li onclick="ADMINBRXC.removeCurrentClass('${self.vueState.activeClass.id}', true)">Remove Class from Element</li>
                    <li onclick="ADMINBRXC.deleteCurrentClass('${self.vueState.activeClass.id}')"class="delete">${self.vueState.globalClassesTrash && Array.isArray(self.vueState.globalClassesTrash) ? 'Move Class to Trash' : 'Delete Class'}</li>
                    <li class="sep"></li>
                    <li onclick="ADMINBRXC.copyAllClasses()">Copy All Classes</li>
                    <li onclick="ADMINBRXC.pasteAllClasses()">Paste All Classes</li>
                    <li onclick="ADMINBRXC.mergeClasses()">Merge All Classes</li>
                    <li onclick="ADMINBRXC.resetAllClasses()"class="delete">Reset All Classes</li>
                    <li class="sep"></li>
                    <li onclick="ADMINBRXC.openClassInManager('${self.vueState.activeClass.id}')">
                        <span class="label">Open Class in Global Class Manager</span>
                        <span class="shortcut">${shortcutPrefix} + ${self.globalSettings.keyboardShortcuts.classManager}</span>
                    </li>
                    <li onclick="ADMINBRXC.openClassManager(&quot;component&quot;);">Component Class Manager</li>`
            content += globalContent;
            content += `</ul>`;

        }
        
        menuCanvas.innerHTML = content;
        const rect = icon.getBoundingClientRect();
        menu.style.top = `${rect.top}px`;
        menu.style.left = `${rect.left}px`;
        menu.classList.add('show');

        // Listeners
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        function openMenu() {
            window.addEventListener('click', windowClickListener);
            x.document.addEventListener('click', windowClickListener);
        }
        
        function closeMenu() {
            window.removeEventListener('click', windowClickListener);
            x.document.removeEventListener('click', windowClickListener);
            menu.classList.remove('show');

        }
        
        function windowClickListener(event) {
            closeMenu();
        }
        openMenu();
    },
    copiedAllClasses: null,
    copyAllClasses: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        if(!Array.isArray(elementObj.settings._cssGlobalClasses) || elementObj.settings._cssGlobalClasses.length < 1) return self.vueGlobalProp.$_showMessage('Abort - No Global Class found!');
        self.copiedAllClasses = elementObj.settings._cssGlobalClasses;
        self.vueGlobalProp.$_showMessage('Global Classes correctly copied!');
        self.vueState.rerenderControls = Date.now();
    },
    pasteAllClasses: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        if(!Array.isArray(self.copiedAllClasses)){
            return self.vueGlobalProp.$_showMessage('Abort - No Global Classes have been copied!');
        } 
        if(!Array.isArray(elementObj.settings._cssGlobalClasses)) elementObj.settings._cssGlobalClasses = [];
        elementObj.settings._cssGlobalClasses = [...new Set(elementObj.settings._cssGlobalClasses.concat(self.copiedAllClasses))];
        self.vueGlobalProp.$_showMessage('Global Classes correctly pasted!');
        self.vueState.rerenderControls = Date.now();
    },
    resetAllClasses: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        if(!Array.isArray(elementObj.settings._cssGlobalClasses || elementObj.settings._cssGlobalClasses < 1 )) return self.vueGlobalProp.$_showMessage('Abort - No Global Classes found!');
        delete elementObj.settings._cssGlobalClasses;
        self.vueGlobalProp.$_showMessage('Global Classes correctly removed!');
        self.vueState.rerenderControls = Date.now();
    },
    removeCurrentClass: function(id, message){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        const index = elementObj.settings._cssGlobalClasses.indexOf(id);
        elementObj.settings._cssGlobalClasses.splice(index, 1);
        message === true ? self.vueGlobalProp.$_showMessage('Global Class correctly removed!') : '';
        self.vueState.rerenderControls = Date.now();
    },
    deleteCurrentClass: function(id){
        const self = this;

        // Remove Class from all elements
        const content = self.helpers.getContent() || [];
        const filteredEls = Array.from(content).filter(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.includes(id));
        if(filteredEls && filteredEls.length > 0){
            filteredEls.forEach(element => {
                const index = element.settings._cssGlobalClasses.indexOf(id);
                element.settings._cssGlobalClasses.splice(index, 1);
            })
        }

        // Remove Global Class
        const activeClass = Array.from(self.vueState.globalClasses).find(el => el.id === id);
        if(!activeClass) return self.vueGlobalProp.$_showMessage('Abort - Global Class not found!');
        const index = self.vueState.globalClasses.indexOf(activeClass);
        self.vueState.globalClasses.splice(index,1);
        if(self.states.classManagerActiveClass === id) self.states.classManagerActiveClass = '';
        let showMessage = 'Global Class correctly deleted!';

        // Move to Trash
        if(self.vueState.globalClassesTrash && Array.isArray(self.vueState.globalClassesTrash)){
            activeClass.deletedAt = Date.now();
            activeClass.originalIndex = index;
            activeClass.user_id = bricksData.loadData.currentUserId;

            self.vueState.globalClassesTrash.push(activeClass);
            showMessage = 'Global Class correctly moved to trash!';
        }

        self.vueGlobalProp.$_showMessage(showMessage);
        self.vueState.rerenderControls = Date.now();
    },
    cloneClass: function(){
        const self = this;
        const els = document.querySelector('#bricks-panel-element-classes')
        if (!els) return;

        const wrapper = els.querySelector('.brxc-clone-class-wrapper')
        if(wrapper) return wrapper.remove();

        const activeClass = els.querySelector('.active-class');

        const inputHTML = `<div class="brxc-clone-class-wrapper"><input type="text" id="brxc-clone-class-input" size="999" autocomplete="off" spellcheck="false" placeholder="Type your class name here" value="${self.vueState.activeClass.name}-new"><span class="bricks-svg-wrapper create" data-balloon="Clone class (SHIFT + ENTER)" data-balloon-pos="left"><!--?xml version="1.0" encoding="UTF-8"?--><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M362.7,64h-256c-23.7,0 -42.7,19.2 -42.7,42.7v298.7c0,23.5 19,42.7 42.7,42.7h298.7c23.5,0 42.7,-19.2 42.7,-42.7v-256l-85.4,-85.4Zm-106.7,341.3c-35.4,0 -64,-28.6 -64,-64c0,-35.4 28.6,-64 64,-64c35.4,0 64,28.6 64,64c0,35.4 -28.6,64 -64,64Zm64,-213.3h-213.3v-85.3h213.3v85.3Z" fill="currentColor"></path></svg></span><span class="bricks-svg-wrapper cancel" data-balloon="Cancel" data-balloon-pos="left"><i class="fas fa-xmark"></i></span></span><div>`
        activeClass.insertAdjacentHTML('afterend', inputHTML);

        const newWrapper = els.querySelector('.brxc-clone-class-wrapper')
        const newInput = newWrapper.querySelector('#brxc-clone-class-input');
        if(!newInput) return;
        newInput.focus();
        newInput.setSelectionRange(newInput.value.length, newInput.value.length)

        self.autocomplete(newInput, self.vueState.globalClasses.map(el => el.name), false);
        const saveBtn = document.querySelector('.brxc-clone-class-wrapper .bricks-svg-wrapper.create')
        const cancelBtn = document.querySelector('.brxc-clone-class-wrapper .bricks-svg-wrapper.cancel')
        const elementObj = self.helpers.getFinalObject(true);

        function cloneClass(){
            // Create CSS Settings
            const newInputValue = self.helpers.formatForClasses(newInput.value);
            const oldSettings = self.vueState.activeClass.settings;
            const oldCat = (self.vueState.activeClass.hasOwnProperty('category')) ? self.vueState.activeClass.category : false;
            const newSettings = JSON.parse(JSON.stringify(oldSettings).replaceAll(self.vueState.activeClass.name,newInputValue));
            let isUnique = true;
            let idClass;

            const addClass = (id, message, newWrapper) =>{
                // Add class to the element
                if (typeof elementObj.settings !== "undefined" && elementObj.settings.hasOwnProperty('_cssGlobalClasses')) {
                    if (!elementObj.settings._cssGlobalClasses.includes(id)) elementObj.settings._cssGlobalClasses.push(id)
                } else {
                    elementObj.settings._cssGlobalClasses = [];
                    elementObj.settings._cssGlobalClasses.push(id);
                }


                newWrapper.remove();
                self.vueGlobalProp.$_showMessage(message);
            }

            // Check if class exists
            self.vueState.globalClasses.forEach(obj => {
                if (obj.name === newInputValue){
                    isUnique = false;
                    idClass = obj.id;
                } 
            })


            if(isUnique === false) {
                addClass(idClass, 'Aborted: the class already exists!', newWrapper)
                return;
            }

            // Generate unique ID
            idClass = self.vueGlobalProp.$_generateId()

            // Create the class object
            const newGlobalClass = {
                id: idClass,
                name: newInputValue,
                settings: newSettings,
            };
            if(oldCat) newGlobalClass.category = oldCat;

            self.vueState.globalClasses.push(newGlobalClass);
            addClass(idClass, 'Class Successfully Created!', newWrapper)
        }

        saveBtn.addEventListener("click", function() {
            if(newInput.value === ''){
                return self.vueGlobalProp.$_showMessage('Abort - No Class Name Given');
            }
            cloneClass()
        });

        cancelBtn.addEventListener("click", function() {
            newWrapper.remove();
        });

        newInput.addEventListener('keyup', function(event) {
            if (event.shiftKey && event.keyCode === 13) cloneClass();
        });
    },
    exportIDStylestoClass: function(type){
        const self = this;
        const els = document.querySelector('#bricks-panel-element-classes')
        if (!els) return;

        const wrapper = els.querySelector('.brxc-copy-id-to-class-wrapper')
        if(wrapper) return wrapper.remove();

        const activeClass = els.querySelector('.active-class');

        let inputHTML = `<div class="brxc-copy-id-to-class-wrapper"><input type="text" id="brxc-copy-id-to-class-input" size="999" autocomplete="off" spellcheck="false" placeholder="Type your class name here"><span class="bricks-svg-wrapper create" data-balloon="Create/Update (SHIFT + ENTER)" data-balloon-pos="left"><!--?xml version="1.0" encoding="UTF-8"?--><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M362.7,64h-256c-23.7,0 -42.7,19.2 -42.7,42.7v298.7c0,23.5 19,42.7 42.7,42.7h298.7c23.5,0 42.7,-19.2 42.7,-42.7v-256l-85.4,-85.4Zm-106.7,341.3c-35.4,0 -64,-28.6 -64,-64c0,-35.4 28.6,-64 64,-64c35.4,0 64,28.6 64,64c0,35.4 -28.6,64 -64,64Zm64,-213.3h-213.3v-85.3h213.3v85.3Z" fill="currentColor"></path></svg></span><span class="bricks-svg-wrapper cancel" data-balloon="Cancel" data-balloon-pos="left"><i class="fas fa-xmark"></i></span></span>`;
        if(typeof self.vueState.globalClassesCategories !== "undefined") inputHTML +=`<input type="text" id="brxc-copy-id-to-class-input-cat" size="999" autocomplete="off" spellcheck="false" placeholder="Type the class category here (optional)">`;
        inputHTML += `</div>`;
        activeClass.insertAdjacentHTML('afterend', inputHTML);

        const newWrapper = els.querySelector('.brxc-copy-id-to-class-wrapper')
        const newInput = newWrapper.querySelector('#brxc-copy-id-to-class-input');
        const newCategory = newWrapper.querySelector('#brxc-copy-id-to-class-input-cat');
        if(!newInput) return;
        newInput.focus();

        self.autocomplete(newInput, Array.from(self.vueState.globalClasses).map(el => el && el.name), false);
        if(newCategory) self.autocomplete(newCategory, self.states.classManagerCategories, false);
        const saveBtn = document.querySelector('.brxc-copy-id-to-class-wrapper .bricks-svg-wrapper.create');
        const cancelBtn = document.querySelector('.brxc-copy-id-to-class-wrapper .bricks-svg-wrapper.cancel');

        const elementObj = self.helpers.getFinalObject(true);

        function exportSettings(){
            // Create CSS Settings
            const settings = {};
            const excludedKeys = ['icon'];
            for (const [key, value] of Object.entries(elementObj.settings)){
                const prop = key.split(':')[0];

                if(['_cssCustom','_cssCustomSass'].includes(prop)){
                    const dot = self.helpers.isComponentActive() ? '.' : '#';
                    let id = typeof elementObj.settings !== "undefined" && elementObj.settings.hasOwnProperty('_cssId') ? `${dot}${elementObj.settings._cssId}` : `${dot}brxe-${elementObj.id}`;
                    settings[key] = value.replaceAll(id, '.' + self.helpers.formatForClasses(newInput.value))
                } else if (!excludedKeys.includes(prop) && self.helpers.isCSSControlKey(key)) {
                    // Object
                    if( typeof elementObj.settings[key] === "object"){
                        for (const [key1, value1] of Object.entries(elementObj.settings[key])){
                            if(!settings.hasOwnProperty(key)) settings[key] = {};
                            settings[key][key1] = JSON.parse(JSON.stringify(elementObj.settings[key][key1]));
                        }
                    // Sring
                    } else {
                        settings[key] = JSON.parse(JSON.stringify(value));
                    }
                }
            }
            let isLocked;
            let isUnique = true;
            let idClass;
            let category;
            if(newCategory && newCategory.value.length > 0) {
                const relatedCat = self.helpers.getClassCategoryIdByName(newCategory.value)
                if(relatedCat){
                    category = relatedCat;
                } else {
                    const catId = self.vueGlobalProp.$_generateId();
                    self.vueState.globalClassesCategories.push({
                        id: catId,
                        name: newCategory.value,
                    })
                    category = catId
                }
            } 

            const addClass = (id, message, newWrapper) =>{
                // Add class to the element
                if (typeof elementObj.settings !== "undefined" && elementObj.settings.hasOwnProperty('_cssGlobalClasses')) {
                    if (!elementObj.settings._cssGlobalClasses.includes(id)) elementObj.settings._cssGlobalClasses.push(id)
                } else {
                    elementObj.settings._cssGlobalClasses = [];
                    elementObj.settings._cssGlobalClasses.push(id);
                }

                // Remove styles on ID
                for (const [key, value] of Object.entries(settings)){
                    if (self.helpers.isCSSControlKey(key)) delete elementObj.settings[key];
                }

                newWrapper.remove();
                self.vueGlobalProp.$_showMessage(message);
            }

            // Check if class exists
            const targetClass = Array.from(self.vueState.globalClasses).find(el => el && el.hasOwnProperty('name') && el.name === self.helpers.formatForClasses(newInput.value));
            if(targetClass){
                isUnique = false;
                idClass = targetClass.id;
                isLocked = self.vueGlobalProp.$_isLocked(targetClass.id);
                if (!isLocked) for (const [key, value] of Object.entries(settings)){
                    //object
                    if(typeof settings[key] === "object"){
                        if(!targetClass.settings.hasOwnProperty(key)) targetClass.settings[key] = {};
                        for (const [key1, value1] of Object.entries(settings[key])){
                            if(!settings.hasOwnProperty(key)) settings[key] = {};
                            targetClass.settings[key][key1] = JSON.parse(JSON.stringify(settings[key][key1]));
                        }
                    } else {
                        //string
                        targetClass.settings[key] = value;
                    }
                }
            }

            if(isLocked === true){
                newWrapper.remove();
                self.vueGlobalProp.$_showMessage('Abort: the class is locked');
                return;
            }

            if(isUnique === false) {
                addClass(idClass, 'Class Successfully Updated!', newWrapper)
                self.vueState.activeClass = JSON.parse(JSON.stringify(self.vueGlobalProp.$_getGlobalClass(idClass)));
                return;
            }

            // Generate unique ID
            idClass = self.vueGlobalProp.$_generateId()


            // Create the class object
            const newGlobalClass = {
                id: idClass,
                name: self.helpers.formatForClasses(newInput.value),
                settings: settings,
            };
            if(category) newGlobalClass.category = category;

            self.vueState.globalClasses.push(newGlobalClass);
            self.vueState.activeClass = self.vueGlobalProp.$_getGlobalClass(idClass);
            self.vueState.rerenderControls = Date.now();
            addClass(idClass, 'Class Successfully Created!', newWrapper);
            self.helpers.saveChanges('globalClasses');
        }

        newInput.addEventListener('keyup', function(event) {
            if (event.shiftKey && event.keyCode === 13) exportSettings();
        });

        saveBtn.addEventListener('click', function(event) {
            if(newInput.value === ''){
                return self.vueGlobalProp.$_showMessage('Abort - No Class Name Given');
            }
            exportSettings()
        }); 
        cancelBtn.addEventListener('click', function(event) {
            newWrapper.remove();
        }); 
    },
    mergeClasses: function(){
        const self = this;
        const els = document.querySelector('#bricks-panel-element-classes')
        if (!els) return;

        const wrapper = els.querySelector('.brxc-copy-id-to-class-wrapper')
        if(wrapper) return wrapper.remove();

        const activeClass = els.querySelector('.active-class');

        let inputHTML = `<div class="brxc-copy-id-to-class-wrapper">
                            <input type="text" id="brxc-copy-id-to-class-input" size="999" autocomplete="off" spellcheck="false" placeholder="Type your class name here"><span class="bricks-svg-wrapper create" data-balloon="Create/Update (SHIFT + ENTER)" data-balloon-pos="left"><!--?xml version="1.0" encoding="UTF-8"?--><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M362.7,64h-256c-23.7,0 -42.7,19.2 -42.7,42.7v298.7c0,23.5 19,42.7 42.7,42.7h298.7c23.5,0 42.7,-19.2 42.7,-42.7v-256l-85.4,-85.4Zm-106.7,341.3c-35.4,0 -64,-28.6 -64,-64c0,-35.4 28.6,-64 64,-64c35.4,0 64,28.6 64,64c0,35.4 -28.6,64 -64,64Zm64,-213.3h-213.3v-85.3h213.3v85.3Z" fill="currentColor"></path></svg></span><span class="bricks-svg-wrapper cancel" data-balloon="Cancel" data-balloon-pos="left"><i class="fas fa-xmark"></i></span></span>`;
        if(typeof self.vueState.globalClassesCategories !== "undefined") inputHTML +=`<input type="text" id="brxc-copy-id-to-class-input-cat" size="999" autocomplete="off" spellcheck="false" placeholder="Type the class category here (optional)">`;
        inputHTML += `<div class="control control-checkbox">
                        <div class="control-inner control-inline control-small">
                            <label for="removeExistingClasses" data-balloon-break="">
                                <span>Remove existing classes from element?</span>
                            </label>
                            <div data-control="checkbox" type="checkbox" class="">
                                <input type="checkbox" id="removeExistingClasses" name="removeExistingClasses">
                            </div>
                        </div>
                    </div>
                    <div class="control control-checkbox">
                        <div class="control-inner control-inline control-small">
                            <label for="deleteExistingClasses" data-balloon-break="">
                                <span>Delete existing classes permanently?</span>
                            </label>
                            <div data-control="checkbox" type="checkbox" class="">
                                <input type="checkbox" id="deleteExistingClasses" name="deleteExistingClasses">
                            </div>
                        </div>
                    </div>`;
        inputHTML += `</div>`;
        activeClass.insertAdjacentHTML('afterend', inputHTML);

        const newWrapper = els.querySelector('.brxc-copy-id-to-class-wrapper')
        const newInput = newWrapper.querySelector('#brxc-copy-id-to-class-input');
        const newCategory = newWrapper.querySelector('#brxc-copy-id-to-class-input-cat');
        const removeClasses = newWrapper.querySelector('#removeExistingClasses');
        const deleteClasses = newWrapper.querySelector('#deleteExistingClasses');
        if(!newInput) return;
        newInput.focus();

        self.autocomplete(newInput, Array.from(self.vueState.globalClasses).map(el => el && el.name), false);
        if(newCategory) self.autocomplete(newCategory, self.states.classManagerCategories, false);
        const saveBtn = document.querySelector('.brxc-copy-id-to-class-wrapper .bricks-svg-wrapper.create');
        const cancelBtn = document.querySelector('.brxc-copy-id-to-class-wrapper .bricks-svg-wrapper.cancel');
        const elementObj = self.helpers.getFinalObject(true);

        function mergeSettings(){
            // Create CSS Settings
            const settings = {};
            const globalClasses = elementObj.settings._cssGlobalClasses;
            if(Array.isArray(globalClasses) && globalClasses.length > 0){
                globalClasses.forEach(globalClass => {
                    const globalClassObj = self.vueGlobalProp.$_getGlobalClass(globalClass);
                    if(!globalClassObj) return;

                    for (const [key, value] of Object.entries(globalClassObj.settings)){
                        if( key.startsWith('_cssCustom') || key.startsWith('_cssCustomSass')){
                            const initialValue = settings[key] || '';
                            settings[key] = `${initialValue}${initialValue === '' ? '' : '\n\n'}/* Custom CSS from .${globalClassObj.name} */\n${value.replaceAll(globalClassObj.name, '.' + self.helpers.formatForClasses(newInput.value))}`
                        } else if (self.helpers.isCSSControlKey(key)) {
                            // Object
                            if(typeof globalClassObj.settings[key] === "object"){
                                for (const [key1, value1] of Object.entries(globalClassObj.settings[key])){
                                    if(!settings.hasOwnProperty(key)) settings[key] = {};
                                    settings[key][key1] = JSON.parse(JSON.stringify(globalClassObj.settings[key][key1]));
                                }
                            // Sring
                            } else {
                                settings[key] = JSON.parse(JSON.stringify(value));
                            }
                        }
                    }

                })
            }
            let isLocked;
            let isUnique = true;
            let idClass;
            let category;
            if(newCategory && newCategory.value.length > 0) {
                const relatedCat = self.helpers.getClassCategoryIdByName(newCategory.value)
                if(relatedCat){
                    category = relatedCat;
                } else {
                    const catId = self.vueGlobalProp.$_generateId();
                    self.vueState.globalClassesCategories.push({
                        id: catId,
                        name: newCategory.value,
                    })
                    category = catId
                }
            } 

            const addClass = (id, message, newWrapper) =>{
                // Add class to the element
                if (typeof elementObj.settings !== "undefined" && elementObj.settings.hasOwnProperty('_cssGlobalClasses')) {
                    if (!elementObj.settings._cssGlobalClasses.includes(id)) elementObj.settings._cssGlobalClasses.push(id)
                } else {
                    elementObj.settings._cssGlobalClasses = [];
                    elementObj.settings._cssGlobalClasses.push(id);
                }

                // Remove styles on ID
                for (const [key, value] of Object.entries(elementObj.settings)){
                    if (self.helpers.isCSSControlKey(key)) delete elementObj.settings[key];
                }

                newWrapper.remove();
                self.vueGlobalProp.$_showMessage(message);
            }

            // Check if class exists
            const targetClass = Array.from(self.vueState.globalClasses).find(el => el && el.hasOwnProperty('name') && el.name === self.helpers.formatForClasses(newInput.value));
            if(targetClass){
                isUnique = false;
                idClass = targetClass.id;
                isLocked = self.vueGlobalProp.$_isLocked(targetClass.id);
                if (!isLocked) for (const [key, value] of Object.entries(settings)){
                    //object
                    if(typeof settings[key] === "object"){
                        if(!targetClass.settings.hasOwnProperty(key)) targetClass.settings[key] = {};
                        for (const [key1, value1] of Object.entries(settings[key])){
                            if(!settings.hasOwnProperty(key)) settings[key] = {};
                            targetClass.settings[key][key1] = JSON.parse(JSON.stringify(settings[key][key1]));
                        }
                    } else {
                        //string
                        targetClass.settings[key] = value;
                    }
                }
            }

            if(isLocked === true){
                newWrapper.remove();
                self.vueGlobalProp.$_showMessage('Abort: the class is locked');
                return;
            }

            if(isUnique === false) {
                addClass(idClass, 'Class Successfully Created!', newWrapper)
                self.vueState.activeClass = JSON.parse(JSON.stringify(self.vueGlobalProp.$_getGlobalClass(idClass)));
                return;
            }

            // Generate unique ID
            idClass = self.vueGlobalProp.$_generateId()


            // Create the class object
            const newGlobalClass = {
                id: idClass,
                name: self.helpers.formatForClasses(newInput.value),
                settings: settings,
            };
            if(category) newGlobalClass.category = category;

            if(deleteClasses.checked === true){
                elementObj.settings._cssGlobalClasses.forEach(el => {
                    self.vueState.globalClasses = self.vueState.globalClasses.filter(el2 => el2 && el2.hasOwnProperty('id') && !elementObj.settings._cssGlobalClasses.includes(el2.id))
                    elementObj.settings._cssGlobalClasses = [];
                });
            } else if(removeClasses.checked === true){
                elementObj.settings._cssGlobalClasses = [];
            }
            setTimeout(() => {
                self.vueState.globalClasses.push(newGlobalClass);
                addClass(idClass, 'Class Successfully Created!', newWrapper);
                self.vueState.activeClass = newGlobalClass;
                self.vueState.rerenderControls = Date.now();
                self.helpers.saveChanges('globalClasses');
            },5)
        }

        newInput.addEventListener('keyup', function(event) {
            if (event.shiftKey && event.keyCode === 13) mergeSettings();
        });

        saveBtn.addEventListener('click', function(event) {
            if(newInput.value === ''){
                return self.vueGlobalProp.$_showMessage('Abort - No Class Name Given');
            }
            mergeSettings()
        }); 
        cancelBtn.addEventListener('click', function(event) {
            newWrapper.remove();
        });
    },
    importIDStylestoClass: function(){
        const self = this;
        
        const activeClass = Array.from(self.vueState.globalClasses).find(el => el && el.hasOwnProperty('id') && el.id === self.vueState.activeClass.id);
        const elementObj = self.helpers.getFinalObject(true);

        // Create CSS Settings
        const settings = {};
        for (const [key, value] of Object.entries(elementObj.settings)){

            if( key.startsWith('_cssCustom') ){
                const dot = self.helpers.isComponentActive() ? '.' : '#';
                let id = typeof elementObj.settings !== "undefined" && elementObj.settings.hasOwnProperty('_cssId') ? `${dot}${elementObj.settings._cssId}` : `${dot}brxe-${elementObj.id}`;
                settings[key] = JSON.parse(JSON.stringify(value.replaceAll(id, '.' + activeClass.name)));
            } else if (self.helpers.isCSSControlKey(key)) {
                // Object
                if(typeof elementObj.settings[key] === "object"){
                    for (const [key1, value1] of Object.entries(elementObj.settings[key])){
                        if(!settings.hasOwnProperty(key)) settings[key] = {};
                        settings[key][key1] = JSON.parse(JSON.stringify(elementObj.settings[key][key1]));
                    }
                // Sring
                } else {
                    settings[key] = JSON.parse(JSON.stringify(value));
                }
            }

            
        }

        const addClass = (message) =>{

            // Import Styles from ID
            for (const [key, value] of Object.entries(settings)){


                //object
                if(typeof settings[key] === "object"){
                    for (const [key1, value1] of Object.entries(settings[key])){
                        if(!activeClass.settings.hasOwnProperty(key)) activeClass.settings[key] = {};
                        activeClass.settings[key][key1] = JSON.parse(JSON.stringify(settings[key][key1]));
                    }
                } else {
                    //string
                    activeClass.settings[key] = value;
                }
                delete elementObj.settings[key]
            }

            self.vueGlobalProp.$_showMessage(message);
        }

        addClass('Styles Successfully Imported to the Class!');
        self.vueState.activeClass = JSON.parse(JSON.stringify(activeClass));
        self.vueState.rerenderControls = Date.now();
        //self.helpers.saveChanges('globalClasses');



    },
    setVariableAutocomplete: function() {
        const self = this;
        setTimeout(() => {
            self.fields['CSSVariabe']['includedFields'].forEach(field => {
                let elements;
                if (typeof field === 'string') {
                    elements = Array.from(document.querySelectorAll(field));
                } else {
                    // Get elements with the selector
                    const filteredElements = Array.from(document.querySelectorAll(field.selector));
    
                    // Check if they have any of the specified child elements
                    elements = filteredElements.filter(el =>
                        el && field.hasChild.some(child => child && el.querySelector(child))
                    );
                }
    
                const wrappers = elements.filter(
                    item => item &&
                        !item.parentNode.closest(self.fields['CSSVariabe']['excludedFields']) &&
                        !item.classList.contains('autocomplete-active')
                );
                if (wrappers.length < 1) return;
                wrappers.forEach(wrapper => {
                    wrapper.classList.add('autocomplete-active');
                    const input = wrapper.querySelector("input[type='text']");
                    input.addEventListener('focus', () => {
                        self.populateCSSVariables();
                        self.autocomplete(input, self.cssVariables, "style");
                    });
                });
            });
        }, 100);
    },
    setActiveStyleTabs: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        let panelGroup = self.vueState.activePanelGroup;

        const elementObj = self.helpers.getFinalObject(true);

        if(self.vueState.activePanelTab === "content" && panelGroup && panelGroup !== '' && bricksData.elements[elementObj.name]?.controlGroups[panelGroup]?.tab === "style") {
            self.vueState.activePanelGroup = '';
        }
    },
    setBorderAndBoxShadow: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        const els = x.document.querySelectorAll('.has-border-settings');
        if(els && els.length > 0) els.forEach(el => el.classList.remove('has-border-settings'))

        if(self.vueState.activePanelGroup !== "_border") return;

        const elementObj = self.helpers.getFinalObject(true);
        const activeEl = FRAMEBRXC.vueGlobalProp.$_getElementNode(elementObj);
        if(!activeEl) return;
        
        activeEl.classList.add('has-border-settings');
    },
    openAvancedCSSModal: function(){
        const self = this;
        self.advancedCSSInit();
        
        self.openModal(false, "#brxcCSSOverlay");
    },
    initToolbar: function(){
        const self = this;
        const leftToolbar = document.querySelector('#bricks-toolbar ul.group-wrapper.left');
        const rightToolbar = document.querySelector('#bricks-toolbar ul.group-wrapper.right');
        const middleToolbar = document.querySelector('#bricks-toolbar ul.group-wrapper.breakpoints');
        let elements;
        let structure;
        let dimensions;
        let dimensionsWidth;
        if (leftToolbar){
            elements = leftToolbar.querySelector('.elements');
        }
        if (middleToolbar){
            dimensionsWidth = middleToolbar.querySelector('.preview-dimension.width');
            dimensions = middleToolbar.querySelectorAll('.preview-dimension')[2];
        }

        if (rightToolbar){
            structure = rightToolbar.querySelector('.structure');
        }
        // Builder Tweaks - Global Features
        if (self.helpers.isBuilderTweaksTabActive('global-features') ){
            if (Object.values(self.globalSettings.topbarShortcuts).includes('grid-guides')) {
                self.addMenuItemtoToolbar('grid-guide', 'Grid Guides (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.gridGuides + ')', 'bottom', 'ADMINBRXC.generateGridGuideCSS();ADMINBRXC.gridGuide(this);', '<i class="bricks-svg ti-layout-grid4-alt" style="opacity: .75;"></i>', leftToolbar,  elements);
                self.addMenuItemtoToolbar('grid-guide-options', 'Grid Guides options', 'bottom', 'ADMINBRXC.setGridGuideOptions(this)', '<svg version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg" style="rotate: 90deg;"><path d="M3,9.5l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Zm5,0l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Zm5,0l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Z" fill="currentColor" fill-rule="evenodd"></path></svg>', leftToolbar,  elements);
            }
            Object.values(self.globalSettings.topbarShortcuts).includes('x-mode') ? self.addMenuItemtoToolbar('x-mode', 'X-Mode (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.xMode + ')', 'bottom', 'ADMINBRXC.XCode(this)', '<i class="bricks-svg fas fa-border-top-left" style="opacity: .75;"></i>', leftToolbar, elements) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes('contrast-checker') ? self.addMenuItemtoToolbar('constrast', 'Contrast Checker (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.contrastChecker + ')', 'bottom', 'ADMINBRXC.contrast(this)', '<i class="bricks-svg ion-ios-contrast" style="opacity: .75;"></i>', leftToolbar, elements) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes('darkmode') ? self.addMenuItemtoToolbar('darkmode', 'Darkmode (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.darkmode + ')', 'bottom', 'ADMINBRXC.darkMode(this)', '<i class="bricks-svg fas fa-moon" style="opacity: .75;"></i>', leftToolbar, elements) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes('class-manager') ? self.addMenuItemtoToolbar('class-manager', 'Class Manager (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.classManager + ')', 'bottom', 'ADMINBRXC.openClassManager("global");', '<i class="bricks-svg ion-md-options" style="opacity: .75;"></i>', leftToolbar, elements) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes('global-query') ? self.addMenuItemtoToolbar('query-manager', 'Query Manager (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.darkmode + ')', 'bottom', 'ADMINBRXC.queryManagerInit();ADMINBRXC.openModal(false,"#brxcQueryManagerOverlay");', '<i class="bricks-svg fas fa-infinity" style="opacity: .75;"></i>', leftToolbar, elements) : '';
            Object.values(self.globalSettings.globalFeatures).includes('responsive-helper') ? self.addMenuItemtoToolbar('responsive-helper', 'Responsive Helper', 'bottom', 'ADMINBRXC.setResponsiveHelper(this)', '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" class="bricks-svg"><g id="vertical-menu--navigation-vertical-three-circle-button-menu-dots"><path id="Vector" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 3.5c0.82843 0 1.5 -0.67157 1.5 -1.5S7.82843 0.5 7 0.5 5.5 1.17157 5.5 2 6.17157 3.5 7 3.5Z" stroke-width="1"></path><path id="Vector_2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 8.5c0.82843 0 1.5 -0.67157 1.5 -1.5S7.82843 5.5 7 5.5 5.5 6.17157 5.5 7 6.17157 8.5 7 8.5Z" stroke-width="1"></path><path id="Vector_3" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 13.5c0.82843 0 1.5 -0.6716 1.5 -1.5s-0.67157 -1.5 -1.5 -1.5 -1.5 0.6716 -1.5 1.5 0.67157 1.5 1.5 1.5Z" stroke-width="1"></path></g></svg>', middleToolbar,  dimensionsWidth) : '';
            Object.values(self.globalSettings.globalFeatures).includes('zoom-out') ? self.addMenuItemtoToolbar('zoom-out', 'Zoom-out', 'bottom', 'ADMINBRXC.zoomOut();', '<i class="bricks-svg ti-zoom-out" style="opacity: .75;"></i>', middleToolbar, dimensions, 'after') : '';
            Object.values(self.globalSettings.topbarShortcuts).includes('advanced-css') ? self.addMenuItemtoToolbar('custom-css', 'Advanced CSS (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.cssStylesheets + ')', 'bottom', `ADMINBRXC.openAvancedCSSModal();`, '<i class="bricks-svg fas fa-code" style="opacity: .75;"></i>', leftToolbar, elements) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes('openai') ? self.addMenuItemtoToolbar('openai', 'OpenAI Assistant (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.openai + ')', 'bottom', 'ADMINBRXC.openModal(false, "#brxcGlobalOpenAIOverlay")', '<i class="bricks-svg fas fa-robot" style="opacity: .75;"></i>', rightToolbar, structure) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes('variable-manager') ? self.addMenuItemtoToolbar('CSSVariableManager', 'CSS Variable Manager (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.variableManager + ')', 'bottom', 'ADMINBRXC.openModal(false, "#brxcCSSVariableManagerOverlay");ADMINBRXC.setCSSVariableManager();', '<i class="bricks-svg fas fa-square-root-variable" style="opacity: .75;"></i>', rightToolbar, structure) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes("color-manager") ? self.addMenuItemtoToolbar('colorManager', 'Color Manager (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.colorManager + ')', 'bottom', 'ADMINBRXC.openModal(false, "#brxcColorManagerOverlay");ADMINBRXC.setColorManager();', '<i class="bricks-svg fas fa-palette" style="opacity: .75;"></i>', rightToolbar, structure) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes("resources") ? self.addMenuItemtoToolbar('resources', 'Resources (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.resources + ')', 'bottom', 'ADMINBRXC.openModal(false, "#brxcResourcesOverlay", false, false)', '<i class="bricks-svg fas fa-images" style="opacity: .75;"></i>', rightToolbar, structure) : '';
            Object.values(self.globalSettings.topbarShortcuts).includes("brickslabs") ? self.addMenuItemtoToolbar('openai', 'BricksLabs (ctrl+cmd+' + self.globalSettings.keyboardShortcuts.brickslabs + ')', 'bottom', 'ADMINBRXC.bricksLabsAPI(false, false, true);ADMINBRXC.openModal(false, "#brxcBricksLabsOverlay")', '<i class="bricks-svg fas fa-flask" style="opacity: .75;"></i>', rightToolbar, structure) : '';
        }



        // Main Menu
        Object.values(self.globalSettings.topbarShortcuts).includes('main-menu') ? self.addMenuItemtoToolbar('main-at-menu', 'AT Main Menu', 'bottom', 'event.stopPropagation();ADMINBRXC.openMainMenu(this, true);', '<i style="opacity:.75""><span class="brxc-AT-menu-icon">AT</span></i>', leftToolbar, elements) : '';
    },
    buildMainMenu: function(){
        const self = this;
        const menuIcon = document.querySelector('li.main-at-menu');
        if(!menuIcon) return;
        menuIcon.classList.add('active')
        const menuIconPos = menuIcon.getBoundingClientRect();
        const shortcut = self.vueState.isMac ? 'CTRL + CMD' : 'CTRL + SHIFT';

        let menu = document.createElement('div');
        menu.id = 'brxc-main-at-menu';
        menu.classList.add('show');
        menu.style.left = `${menuIconPos.left}px`;
        let content = "";
        content += `<ul>
                        <div class="brxc-main-menu__block">
                            <div class="title">Managers</div>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.openClassManager('global');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg ion-md-options" style="opacity: .75;"></i></span>
                                <span class="label">Global Class Manager</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.classManager}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.openModal(false, '#brxcColorManagerOverlay');ADMINBRXC.setColorManager();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-palette" style="opacity: .75;"></i></span>
                                <span class="label">Color Manager</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.colorManager}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.queryManagerInit();ADMINBRXC.openModal(false,'#brxcQueryManagerOverlay');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-infinity" style="opacity: .75;"></i></span>
                                <span class="label">Query Loop Manager</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.queryLoopManager}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.openModal(false, '#brxcCSSVariableManagerOverlay');ADMINBRXC.setCSSVariableManager();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-square-root-variable" style="opacity: .75;"></i></span>
                                <span class="label">Variable Manager</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.variableManager}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.setCustomComponents();ADMINBRXC.openModal(false, '#brxcCustomComponentsOverlay');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-address-card" style="opacity: .75;"></i></span>
                                <span class="label">Nested Elements Library</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.nestedElemenets}</span>
                                </div>
                            </li>
                        </div>
                        <div class="brxc-main-menu__block">
                            <div class="title">Styles & CSS</div>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.openAvancedCSSModal();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-code" style="opacity: .75;"></i></span>
                                <span class="label">Advanced CSS</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.cssStylesheets}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.openFindReplaceModal(event,true, '#brxcFindReplaceModal');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-magnifying-glass" style="opacity: .75;"></i></span>
                                <span class="label">Find & Replace (Global)</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.findAndReplace}</span>
                                </div>
                            </li>
                        </div>
                        <div class="brxc-main-menu__block">
                            <div class="title">Structure Panel</div>
                            <li onclick="ADMINBRXC.setStructureHelper();ADMINBRXC.openModal(false, '#brxcStructureHelper');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-circle-question" style="opacity: .75;"></i></span>
                                <span class="label">Structure Helper</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.structureHelper}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.codepenImporterInit();ADMINBRXC.openModal(false, '#brxcCodePenImporter');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fab fa-codepen" style="opacity: .75;"></i></span>
                                <span class="label">Codepen Converter</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.codepenConverter}</span>
                                </div>
                            </li>
                        </div>
                        <div class="brxc-main-menu__block">
                            <div class="title">Templates</div>
                            <li onclick="ADMINBRXC.openRemoteTemplatesModal()">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg ti-layout" style="opacity: .75;"></i></span>
                                <span class="label">Quick Remote Templates</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.remoteTemplate}</span>
                                </div>
                            </li>
                        </div>
                        <div class="brxc-main-menu__block">
                            <div class="title">OPENAI</div>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.openModal(false, '#brxcGlobalOpenAIOverlay')">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-robot" style="opacity: .75;"></i></span>
                                <span class="label">OpenAI Assistant</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.openai}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.promptManagerInit();ADMINBRXC.openModal(false,'#brxcPromptManagerOverlay');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-bookmark" style="opacity: .75;"></i></span>
                                <span class="label">Prompt Manager</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.promptManager}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.generatedAIStructureInit();ADMINBRXC.openModal(false, '#brxcGenerateAIStructureOverlay');">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-bars-staggered" style="opacity: .75;"></i></span>
                                <span class="label">Generate Structure with AI</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.generateAIStructure}</span>
                                </div>
                            </li>
                        </div>
                        <div class="brxc-main-menu__block">
                            <div class="title">Extra</div>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.openQuickSearch()">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-magnifying-glass" style="opacity: .75;"></i></span>
                                <span class="label">Quick Search</span>
                                <div class="action">
                                    <span class="shortcut">${self.vueState.isMac ? 'CMD' : 'CTRL'} + ${self.globalSettings.keyboardShortcuts.quickSearch}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.openModal(false, '#brxcResourcesOverlay', false, false)">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-images" style="opacity: .75;"></i></span>
                                <span class="label">Resources Panel</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.resources}</span>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.bricksLabsAPI(false, false, true);ADMINBRXC.openModal(false, '#brxcBricksLabsOverlay')">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-flask" style="opacity: .75;"></i></span>
                                <span class="label">BricksLabs Center</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.brickslabs}</span>
                                </div>
                            </li>
                        </div>
                    </ul>
                    <ul>
                        <div class="brxc-main-menu__block">
                            <div class="title">Builder Tweaks</div>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.generateGridGuideCSS();ADMINBRXC.gridGuide();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg ti-layout-grid4-alt" style="opacity: .75;"></i></span>
                                <span class="label">Grid Guides</span>
                                <div class="settings" data-balloon="Settings" data-balloon-pos="right" onclick="event.stopPropagation();ADMINBRXC.closeMainMenu();ADMINBRXC.setGridGuideOptions(this);"><i class="fas fa-gear"></i></div>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.gridGuides}</span>
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.generateGridGuideCSS();ADMINBRXC.gridGuide();ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.gridGuideActive === true? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.XCode();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-border-top-left" style="opacity: .75;"></i></span>
                                <span class="label">X-mode</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.xMode}</span>
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.XCode();ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.xCodeActive === true? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.contrast();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg ion-ios-contrast" style="opacity: .75;"></i></span>
                                <span class="label">Contrast Checker</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.contrastChecker}</span>
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.contrast();ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.contrastActive === true? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.darkMode();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-moon" style="opacity: .75;"></i></span>
                                <span class="label">Darkmode</span>
                                <div class="action">
                                    <span class="shortcut">${shortcut} + ${self.globalSettings.keyboardShortcuts.darkmode}</span>
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.darkMode();ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.darkmodeActive === true? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                        </div>
                        <div class="brxc-main-menu__block">
                            <div class="title">Strict Editor View</div>
                            <li onclick="ADMINBRXC.closeMainMenu();${self.strictEditorState !== true ? 'ADMINBRXC.strictEditorState = true;' : 'ADMINBRXC.strictEditorState = false;'}ADMINBRXC.vueState.rerenderControls = Date.now();">
                                <span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-unlock-keyhole" style="opacity: .75;"></i></span>
                                <span class="label">Strict Editor Settings</span>
                                <div class="action">
                                    <span class="save"><span class="bricks-svg-wrapper" data-balloon="Save Settings" data-balloon-pos="top" onclick="ADMINBRXC.saveFullAccessOptions()"><i class="fas fa-floppy-disk"></i></span></span>
                                    <div class="toggle" onclick="event.stopPropagation();${self.strictEditorState !== true ? 'ADMINBRXC.strictEditorState = true;' : 'ADMINBRXC.strictEditorState = false;'}ADMINBRXC.setStrictEditorView();ADMINBRXC.openMainMenu();"><i class="fas fa-toggle-${self.strictEditorState === true? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                        </div>
                        <div class="brxc-main-menu__block">
                            <div class="title">Quick Edits</div>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'disable-id-styles', 'data-disable-styles');">
                                <span class="label">Lock ID Styles</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'disable-id-styles', 'data-disable-styles');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.classFeatures.includes('disable-id-styles') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'focus-on-first-class');">
                                <span class="label">Focus on First Unlocked Class</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'focus-on-first-class');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.classFeatures.includes('focus-on-first-class') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'autoformat-field-values');">
                                <span class="label">Autoformat Control Values</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'autoformat-field-values');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.classFeatures.includes('autoformat-field-values') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'highlight-classes');">
                                <span class="label">Highlight Classes</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'highlight-classes');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.classFeatures.includes('highlight-classes') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'autocomplete-variable');">
                                <span class="label">Suggestions Dropdown for CSS Variables</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'autocomplete-variable');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.classFeatures.includes('autocomplete-variable') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'sync-label');">
                                <span class="label">Sync Element's Label with the First Global Class Name</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.classFeatures, 'sync-label');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.classFeatures.includes('sync-label') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementFeatures, 'superpower-custom-css', 'data-superpower-css');">
                                <span class="label">SuperPowerCSS</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementFeatures, 'superpower-custom-css', 'data-superpower-css');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.elementFeatures.includes('superpower-custom-css') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementFeatures, 'dynamic-data-modal', 'data-dynamic-data-modal');">
                                <span class="label">Dynamic Data Modal</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementFeatures, 'dynamic-data-modal', 'data-dynamic-data-modal');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.elementFeatures.includes('dynamic-data-modal') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementFeatures, 'disable-borders-boxshadows');">
                                <span class="label">Disable Borders & Box-shadow Outlines</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementFeatures, 'disable-borders-boxshadows');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.elementFeatures.includes('disable-borders-boxshadows') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.structurePanelGeneralTweaks, 'new-element-shortcuts');">
                                <span class="label">Right Shortcuts for Creating New Elements</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.structurePanelGeneralTweaks, 'new-element-shortcuts');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.structurePanelGeneralTweaks.includes('new-element-shortcuts') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementShortcutIcons, 'tabs-shortcuts', 'data-has-panel-shortcuts');">
                                <span class="label">Left Tabs Shortcuts</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.elementShortcutIcons, 'tabs-shortcuts', 'data-has-panel-shortcuts');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.elementShortcutIcons.includes('tabs-shortcuts') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                            <li onclick="ADMINBRXC.closeMainMenu();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.structurePanelGeneralTweaks, 'styles-and-classes-indicators');">
                                <span class="label">Style Indicators in Structure Panel</span>
                                <div class="action">
                                    <div class="toggle" onclick="event.stopPropagation();ADMINBRXC.toggleQuickEditOption(ADMINBRXC.globalSettings.structurePanelGeneralTweaks, 'styles-and-classes-indicators');ADMINBRXC.openMainMenu(false, false);"><i class="fas fa-toggle-${self.globalSettings.structurePanelGeneralTweaks.includes('styles-and-classes-indicators') ? 'on' : 'off'}"></i></div>
                                </div>
                            </li>
                        </div>
                    </ul>`;

        menu.innerHTML = content;
        document.body.appendChild(menu);
    },
    toggleQuickEditOption: function(arr,value, attr = false){
        const self = this;
        if(arr.includes(value)){
            const index = arr.indexOf(value);
            arr.splice(index,1);
            if(attr) document.body.removeAttribute(attr);
            switch(value){
                case 'disable-id-styles':
                    const icon = document.querySelector('.disabled-style-icon');
                    if(icon) icon.remove();
                case 'highlight-classes':
                    const items = document.querySelectorAll('.structure-item.brxc-active-class');
                    const iframeItems = FRAMEBRXC.content.body.querySelectorAll('.brxc-active-class');
                    if(items && items.length > 0){
                        items.forEach(el => el.classList.remove('brxc-active-class'));
                    }
                    if(iframeItems && iframeItems.length > 0){
                        iframeItems.forEach(el => el.classList.remove('brxc-active-class'));
                    }
                case 'disable-borders-boxshadows':
                    const iframeBorderItems = FRAMEBRXC.content.body.querySelectorAll('.is-active-element.has-border-settings');
                    if(iframeBorderItems && iframeBorderItems.length > 0){
                        iframeBorderItems.forEach(el => el.classList.remove('has-border-settings'));
                    }
                case 'new-element-shortcuts':
                    self.setRightShortcutCol();
                case 'tabs-shortcuts':
                    const leftTab = document.querySelector('#bricks-panel-element .brxce-panel-shortcut__wrapper');
                    if(leftTab) leftTab.remove();
                case 'styles-and-classes-indicators':
                    const styledItems = document.querySelectorAll('#bricks-structure [data-has-styles="true"], #bricks-structure [data-has-classes="true"]')
                    if(styledItems && styledItems.length > 0){
                        styledItems.forEach(el => {
                            el.removeAttribute('data-has-styles');
                            el.removeAttribute('data-has-classes');
                        })
                    }
                default:
                    // silence
            }
        } else {
            arr.push(value);
            if(attr) document.body.setAttribute(attr, 'true');
            switch(value){
                case 'new-element-shortcuts':
                    self.setRightShortcutCol();
                default:
                    // silence
            }
        }
        self.vueState.rerenderControls = Date.now();
    },
    openMainMenu: function(target, close = true){
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        const existingMenu = document.querySelector('#brxc-main-at-menu');
        if(existingMenu){
            existingMenu.remove();
            if(close === true){
                if(target) target.classList.remove('active');
                return;
            }
        }
        function openMenu() {
            window.addEventListener('click', menuClickListener);
            x.document.addEventListener('click', menuClickListener);
            self.buildMainMenu();
        }
        
        function closeMenu() {
            window.removeEventListener('click', menuClickListener);
            x.document.removeEventListener('click', menuClickListener);
            self.closeMainMenu();
        }
        
        function menuClickListener(event) {
            closeMenu();
        }
        openMenu();
    },
    closeMainMenu: function(){
        const existingMenu = document.querySelector('#brxc-main-at-menu');
        if(existingMenu) existingMenu.remove();
        const menuIcon = document.querySelector('li.main-at-menu');
        if(!menuIcon) return;
        menuIcon.classList.remove('active')
    },
    // CSS Variable Manager
    cssVariablesStates:{
        activeCategory: 'all',
        renameCategory: false,
        addCategory: false,
        importGlobalVariables: false,
        importThemeVariables: false,
        search: '',
        showGlobal: true,
        showTheme: true,
        generatedCSSTheme: false,
        view: 'full',
        onDrag: false,
        skipValues: false,
    },
    generateBuilderCSS: function(){
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        var stylesheet1 = x.document.querySelector(':root');
        var stylesheet2 = document.querySelector(':root');

        let css = '';
        if(self.colorStates.generatedCSS) css += self.colorStates.generatedCSS;
        if(self.helpers.isCSSVariablesTabActive('theme-variables') && self.cssVariablesStates.generatedCSSTheme) css += self.cssVariablesStates.generatedCSSTheme;
        [stylesheet1,stylesheet2].forEach(root => {
            root.removeAttribute('style');
            root.style = css;
        }) 
    },
    generateVariableCSS: function() {
        const self = this;
        if(!self.helpers.isCSSVariablesTabActive('theme-variables')) return;

        const theme = self.vueState.themeStyleSettings;
        if(!theme) return;

        const general = theme.hasOwnProperty('general') ? theme.general : false;
        if(!general) return;


        const vars = general.hasOwnProperty('_cssVariables') ? general._cssVariables : false;
        if(!vars || !Array.isArray(vars) || vars.length < 1) return;

        const css = vars
            .filter(variable => variable.hasOwnProperty('name') && variable.hasOwnProperty('value'))
            .map(variable => `--${variable.name}:${variable.value};`)
            .join('');

        self.cssVariablesStates.generatedCSSTheme = css;

    },
    setCSSVariableManager: function(){
        const self = this;
        self.setCSSVariableManagerHeader();
        self.setCSSVariableManagerSearch();
        self.setCSSVariableManagerBody();
    },
    setCSSVariableManagerHeader: function(){
        const self = this;
        self.cssVariablesStates.view === "sidebar" ? self.setCSSVariableManagerHeaderSidebar() : self.setCSSVariableManagerHeaderFull();
    },
    setCSSVariableManagerHeaderSidebar: function(){
        const self = this;
        let content = '';
        content += `<div class="brxc-select">`;
        
        // set default active category
        if(self.cssVariablesStates.activeCategory === false && self.vueState.globalVariablesCategoriesSelected.length === 0){
            self.cssVariablesStates.activeCategory = 'all';
        }
        
        
        if(self.cssVariablesStates.renameCategory === false && self.cssVariablesStates.addCategory === false && self.cssVariablesStates.activeCategory){
            const categories = [{'id': 'all', 'name': 'All'},{'id': 'uncategorized', 'name': 'Uncategorized'}].concat(self.vueState.globalVariablesCategories);
            const uneditableCategories = ['all', 'uncategorized'];
            content += `<select name="brxc-cssVariablesOptions" id="cssVariablesOptions" class="brxc-cssVariablesOptions" value="${self.cssVariablesStates.activeCategory}" onChange="ADMINBRXC.cssVariablesStates.search = '';ADMINBRXC.cssVariablesStates.activeCategory = this.value;ADMINBRXC.setCSSVariableManager();">`;
            categories.forEach(cat => {
                content += `<option value="${cat.id}"${cat.id === self.cssVariablesStates.activeCategory ? ' selected="selected"' : ''}>${cat.name}</option>`;
            })
            content += `</select>`;
            content += '<div class="brxc-icon-container">'
            content += !uneditableCategories.includes(self.cssVariablesStates.activeCategory) ? `<div class="brxc-icon" data-balloon="Rename Category" data-balloon-pos="bottom-right" onClick="ADMINBRXC.cssVariablesStates.renameCategory = true;ADMINBRXC.setCSSVariableManagerHeader()"><span class="bricks-svg-wrapper"><i class="fas fa-pen"></i></span></div>` : '';
            content += `<div class="brxc-icon" data-balloon="Add New Category" data-balloon-pos="bottom-right" onClick="ADMINBRXC.cssVariablesStates.addCategory = true;ADMINBRXC.setCSSVariableManagerHeader()"><span class="bricks-svg-wrapper"><i class="fas fa-plus"></i></span></div>`;
            content += !uneditableCategories.includes(self.cssVariablesStates.activeCategory) ? `<div class="brxc-icon" data-balloon="Delete Category" data-balloon-pos="bottom-right" onClick="ADMINBRXC.setDeleteVariable(this, 'ADMINBRXC.deleteVariableCategory()');"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>` : '';
            content += `</div>`;
            
        } else if(self.cssVariablesStates.renameCategory === true){
            content += `<input type="text" id="brxcRenameCategory" value="${self.helpers.getGlobalVariableCategoryNameById(self.cssVariablesStates.activeCategory)}" />`;
        } else if(self.cssVariablesStates.addCategory === true){
            content += `<input type="text" id="brxcAddCategory" placeholder="Type the category's name here and hit ENTER." value="" />`;
        }
        content += `</div>`;

        const canvas = document.querySelector('#CSSVariableHeaderCanvas')
        if(canvas && content) canvas.innerHTML = content;

        // Add
        if (self.cssVariablesStates.addCategory === true || !self.cssVariablesStates.activeCategory) {
            self.cssVariablesStates.addCategory = false;
            const input = canvas.querySelector('#brxcAddCategory');
            if (!input) return;
            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();

            const onBlur = () => {
                input.removeEventListener("blur", onBlur);
                input.removeEventListener("keydown", onKeyDown);
                setTimeout(() => {
                    self.setCSSVariableManagerHeader();
                }, 10);
            };

            const onKeyDown = (event) => {
                if (event.key === "Enter") {
                    self.addVariableCategory(input);
                    input.removeEventListener("blur", onBlur);
                    input.removeEventListener("keydown", onKeyDown);
                }
            };

            input.addEventListener("blur", onBlur);
            input.addEventListener("keydown", onKeyDown);
        }

        // Rename
        if (self.cssVariablesStates.renameCategory === true) {
            self.cssVariablesStates.renameCategory = false;
            const input = canvas.querySelector('#brxcRenameCategory');
            if (!input) return;
            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();

            function renameName(input) {

                const name = input.value.toLowerCase();
                const existingCategory = self.helpers.getGlobalVariableCategoryIdByName(name);
                if(existingCategory) return self.vueGlobalProp.$_showMessage('ABORT: category name already exists!');

                const obj = self.helpers.getGlobalVariableCategoryObjById(self.cssVariablesStates.activeCategory);
                if(!obj) return;

                obj.name = input.value;
                self.vueGlobalProp.$_showMessage('Category successfully renamed!');
                self.setCSSVariableManager();
            }

            const onBlur = () => {
                input.removeEventListener("blur", onBlur);
                input.removeEventListener("keydown", onKeyDown);
                setTimeout(() => {
                    self.setCSSVariableManagerHeader();
                }, 10);
            };

            const onKeyDown = (event) => {
                if (event.key === "Enter") {
                    renameName(input);
                    input.removeEventListener("blur", onBlur);
                    input.removeEventListener("keydown", onKeyDown);
                }
            };

            input.addEventListener("blur", onBlur);
            input.addEventListener("keydown", onKeyDown);
        }
    },
    addVariableCategory: function(input, event){
        if(event && event.key !== "Enter") return;

        const self = this;
        let count = 0;
        let id;
        const names = input.value.split(',').map(item => item.trim());
        names.forEach(el => {
            const name = el.toLowerCase();
            if(!self.vueState.globalVariablesCategories) self.vueState.globalVariablesCategories = [];
            const existingCategory = self.helpers.getGlobalVariableCategoryIdByName(name);
            if(!existingCategory){
                id = self.vueGlobalProp.$_generateId();
                self.vueState.globalVariablesCategories.push({
                    id: id,
                    name: el
                });
                count++;
            } else {
                id = existingCategory;
            }
        })
        if(count > 0) self.vueGlobalProp.$_showMessage('Category successfully added!');
        
        self.cssVariablesStates.activeCategory = id;
        self.setCSSVariableManager();
    },
    setCSSVariableManagerHeaderFull: function(){
        const self = this;
        const canvas = document.querySelector('#CSSVariableHeaderCanvas');
        if(!canvas) return;

        let cats = '<ul>';
        let count;
        const arr = self.helpers.isCSSVariablesTabActive('theme-variables') && self.helpers.themeHasVariables() ? self.vueState.globalVariables.concat(self.vueState.themeStyleSettings.general._cssVariables) : self.vueState.globalVariables;

        function isActive (name) {
            if(self.helpers.getGlobalVariableCategoryIdByName(name) === self.cssVariablesStates.activeCategory) return true;
            return false;
        }

        // All
        count = arr.length;
        cats += `<li class="${self.cssVariablesStates.activeCategory === "all" ? 'active' : ''}"${self.cssVariablesStates.activeCategory === "all" ? ' data-active="true"' : ''} data-id="all" onClick="ADMINBRXC.variableManagerFilterCat(event)"><input type="text" value="All" readonly/><span class="count">${count}</span></li>`
        
        // Uncategorized
        count = Array.from(arr).filter(el => el && self.helpers.isVariableUncategorized(el)).length;
        cats += `<li class="${self.cssVariablesStates.activeCategory === "uncategorized" ? 'active' : ''}"${self.cssVariablesStates.activeCategory === "uncategorized" ? ' data-active="true"' : ''} data-id="uncategorized" onClick="ADMINBRXC.variableManagerFilterCat(event)"><input type="text" value="Uncategorized" readonly/><span class="count">${count}</span></li>`

        // Categories
        self.vueState.globalVariablesCategories.forEach(catObj => {
            isExpandedDefault = catObj.hasOwnProperty('defaultExpanded');
            count = Array.from(arr).filter(el => el && el.hasOwnProperty('category') && catObj.id === el.category).length;
            cats += `<li class="${isActive(catObj.name) ? 'active' : ''}"${isActive(catObj.name) ? ' data-active="true"' : ''} data-id="${catObj.id}" ondragenter="this.classList.add('dragged')" ondragleave="this.classList.remove('dragged')" ondrop="event.preventDefault();ADMINBRXC.onDropVariableCatList(this);" ondragover="event.preventDefault();" onClick="ADMINBRXC.variableManagerFilterCat(event)">
                        <input type="text" data-initial="${catObj.name}" value="${catObj.name}"${catObj.id !== self.cssVariablesStates.activeCategory ? ' readonly' : ''}/>
                        <div class="action">`;
            if(catObj.id === self.cssVariablesStates.activeCategory){
                    cats += `<div class="expandedCat${isExpandedDefault ? ' expanded' : ''}" onClick="ADMINBRXC.toggleExpandVariableCategory(event,'${self.cssVariablesStates.activeCategory}')" data-balloon="${isExpandedDefault ? 'Expanded' : 'Collapsed'} inside the Variable Picker" data-balloon-pos="top-right"><span class="bricks-svg-wrapper"><i class="fas fa-expand-alt"></i></span></div>
                             <div class="deleteCat" onClick="event.stopPropagation();ADMINBRXC.deleteVariableCategory('${self.cssVariablesStates.activeCategory}')" data-balloon="Delete category" data-balloon-pos="top-right"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
            }
                    cats += `<span class="count">${count}</span>
                        </div>
                    </li>`;
        })

        cats += '</ul><input type="text" id="addNewCat" placeholder="+ New category" onkeyup="ADMINBRXC.addVariableCategory(this, event);" />';

        if(canvas && cats) canvas.innerHTML = cats;

        // rename cat
        const input = canvas.querySelector('li.active input');
        if(input){
            input.addEventListener('keyup', (event) => {
                if(event.key !== "Enter") return;
                if(event.target.value === event.target.dataset.initial) return self.setCSSVariableManagerHeaderFull();
                if(self.vueState.globalVariablesCategories.map(el => el && el.name).includes(event.target.value)) return self.vueGlobalProp.$_showMessage(`ABORT: category "${event.target.value}" already exists`);
                const activeObj = self.helpers.getGlobalVariableCategoryObjById(event.target.parentElement.dataset.id);
                if(!activeObj) return;
                activeObj.name = event.target.value;
                self.vueGlobalProp.$_showMessage(`Category correctly renamed to ${event.target.value}`)
                self.setCSSVariableManagerHeaderFull();
            })
        }
    },
    toggleExpandVariableCategory: function(e,id){
        e.preventDefault();
        e.stopPropagation();
        const self = this;
        const obj = self.helpers.getGlobalVariableCategoryObjById(id);
        if(!obj) return;

        if(obj.hasOwnProperty('defaultExpanded')){
            delete obj['defaultExpanded'];
        } else {
            obj['defaultExpanded'] = true;
        };

        self.setCSSVariableManager();
        self.refreshVariablePickerList(false);
    },
    toggleExpandColorCategory: function(e,id){
        e.preventDefault();
        e.stopPropagation();
        const self = this;
        const obj = self.vueState.colorPalette.find(el => el.id === id);
        if(!obj) return;

        if(obj.hasOwnProperty('defaultExpanded')){
            delete obj['defaultExpanded'];
        } else {
            obj['defaultExpanded'] = true;
        };
        self.refreshVariablePickerList(false);
        
    },
    toggleViewColorCategory: function(e,id,value){
        e.preventDefault();
        e.stopPropagation();
        const self = this;
        const obj = self.vueState.colorPalette.find(el => el.id === id);
        if(!obj) return;

        obj['view'] = value;

        self.refreshVariablePickerList(false);
    },
    variableManagerFilterCat: function(event){
        const self = this;
        target = (event.target.dataset.id) ? event.target : event.target.parentElement;
        if(target.dataset.active === 'true') return;
        self.cssVariablesStates.activeCategory = target.dataset.id;
        self.setCSSVariableManager();
    },
    setDeleteVariable: function(target,newFunction){
        const oldContent = target.innerHTML;
        const oldBalloon = target.dataset.balloon;
        const oldFunction = target.getAttribute('onclick');
        const newContent = '<span class="bricks-svg-wrapper"><i class="fas fa-check"></i></span>';
        const newBalloon = 'Confirm?';

        target.setAttribute("onClick", 'event.stopPropagation();' + newFunction);
        target.setAttribute("data-balloon", newBalloon);
        target.innerHTML = newContent;
        setTimeout(() => {
            target.setAttribute("onClick", oldFunction);
            target.setAttribute("data-balloon", oldBalloon);
            target.innerHTML = oldContent;
        }, 2000)
    },
    setDeleteVariableSingle: function(type, target, id){
        const oldContent = target.innerHTML;
        const oldBalloon = target.dataset.balloon;
        const oldFunction = `ADMINBRXC.setDeleteVariableSingle('${type}', this, '${id}')`;
        const newContent = '<span class="bricks-svg-wrapper"><i class="fas fa-check"></i></span>';
        const newBalloon = 'Confirm?';
        const newFunction = `ADMINBRXC.deleteVariable('${type}', '${id}')`;

        target.setAttribute("onClick", newFunction);
        target.setAttribute("data-balloon", newBalloon);
        target.innerHTML = newContent;
        setTimeout(() => {
            target.setAttribute("onClick", oldFunction);
            target.setAttribute("data-balloon", oldBalloon);
            target.innerHTML = oldContent;
        }, 2000)
    },
    deleteVariableCategory: function(){
        const self = this;
        const arrs = self.helpers.isCSSVariablesTabActive('theme-variables') && self.helpers.themeHasVariables() ? [self.vueState.globalVariables, self.vueState.themeStyleSettings.general._cssVariables] : [self.vueState.globalVariables];
        
        arrs.forEach(arr => {
            const match = arr.filter(el => el && el.hasOwnProperty('category') && el.category === self.cssVariablesStates.activeCategory);
            match.forEach(variable => {
                delete variable.category;
            })
        })

        const index = self.vueState.globalVariablesCategories.indexOf(self.cssVariablesStates.activeCategory);
            self.vueState.globalVariablesCategories.splice(index, 1);
            self.cssVariablesStates.activeCategory = 'all';

        self.vueGlobalProp.$_showMessage('Category successfully deleted');
        self.setCSSVariableManager();
    },
    setCSSVariableManagerSearch: function(){
        const self = this;

        // Variable Manager Disabled
        if(bricksData.disableVariablesManager === "1") return;

        const arr = self.helpers.isCSSVariablesTabActive('theme-variables') && self.helpers.themeHasVariables() ? self.vueState.globalVariables.concat(self.vueState.themeStyleSettings.general._cssVariables) : self.vueState.globalVariables;
        let vars;

        if(self.cssVariablesStates.activeCategory === 'all'){
            vars = arr;
        } else if(self.cssVariablesStates.activeCategory === 'uncategorized'){
            vars = arr.filter(el => el && self.helpers.isVariableUncategorized(el));
        } else {
            vars = Array.from(arr).filter(el => el && el.hasOwnProperty('category') && el.category === self.cssVariablesStates.activeCategory)
        }
        
        const canvas = document.querySelector('#CSSVariableSearchCanvas');
        if(self.cssVariablesStates.view === "sidebar" && (!vars || !Array.isArray(vars) || vars.length < 2)) return canvas.innerHTML = '';
        let content = `<div class="brxc-overlay__search-box">
                        <input type="search" class="class-filter" name="class-search" placeholder="Filter by variable name" data-type="title" value="${self.cssVariablesStates.search}" oninput="ADMINBRXC.cssVariablesStates.search = this.value;ADMINBRXC.setCSSVariableManagerBody();">
                        <div class="iso-search-icon">
                            <i class="bricks-svg ti-search"></i>
                        </div>
                        <div class="iso-reset" data-balloon="Reset Filter" data-balloon-pos="bottom-right" onclick="ADMINBRXC.cssVariablesStates.search = '';ADMINBRXC.setCSSVariableManager();">
                            <i class="bricks-svg ti-close"></i>
                        </div>
                      </div>`;
        canvas.innerHTML = content;
    },
    setCSSVariableManagerBody: function() {
        const self = this;
        const canvas = document.querySelector('#CSSVariableBodyCanvas');

        // Variable Manager Disabled
        if(bricksData.disableVariablesManager === "1"){
            if(!canvas) return;
            canvas.innerHTML = `<p class="varable-manager-disabled" data-control="info">The variable manager is actually disabled in the Bricks Settings -> General -> Miscellaneous. Please activate it in order to manage your variables.</p>`;
            return;
        }

        const vars = self.helpers.isCSSVariablesTabActive('theme-variables') && self.helpers.themeHasVariables() ? self.vueState.globalVariables.concat(self.vueState.themeStyleSettings.general._cssVariables) : self.vueState.globalVariables;
        let allVars;
    
        if (self.cssVariablesStates.activeCategory === 'all') {
            allVars = vars;
        } else if (self.cssVariablesStates.activeCategory === 'uncategorized') {
            allVars = vars.filter(el => el && self.helpers.isVariableUncategorized(el));
        } else {
            allVars = vars.filter(el => el && el.hasOwnProperty('category') && el.category === self.cssVariablesStates.activeCategory);
        }
    
        let globalVars = Object.values(self.vueState.globalVariables);
    
        if (self.cssVariablesStates.activeCategory !== 'all') {
            globalVars = globalVars.filter(el => {
                if (self.cssVariablesStates.activeCategory === 'uncategorized') {
                    return self.helpers.isVariableUncategorized(el);
                } else {
                    return el && el.hasOwnProperty('category') && el.category === self.cssVariablesStates.activeCategory;
                }
            });
        }
    
        if (self.cssVariablesStates.search !== '') {
            globalVars = globalVars.filter(el => el && el.hasOwnProperty('name') && el.name.includes(self.cssVariablesStates.search));
        }
    
        let content = '';
        content += `<div class="variable-heading${allVars.length > 1 ? ' sticky' : ''} global"><label class="has-tooltip"><span class="title${self.cssVariablesStates.showGlobal !== true ? ' inactive' : ''}">Global Variables (${globalVars.length})</span><div data-balloon="The global variables apply on all your website. They have lower specificity compared to theme-specific variables." data-balloon-pos="bottom" data-balloon-length="large"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="action">`;
        content += `<div class="brxc-icon" data-balloon="${self.cssVariablesStates.showGlobal === true ? 'Hide' : 'Show'} Global Variables" data-balloon-pos="left" onclick="ADMINBRXC.toggleGlobalVars('global')"><span class="bricks-svg-wrapper"><i class="fas fa-eye${self.cssVariablesStates.showGlobal !== true ? '-slash' : ''}"></i></span></div>`;
        content += '</div></div>';

        if (globalVars.length > 0 && self.cssVariablesStates.showGlobal === true) {
            content += '<ul class="brxc-global-variable-list">';
            globalVars.forEach(el => {
                content += `<li data-id="${el.hasOwnProperty('id') ? el.id : ''}" class=""><div class="variable-wrapper">`;
                content += `<div class="handle"><i class="fas fa-grip-vertical"></i></div>`;
                content += `<div class="variable-inner-wrapper">`;
                content += `<button class="variable-type-switch ${el.hasOwnProperty('type') && el.type === "clamp" ? 'clamp' : 'static'}" onClick="ADMINBRXC.toggleTypeSwitch('global', '${el && el.hasOwnProperty('id') ? el.id : false}')">${el.hasOwnProperty('type') ? el.type.slice(0, 2) : 'ST'}${self.helpers.isVarActiveOnPage(`var(--${self.helpers.formatForClasses(el.name)})`) ? `<div class="btn-color-check" data-balloon="active on the page" data-balloon-pos="right"><i class="fas fa-check"></i></i></div>` : ''}</button>`;
                content += `<span class="variable-prefix">--</span>`;
                content += `<input type="text" class="variable-name" data-original="${el && el.hasOwnProperty('name') ? el.name : ''}" value="${el && el.hasOwnProperty('name') ? el.name : ''}" onkeyup="ADMINBRXC.renameVariable('global', event)" onblur="this.value = this.dataset.original"/>`;
                content += el.hasOwnProperty('type') && el.type === "clamp" ? `<div class="input-container"><div class="input-wrapper"><input type="number" class="variable-min" value="${el && el.hasOwnProperty('min') ? el.min : ''}" onchange="ADMINBRXC.setVariableClamp('global' ,event,'min');" onkeyup="ADMINBRXC.setVariableClamp('global', event,'min');" /><span class="variable-unit">px</span> </div><div class="input-wrapper"><input type="number" class="variable-max" value="${el && el.hasOwnProperty('max') ? el.max : ''}" onchange="ADMINBRXC.setVariableClamp('global', event,'max');" onkeyup="ADMINBRXC.setVariableClamp('global', event,'max');" /><span class="variable-unit">px</span> </div></div>` : `<input type="text" class="variable-value" value="${el && el.hasOwnProperty('value') ? el.value : ''}" oninput="ADMINBRXC.setVariableValue('global', event,'value');" />`;
                content += `</div>`;
                content += `<div class="right-actions">`;
                content += `<div class="duplicate-variable" data-balloon="Duplicate Variable" data-balloon-pos="left" onClick="ADMINBRXC.duplicateVariable('global','${el.hasOwnProperty("id") ? el.id : false}');"><span class="bricks-svg-wrapper"><i class="fas fa-clone"></i></span></div>`;
                content += `<div class="delete-variable" data-balloon="Delete Variable" data-balloon-pos="left" onClick="ADMINBRXC.setDeleteVariableSingle('global', this, '${el.hasOwnProperty("id") ? el.id : false}');"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
                content += `</div></div>`;
                content += `</li>`;
            });
            content += '</ul>';
        } else if (self.cssVariablesStates.showGlobal === true) {
            content += `<p class="brxc-variable__category-empty" data-control="info">No global variable found in this category.</p>`
        }
        
    
        // Add new variable
        if(self.cssVariablesStates.showGlobal === true){
            content += `<div class="brxc-add-color-wrapper">`;
            content += `<div class="brxc-import-css-colors${self.cssVariablesStates.importGlobalVariables === true ? ' active' : ''}" data-balloon="Import CSS variables" data-balloon-pos="bottom-left" onclick="ADMINBRXC.toggleImportVariables('global','${self.cssVariablesStates.importGlobalVariables === true ? 'true' : 'false'}');"><i class="fas fa-code"></i></div> `;
            content += self.cssVariablesStates.importGlobalVariables === true ? `<textarea id="addNewGlobalVariableCSS" rows="20" placeholder="Paste your CSS variables here"></textarea>` : `<input type="text" id="addNewVariable" class="brxc-add-new-variable" placeholder="Add a new global variable" onkeyup="ADMINBRXC.addVariable('global', event);" />`;
            content += `</div>`;
            if (self.cssVariablesStates.importGlobalVariables === true) {
                content += `<div id="brxcImportVariableWrapper">
                                <div class="gridUI__input-wrapper">
                                    <label class="has-tooltip">
                                        <span>Skip values?</span>
                                        <div data-balloon="Toggle this option if you're importing variables that are defined elsewhere, but want them selectable inside the Variable Picker." data-balloon-pos="top" data-balloon-length="medium">
                                            <i class="fas fa-circle-question"></i>
                                        </div>
                                    </label>
                                    <i class="fas fa-toggle-${self.cssVariablesStates.skipValues === true ? 'on' : 'off'}" onClick="ADMINBRXC.cssVariablesStates.skipValues = !ADMINBRXC.cssVariablesStates.skipValues;ADMINBRXC.setCSSVariableManagerBody();"></i>
                                </div>
                                <a class="brxc-overlay__action-btn primary" onclick="ADMINBRXC.importVariables('global');"><span>Import Variables</span></a>
                            </div>`;
            }
        }
        
    
        if (!self.helpers.isCSSVariablesTabActive('theme-variables')) {
            return canvas.innerHTML = content;
        }
    
        // Theme Variables
        if(self.helpers.isThemeVariableActive()){
            if (self.helpers.themeHasVariables() && self.cssVariablesStates.activeCategory) {
                let tempVarsTheme;
                if (self.cssVariablesStates.activeCategory === 'all') {
                    tempVarsTheme = self.vueState.themeStyleSettings.general._cssVariables;
                } else if (self.cssVariablesStates.activeCategory === 'uncategorized') {
                    tempVarsTheme = Array.from(self.vueState.themeStyleSettings.general._cssVariables).filter(el => el && self.helpers.isVariableUncategorized(el));
                } else {
                    tempVarsTheme = Array.from(self.vueState.themeStyleSettings.general._cssVariables).filter(el => el && el.hasOwnProperty('category') && el.category === self.cssVariablesStates.activeCategory);
                }
        
                let themeVars = Object.values(tempVarsTheme);
        
                if (self.cssVariablesStates.search !== '') {
                    themeVars = themeVars.filter(el => el && el.hasOwnProperty('name') && el.name.includes(self.cssVariablesStates.search));
                }
        
                content += `<div class="variable-heading${allVars.length > 1 ? ' sticky' : ''} theme"><label class="has-tooltip"><span class="title${self.cssVariablesStates.showTheme !== true ? ' inactive' : ''}">Theme Variables (${themeVars.length})</span><div data-balloon="The theme variables only apply on posts/pages where the specific theme style is active. They have higher specificity than global variables." data-balloon-pos="bottom" data-balloon-length="large"><i class="fas fa-circle-question"></i></div></label>`;
                content += `<div class="action">`;
                content += `<div class="brxc-icon" data-balloon="${self.cssVariablesStates.showTheme === true ? 'Hide' : 'Show'} Theme Variables" data-balloon-pos="left" onclick="ADMINBRXC.toggleGlobalVars('theme')"><span class="bricks-svg-wrapper"><i class="fas fa-eye${self.cssVariablesStates.showTheme !== true ? '-slash' : ''}"></i></span></div>`;
                content += '</div></div>';
                if (themeVars.length > 0 && self.cssVariablesStates.showTheme === true) {
                    content += '<ul class="brxc-theme-variable-list" data-type="theme">';
                    themeVars.forEach(el => {
                        content += `<li data-id="${el.hasOwnProperty('id') ? el.id : ''}" class=""><div class="variable-wrapper">`;
                        content += themeVars.length > 1 && self.cssVariablesStates.activeCategory === 'all' ? `<div class="handle"><i class="fas fa-grip-vertical"></i></div>` : '';
                        content += `<div class="variable-inner-wrapper">`;
                        content += `<button class="variable-type-switch ${el.hasOwnProperty('type') && el.type === "clamp" ? 'clamp' : 'static'}" onClick="ADMINBRXC.toggleTypeSwitch('theme', '${el && el.hasOwnProperty('id') ? el.id : false}')">${el.hasOwnProperty('type') ? el.type.slice(0, 2) : 'ST'}${self.helpers.isVarActiveOnPage(`var(--${self.helpers.formatForClasses(el.name)})`) ? `<div class="btn-color-check" data-balloon="active on the page" data-balloon-pos="right"><i class="fas fa-check"></i></i></div>` : ''}</button>`;
                        content += `<span class="variable-prefix">--</span>`;
                        content += `<input type="text" class="variable-name" data-original="${el && el.hasOwnProperty('name') ? el.name : ''}" value="${el && el.hasOwnProperty('name') ? el.name : ''}" onkeyup="ADMINBRXC.renameVariable('theme', event)" onblur="this.value = this.dataset.original"/>`;
                        content += el.hasOwnProperty('type') && el.type === "clamp" ? `<div class="input-container"><div class="input-wrapper"><input type="number" class="variable-min" value="${el && el.hasOwnProperty('min') ? el.min : ''}" onchange="ADMINBRXC.setVariableClamp('theme' ,event,'min');" onkeyup="ADMINBRXC.setVariableClamp('theme', event,'min');" /><span class="variable-unit">px</span> </div><div class="input-wrapper"><input type="number" class="variable-max" value="${el && el.hasOwnProperty('max') ? el.max : ''}" onchange="ADMINBRXC.setVariableClamp('theme', event,'max');" onkeyup="ADMINBRXC.setVariableClamp('theme', event,'max');" /><span class="variable-unit">px</span> </div></div>` : `<input type="text" class="variable-value" value="${el && el.hasOwnProperty('value') ? el.value : ''}" oninput="ADMINBRXC.setVariableValue('theme', event,'value');" />`;
                        content += `</div>`;
                        content += `<div class="right-actions">`;
                        content += `<div class="duplicate-variable" data-balloon="Duplicate Variable" data-balloon-pos="left" onClick="ADMINBRXC.duplicateVariable('theme', '${el.hasOwnProperty("id") ? el.id : false}');"><span class="bricks-svg-wrapper"><i class="fas fa-clone"></i></span></div>`;
                        content += `<div class="delete-variable" data-balloon="Delete Variable" data-balloon-pos="left" onClick="ADMINBRXC.setDeleteVariableSingle('theme', this, '${el.hasOwnProperty("id") ? el.id : false}');"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
                        content += `</div></div>`;
                        content += `</li>`;
                    });
                    content += '</ul>';
                } else if (self.cssVariablesStates.showTheme === true) {
                    content += `<p class="brxc-variable__category-empty" data-control="info">No theme variable found in this category.</p>`
                }
            } else {
                content += `<div class="variable-heading theme"><label class="has-tooltip"><span class="title${self.cssVariablesStates.showTheme !== true ? ' inactive' : ''}">Theme Variables (0)</span><div data-balloon="The theme variables only apply on posts/pages where the specific theme style is active. They have higher specificity than global variables." data-balloon-pos="bottom" data-balloon-length="large"><i class="fas fa-circle-question"></i></div></label>`;
                content += `<div class="action">`;
                content += `<div class="brxc-icon" data-balloon="${self.cssVariablesStates.showTheme === true ? 'Hide' : 'Show'} Theme Variables" data-balloon-pos="left" onclick="ADMINBRXC.toggleGlobalVars('theme')"><span class="bricks-svg-wrapper"><i class="fas fa-eye${self.cssVariablesStates.showTheme !== true ? '-slash' : ''}"></i></span></div>`;
                content += '</div></div>';
                content += `<p class="brxc-variable__category-empty" data-control="info">No theme variable found in this category.</p>`;
            }
        
            // Add new variable
            if(self.cssVariablesStates.showTheme === true){
                content += `<div class="brxc-add-color-wrapper">`;
                content += `<div class="brxc-import-css-colors${self.cssVariablesStates.importThemeVariables === true ? ' active' : ''}" data-balloon="Import CSS variables" data-balloon-pos="bottom-left" onclick="ADMINBRXC.toggleImportVariables('theme', '${self.cssVariablesStates.importThemeVariables === true ? 'true' : 'false'}');"><i class="fas fa-code"></i></div> `;
                content += self.cssVariablesStates.importThemeVariables === true ? `<textarea id="addNewThemeVariableCSS" rows="20" placeholder="Paste your CSS variables here"></textarea>` : `<input type="text" id="addNewThemeVariable" class="brxc-add-new-variable" placeholder="Add a new theme variable" onkeyup="ADMINBRXC.addVariable('theme', event);" />`;
                content += `</div>`;
                if (self.cssVariablesStates.importThemeVariables === true) {
                    content += `<div id="brxcImportVariableWrapper">
                                    <div class="gridUI__input-wrapper">
                                        <label class="has-tooltip">
                                            <span>Skip values?</span>
                                            <div data-balloon="Toggle this option if you're importing variables that are defined elsewhere, but want them selectable inside the Variable Picker." data-balloon-pos="top" data-balloon-length="medium">
                                                <i class="fas fa-circle-question"></i>
                                            </div>
                                        </label>
                                        <i class="fas fa-toggle-${self.cssVariablesStates.skipValues === true ? 'on' : 'off'}" onClick="ADMINBRXC.cssVariablesStates.skipValues = !ADMINBRXC.cssVariablesStates.skipValues;ADMINBRXC.setCSSVariableManagerBody();"></i>
                                    </div>
                                    <a class="brxc-overlay__action-btn primary" onclick="ADMINBRXC.importVariables('theme');"><span>Import Variables</span></a>
                                </div>`;
                }
            }
        }
        
    
        canvas.innerHTML = content;
    
        //Listeners
    
        const variableWrappers = canvas.querySelectorAll('ul.brxc-theme-variable-list, ul.brxc-global-variable-list');
        if (variableWrappers.length < 1) return;
    
        variableWrappers.forEach(variableWrapper => {
            const inputs = variableWrapper.querySelectorAll('input.variable-value');
            if (inputs && inputs.length > 0) {
                inputs.forEach(input => {
                    // auto-complete
                    if (Object.values(self.globalSettings.classFeatures).includes("autocomplete-variable")) {
                        input.addEventListener('focus', () => {
                            self.autocomplete(input, self.cssVariables, "style");
                        });
                    }
    
                    //autoformat
                    if (Object.values(self.globalSettings.classFeatures).includes("autoformat-field-values")) {
                        input.addEventListener('blur', () => {
                            self.autoformat(input, "custom");
                            input.dispatchEvent(new Event('input'));
                        });
                    }
                });
            }

            //Drag and drop
            const rows = variableWrapper.querySelectorAll('li .handle');
            if (!rows || rows.length < 1) return;
    
            new Sortable(variableWrapper, {
                multiDrag: true,
                selectedClass: "sortable-selected",
                animation: 150,
                handle: "li .handle",
                helper: 'clone',
                onStart: function (evt) {
                    evt.items.length > 0 ? self.cssVariablesStates.onDrag = evt.items.map(el => el.dataset.id) : self.cssVariablesStates.onDrag = [evt.item.dataset.id];
                },
                onEnd: () => {
                    const vars = variableWrapper.dataset.type === "theme" ? self.vueState.themeStyleSettings.general._cssVariables : self.vueState.globalVariables;
                    const items = Array.from(variableWrapper.children);
                    items.forEach((item, index) => {
                        const target = Array.from(vars).find(el => el && el.hasOwnProperty('id') && el.id === item.dataset.id);
                        if (!target) return;
    
                        self.helpers.moveArr(vars, vars.indexOf(target), index);
                    });
    
                    self.setCSSVariableManager();
                },
            });
 
        });
    },
    
    toggleGlobalVars: function(type){
        const self = this;
        if(type === 'theme'){
            self.cssVariablesStates.showTheme === true ? self.cssVariablesStates.showTheme = false : self.cssVariablesStates.showTheme = true;
        } else {
            self.cssVariablesStates.showGlobal === true ? self.cssVariablesStates.showGlobal = false : self.cssVariablesStates.showGlobal = true;
        }
        self.setCSSVariableManager();
    },
    deleteVariable: function(type, id){
        const self = this;
        const vars = type === "theme" ? self.vueState.themeStyleSettings.general._cssVariables : self.vueState.globalVariables;
        const variable = Array.from(vars).find(el => el && el.hasOwnProperty('id') && el.id === id);
        if (!variable) return;

        const index = vars.indexOf(variable);
        if (index === -1) return;

        vars.splice(index, 1);

        // Regenerate CSS
        if(type === "theme"){
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();  
        }
        self.vueGlobalProp.$_showMessage('Variable successfully deleted');
        self.setCSSVariableManager();
    },
    addVariable: function(type, event){
        if(event.key !== "Enter") return;
        const self = this;
        let vars;

        if(type === "theme") {
            self.helpers.createThemeVariable();
            vars = self.vueState.themeStyleSettings.general._cssVariables;
        } else {
            vars = self.vueState.globalVariables;
        }
        const newVariable = {
            id: self.vueGlobalProp.$_generateId(),
            name: self.helpers.formatForClasses(event.target.value),
            type: 'static',
        }

        // Add Category
        if(self.cssVariablesStates.activeCategory && !['all','uncategorized'].includes(self.cssVariablesStates.activeCategory)) newVariable.category = self.cssVariablesStates.activeCategory;
        
        // Push Variable
        vars.push(newVariable);

        // Regenerate theme CSS
        if(type === 'theme'){
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
        }

        self.vueGlobalProp.$_showMessage('Variable successfully added');
        self.setCSSVariableManager();

        // refocus the cursor
        setTimeout(() => {
            const input = type === "theme" ? document.querySelector('#addNewThemeVariable') : document.querySelector('#addNewVariable');
            if(!input) return;

            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();
        },10)

    },
    duplicateVariable: function(type, id){
        const self = this;
        const vars = type === 'theme' ? self.vueState.themeStyleSettings.general._cssVariables : self.vueState.globalVariables;
        const variable = Array.from(vars).find(el => el && el.hasOwnProperty('id') && el.id === id);
        if (!variable) return;

        const newVariable = {...variable};
        newVariable.id = self.vueGlobalProp.$_generateId();
        newVariable.name = `${variable.name}-copy`;

        vars.push(newVariable);

        // Regenerate CSS
        if(type === "theme"){
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
        }

        self.setCSSVariableManager();
    },
    setaddVariableFromPicker: function(event, target){
        const self = this;
        const group = event.target.dataset.group;
        const parent = event.target.closest('.brxc-overlay__action-btn-wrapper');
        event.target.remove();
        let input = document.createElement('input');
        input.type = "text";
        input.setAttribute('class', 'add-new-variable-input');
        parent.appendChild(input);

        input = parent.querySelector('.add-new-variable-input');
        const end = input.value.length;
        input.setSelectionRange(end, end);
        input.focus();
        input.addEventListener('keyup', (e) => {
            self.addVariableFromPicker(e, group, target);
        })
    },
    addVariableFromPicker: function(event, groupId, target){
        if(event.key !== "Enter") return;
        const self = this;
        self.cssVariablesStates.activeCategory = groupId;
        target.value = `var(--${self.helpers.formatForClasses(event.target.value)})`;
        const event2 = new Event('input', {
            bubbles: true,
            cancelable: true,
        });
        target.dispatchEvent(event2);
        self.openVariableCategory(groupId);
        self.addVariable('global', event);
        setTimeout(() => {
            const inputs = document.querySelectorAll('.brxc-global-variable-list input[type="text"].variable-value');
            if(!inputs || inputs.length < 1) return;
            const input = inputs[inputs.length - 1];
            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();

        }, 5)
    },
    importVariables: function(type){
        const self = this;
        const selector = type === "theme" ? '#addNewThemeVariableCSS' : '#addNewGlobalVariableCSS'
        const value = document.querySelector(selector).value;
        const cssVariablePattern = /(--[\w-]+):\s*([^;]+);/g;
        const parsedValue = value ? value.replaceAll('\n', '') : false;
        let vars;
        let importedVariables = 0;
        let newVariable;

        // No value found
        if (!parsedValue || parsedValue.length < 1) return;

        const matches = parsedValue.match(cssVariablePattern);
        if(!matches || !Array.isArray(matches) || matches.length < 1) return self.vueGlobalProp.$_showMessage(`No Matching Variables found`);

        // Assigning the correct array
        if(type === "theme") {
            self.helpers.createThemeVariable();
            vars = self.vueState.themeStyleSettings.general._cssVariables;
        } else {
            vars = self.vueState.globalVariables;
        }
        
        // Loop throug all the declarations
        matches.forEach(match => {
            const matchResult = match.match(cssVariablePattern);
            if (!matchResult) return;
            const split = matchResult[0].split(':');
            const name = split[0].substr(2);
            const value = split[1].trimStart().replaceAll(';', '');
            const formattedName = self.helpers.formatForClasses(name);
            let newVariable = '';
            // Parse clamp values

            if(self.cssVariablesStates.skipValues === true){
                newVariable = {
                    id: self.vueGlobalProp.$_generateId(),
                    name: formattedName,
                    type: 'static',
                }
            } else if (value.includes('clamp(')) {

                function remToPx(remValue, rootFontSize) {
                    const pxValue = remValue * rootFontSize;
                    return parseFloat(pxValue.toFixed(2)).toString();
                }

                // Root
                let rootFontSize = self.helpers.getRootFontSize();
                let min = false;
                let max = false;

                // Extracting min and max values from the clamp function
                const clampValues = value.match(/clamp\((.+)\)/)[1].split(',').map(v => v.trim());

                let tempMin = clampValues[0];
                let tempMax = clampValues[clampValues.length - 1];

                // min
                if(tempMin.includes('rem')) {
                    min = remToPx(parseFloat(tempMin), rootFontSize);
                } else if (tempMin.includes('px')){
                    min = tempMin.replaceAll('px','');
                }

                // max
                if(tempMax.includes('rem')) {
                    max = remToPx(parseFloat(tempMax), rootFontSize);
                } else if (tempMax.includes('px')){
                    max = tempMax.replaceAll('px','');
                }

                // Clamp with either px or rem
                if(min && max){
                    newVariable = {
                        id: self.vueGlobalProp.$_generateId(),
                        name: formattedName,
                        type: 'clamp',
                        value: self.helpers.clampBuilder(min, max),
                        min: min,
                        max: max,
                    };

                // Clamp with unknown unit
                } else {
                    newVariable = {
                        id: self.vueGlobalProp.$_generateId(),
                        name: formattedName,
                        type: 'static',
                        value: value,
                    }
                }
                
            
            // Static Values
            } else {
                newVariable = {
                    id: self.vueGlobalProp.$_generateId(),
                    name: formattedName,
                    type: 'static',
                    value: value,
                }
            }

            // Add Category
            if(self.cssVariablesStates.activeCategory && !['all','uncategorized'].includes(self.cssVariablesStates.activeCategory)) newVariable.category = self.cssVariablesStates.activeCategory;
            
            // Push new variable
            vars.push(newVariable);

            importedVariables++;

        })

        // Message
        importedVariables === 0 ? self.vueGlobalProp.$_showMessage(`No Variables found`) : self.vueGlobalProp.$_showMessage(`${importedVariables} Variables have been successfully imported`);
        
        // Regenerate Theme CSS
        if(type === "theme"){
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
            self.cssVariablesStates.importThemeVariables = false;
        } else {
            self.cssVariablesStates.importGlobalVariables = false;
        }
        self.setCSSVariableManager();

    },
    renameVariable: function(type, event){
        if(event.key !== "Enter") return;
        const self = this;
        const vars = type === "theme" ? self.vueState.themeStyleSettings.general._cssVariables : self.vueState.globalVariables;
        const row = event.target.closest('li');
        const variable = Array.from(vars).find(el => el && el.hasOwnProperty('id') && row.dataset.id && row.dataset.id === el.id);
        if(!variable) return;

        variable.name = self.helpers.formatForClasses(event.target.value);

        // Regenerate Theme CSS
        if(type === "theme"){
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
        }

        self.vueGlobalProp.$_showMessage('Variable successfully renamed');
        self.setCSSVariableManager();
    },
    setVariableValue: function(type, event, property){
        const self = this;
        const vars = type === "theme" ? self.vueState.themeStyleSettings.general._cssVariables : self.vueState.globalVariables;
        const row = event.target.closest('li');
        const variable = Array.from(vars).find(el => el && el.hasOwnProperty('id') && row.dataset.id && row.dataset.id === el.id);
        if(!variable) return;
        event.target.value === '' ? delete variable[property] : variable[property] = event.target.value;
        if (self.debounceTimer) {
            clearTimeout(self.debounceTimer);
        }

        // Regenerate Theme CSS
        self.debounceTimer = setTimeout(() => {
            if (type !== "theme") return;
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
        }, 300)
        
    },
    setVariableClamp: function(type, event, property){
        const self = this;
        const vars = type === "theme" ? self.vueState.themeStyleSettings.general._cssVariables : self.vueState.globalVariables;
        const row = event.target.closest('li');
        const variable = Array.from(vars).find(el => el && el.hasOwnProperty('id') && row.dataset.id && row.dataset.id === el.id);
        if(!variable) return;

        variable[property] = event.target.value;
        if(variable.hasOwnProperty('min') && variable.hasOwnProperty('max')){
            variable['value'] = self.helpers.clampBuilder(parseFloat(variable['min']), parseFloat(variable['max']));
        }

        if (type === "theme") {
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
        };

        
    },
    toggleTypeSwitch: function(type, id){
        const self = this;
        const vars = type === 'theme' ? self.vueState.themeStyleSettings.general._cssVariables : self.vueState.globalVariables;
        const variable = Array.from(vars).find(el => el && el.hasOwnProperty('id') && el.id === id);
        if (!variable) return;
        
        variable.type = variable.type === 'clamp' ? 'static' : 'clamp';
        
        if(type === "theme"){
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
        }

        self.setCSSVariableManager();
    },
    toggleImportVariables: function(type, importCSS){
        const self = this;
        const value = !(importCSS === 'true');
        type === 'theme' ?  self.cssVariablesStates.importThemeVariables = value : self.cssVariablesStates.importGlobalVariables = value;
        self.setCSSVariableManagerBody();
    },
    // Color Manager
    colorStates:{
        activePalette: "",
        activeColor: false,
        colorManagerMode: "light",
        colorManagerSearch: "",
        colorManagerRenamePalette: false,
        colorManagerAddPalette: false,
        colorManagerShadePopup: false,
        colorManagerShadePopupId: false,
        colorManagerShadePopupLastId: false,
        colorManagerShadeNumber: 6,
        colorManagerShadeBaseName: false,
        colorManagerShadeCustom: false,
        colorManagerShadeLight: true,
        colorManagerShadeDark: true,
        colorManagerShadeTransparent: true,
        colorManagerShadeLightValid: true,
        colorManagerShadeDarkValid: true,
        colorManagerShadeTransparentValid: true,
        colorManagerShadeColors: ['#ffffff'],
        colorManagerShadeFinalColors: ['#ffffff'],
        colorManagerComplementaryPopup: false,
        colorManagerComplementaryPopupId: false,
        colorManagerComplementaryPopupLastId: false,
        colorManagerComplementaryBaseName: false,
        colorManagerComplementaryScheme: 'complementary',
        colorManagerComplementaryFinalColors: [],
        generatedCSS: false,
    },
    setColorManager: function(){
        const self = this;
        self.setColorManagerHeader();
        self.setColorManagerSearch();
        self.setColorManagerBody();
    },
    setFavoritePalette: function(){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const activePalette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id === self.colorStates.activePalette);
        const defaultPalette = Array.from(palettes).find(el => el && el.hasOwnProperty('default') && el.default === "true");
        if(activePalette && defaultPalette && activePalette === defaultPalette){
            delete defaultPalette.default;
            self.vueGlobalProp.$_showMessage('Color Palette successfully removed as default!');
        } else {
            if(defaultPalette) delete defaultPalette.default;
            activePalette.default = "true";
            self.vueGlobalProp.$_showMessage('Color Palette successfully set as default!');
        }
        self.setColorManagerHeader();

    },
    togglePaletteStatus: function(){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        if(!palette) return;

        !palette.hasOwnProperty('status') || palette.status !== "disabled" ? palette.status = "disabled" : palette.status = "enabled";
        self.generateColorCSS();
        self.generateBuilderCSS();
        self.setColorManagerHeader();
    },
    setColorManagerHeader: function(){
        const self = this;
        let content = '';
        const palettes = self.vueState.colorPalette;
        if(palettes.length < 1) return;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        content += `<div class="brxc-select">`;
        content += (self.colorStates.colorManagerMode === 'dark') ? `<div class="brxc-darkmode active" data-balloon="Switch to Lightmode" data-balloon-pos="right" onclick="ADMINBRXC.darkMode()"><i class="ion-ios-moon"></i></div>` : `<div class="brxc-darkmode" data-balloon="Switch to Darkmode" data-balloon-pos="right"onclick="ADMINBRXC.darkMode()"><i class="ion-ios-sunny"></i></div>`;
        if(self.colorStates.colorManagerRenamePalette === false && self.colorStates.colorManagerAddPalette === false){
            content += `<select name="brxc-colorPaletteOptions" id="colorPaletteOptions" class="brxc-colorPaletteOptions" value="${palette.name}" onChange="ADMINBRXC.colorStates.colorManagerSearch = '';ADMINBRXC.colorStates.activePalette = this.value;ADMINBRXC.setColorManagerSearch();ADMINBRXC.setColorManagerHeader();ADMINBRXC.setColorManagerBody();">`;
            palettes.forEach(pal => {
                content += `<option value="${pal.id}"${pal.id === self.colorStates.activePalette ? ' selected="selected"' : ''}>${pal.name}</option>`;
            })
            content += `</select>`;
            content += '<div class="brxc-icon-container">'
            content += `<div class="brxc-icon${palette.hasOwnProperty('default') && palette.default === "true" ? ' active' : ''}" data-balloon="Set as Default" data-balloon-pos="bottom-right" onClick="ADMINBRXC.setFavoritePalette();"><span class="bricks-svg-wrapper"><i class="fas fa-star"></i></span></div>`;
            content += `<div class="brxc-icon" data-balloon="Rename Palette" data-balloon-pos="bottom-right" onClick="ADMINBRXC.colorStates.colorManagerRenamePalette = true;ADMINBRXC.setColorManagerHeader()"><span class="bricks-svg-wrapper"><i class="fas fa-pen"></i></span></div>`;
            content += `<div class="brxc-icon" data-balloon="Add New Palette" data-balloon-pos="bottom-right" onClick="ADMINBRXC.colorStates.colorManagerAddPalette = true;ADMINBRXC.setColorManagerHeader()"><span class="bricks-svg-wrapper"><i class="fas fa-plus"></i></span></div>`;
            content += `<div class="brxc-icon" data-balloon="Duplicate Palette" data-balloon-pos="bottom-right" onClick="ADMINBRXC.duplicatePalette();"><span class="bricks-svg-wrapper"><i class="fas fa-clone"></i></span></div>`;
            content += `<div class="brxc-icon" data-balloon="Delete Palette" data-balloon-pos="bottom-right" onClick="ADMINBRXC.setDeleteVariable(this, 'ADMINBRXC.deletePalette();');"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
            content += `</div>`;
            content += `<div class="brxc-toggle-palette"><div class="" data-balloon="${!palette.hasOwnProperty('status') || palette.status !== "disabled" ? "Disable Palette" : "Enable Palette"}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.togglePaletteStatus()">`;
            content += !palette.hasOwnProperty('status') || palette.status !== "disabled" ? `<i class="fas fa-toggle-on"></i>` : `<i class="fas fa-toggle-off"></i>`;
            content += `</div></div>`;
        } else if(self.colorStates.colorManagerRenamePalette === true){
            content += `<input type="text" id="brxcRenamePalette" value="${palette.name}" />`;
        } else if(self.colorStates.colorManagerAddPalette === true){
            content += `<input type="text" id="brxcAddPalette" placeholder="Type the color palette's name here and hit ENTER." value="" />`;
        }
        content += `</div>`;

        const canvas = document.querySelector('#colorHeaderCanvas')
        if(canvas && content) canvas.innerHTML = content;

        // Rename
        if (self.colorStates.colorManagerRenamePalette === true) {
            self.colorStates.colorManagerRenamePalette = false;
            const input = canvas.querySelector('#brxcRenamePalette');
            if (!input) return;
            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();

            function saveName(input) {
                const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette);
                if (palette.name !== input.value) {
                    palette.name = input.value;
                    self.vueGlobalProp.$_showMessage('Color Palette correctly renamed!');
                }
                setTimeout(() => {
                    self.setColorManager();
                }, 10);
            }

            const onBlur = () => {
                saveName(input);
                input.removeEventListener("blur", onBlur);
                input.removeEventListener("keydown", onKeyDown);
                setTimeout(() => {
                    self.setColorManagerHeader();
                }, 10);
            };

            const onKeyDown = (event) => {
                if (event.key === "Enter") {
                    saveName(input);
                    input.removeEventListener("blur", onBlur);
                    input.removeEventListener("keydown", onKeyDown);
                }
            };

            input.addEventListener("blur", onBlur);
            input.addEventListener("keydown", onKeyDown);
        }


        // Add
        if (self.colorStates.colorManagerAddPalette === true) {
            self.colorStates.colorManagerAddPalette = false;
            const input = canvas.querySelector('#brxcAddPalette');
            if (!input) return;
            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();
            const newId = self.vueGlobalProp.$_generateId();

            function addName(input) {
                const newPalette = {
                    id: newId,
                    name: input.value,
                    colors: []
                };
                palettes.push(newPalette);
                self.colorStates.activePalette = newId;
                self.vueGlobalProp.$_showMessage('Color Palette successfully created!');
                self.setColorManager();
            }

            const onBlur = () => {
                input.removeEventListener("blur", onBlur);
                input.removeEventListener("keydown", onKeyDown);
                setTimeout(() => {
                    self.setColorManagerHeader();
                }, 10);
            };

            const onKeyDown = (event) => {
                if (event.key === "Enter") {
                    addName(input);
                    input.removeEventListener("blur", onBlur);
                    input.removeEventListener("keydown", onKeyDown);
                }
            };

            input.addEventListener("blur", onBlur);
            input.addEventListener("keydown", onKeyDown);
        }
    },
    duplicatePalette: function () {
        const self = this;
        const palettes = self.vueState.colorPalette;
        const activePalette = palettes.find(el => el && el.hasOwnProperty('id') && el.id === self.colorStates.activePalette);

        function reassignNewIds(arr) {
            const idMap = new Map();
        
            // Process parents first
            for (const parent of arr.filter(el => el && el.hasOwnProperty('shadeChildren') && el.shadeChildren && el.shadeChildren.length > 0)) {
                const newId = self.vueGlobalProp.$_generateId();
                idMap.set(parent.id, newId);
                parent.id = newId;
        
                for (const childId of parent.shadeChildren) {
                    const child = arr.find(el => el && el.id === childId);
                    if (child) {
                        child.shadeParent = newId;
                    }
                }
                parent.shadeChildren.length = 0;
            }
        
            // Process children
            for (const child of arr.filter(el => el && !el.hasOwnProperty('shadeChildren'))) {
                const newId = self.vueGlobalProp.$_generateId();
                idMap.set(child.id, newId);
                child.id = newId;
                if(child.hasOwnProperty('shadeParent')){
                    const parent = arr.find(el => el && el.id === child.shadeParent);
                    if (parent) {
                        parent.shadeChildren.push(newId);
                    }
                }
                
            }
            return arr;
        }
    
        if (activePalette) {
            const duplicate = {
                ...activePalette,
                id: self.vueGlobalProp.$_generateId(),
                name: activePalette.name + ' (Copy)',
            };
            duplicate.colors = reassignNewIds(JSON.parse(JSON.stringify(duplicate.colors)));
            if(duplicate.hasOwnProperty('default')) delete duplicate.default;
    
            palettes.push(duplicate);
            self.colorStates.activePalette = duplicate.id;
            self.vueGlobalProp.$_showMessage('Color Palette successfully duplicated!');
            self.setColorManager();
        }
        
    },
    deletePalette: function(){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const activePalette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id === self.colorStates.activePalette);
        
        palettes.splice(palettes.indexOf(activePalette), 1);
        self.colorStates.activePalette = (self.vueState.colorPalette[0]) ? self.vueState.colorPalette[0].id : '';

        self.vueGlobalProp.$_showMessage('Color Palette successfully deleted!');
        self.generateColorCSS();
        self.generateBuilderCSS();
        self.setColorManager();

    },
    setColorManagerSearch: function(){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const activePalette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id === self.colorStates.activePalette);
        const canvas = document.querySelector('#colorSearchCanvas');
        if(!activePalette || !activePalette.hasOwnProperty('colors') || !Array.isArray(activePalette.colors) || activePalette.colors.length < 2) return canvas.innerHTML = '';
        let content = `<div class="brxc-overlay__search-box">
                        <input type="search" class="class-filter" name="class-search" placeholder="Filter by color name" data-type="title" value="${self.colorStates.colorManagerSearch}" oninput="ADMINBRXC.colorStates.colorManagerSearch = this.value;ADMINBRXC.setColorManagerBody();">
                        <div class="iso-search-icon">
                            <i class="bricks-svg ti-search"></i>
                        </div>
                        <div class="iso-reset" data-balloon="Reset Filter" data-balloon-pos="bottom-right" onclick="ADMINBRXC.colorStates.colorManagerSearch = '';ADMINBRXC.setColorManagerSearch();ADMINBRXC.setColorManagerBody();">
                            <i class="bricks-svg ti-close"></i>
                        </div>
                      </div>`;
        canvas.innerHTML = content;
    },
    setColorManagerBody: function(){
        const self = this;
        self.resetStates();
        const mode = self.colorStates.colorManagerMode;
        const canvas = document.querySelector('#colorBodyCanvas');
        const palettes = self.vueState.colorPalette;
        const activePalette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id === self.colorStates.activePalette);
        if(!activePalette) return;
        if(!activePalette.hasOwnProperty('colors') ) activePalette.colors = {};
        let colors = activePalette.colors;
        
        // Search
        colors = (self.colorStates.colorManagerSearch === '') ? colors : Array.from(colors).filter(el => el && el.name.includes(self.colorStates.colorManagerSearch));


        function checkRow(obj,hasRaw){
            if(!hasRaw){
                if(obj.hasOwnProperty('hsl')){
                    return obj.hsl;
                } else if(obj.hasOwnProperty('rgb')){
                    return obj.rgb;
                } else if (obj.hasOwnProperty('hex')){
                    return obj.hex;
                }
            } else {
                //const mode = self.colorStates.colorManagerMode;
                if(obj.hasOwnProperty('raw') && obj.hasOwnProperty('rawValue') && obj.rawValue.hasOwnProperty(mode)){
                    return obj.rawValue[mode];
                } else if (mode === "dark" && obj.hasOwnProperty('raw') && obj.hasOwnProperty('rawValue') && obj.rawValue.hasOwnProperty("light")){
                    return obj.rawValue.light
                } else if(obj.hasOwnProperty('raw')){
                    return obj.raw;
                } else {
                    return '#ff0000';
                }
            }
        }

        let content = '<ul class="brxc-color-list">';
        let ind = 0;
        for(const key of Object.keys(colors)){
            const color = colors[key];
            const hasRaw = color.hasOwnProperty('raw');
            const hasRawValue = color.hasOwnProperty('rawValue');
            const isShade = color.hasOwnProperty('isShade') && color.hasOwnProperty('shadeParent') && color.shadeParent;
            const isVariableOnly = color.hasOwnProperty('isVariableOnly') && color.isVariableOnly === true;

            // Hide if parent is not expanded
            const hasShadeParent = color.hasOwnProperty('shadeParent');
            const parent = hasShadeParent ? Array.from(colors).find(el => el && el.hasOwnProperty('id') && el.id === color.shadeParent) : false;
            if(parent && parent.hasOwnProperty('isExpanded') && parent.isExpanded !== true) continue;

            const isFramework = self.helpers.isFramework(color.id);
            content += `<li data-id="${color.id}"${!isShade ? ' data-parent="true"' : ''} class="${(self.colorStates.colorManagerShadePopup === true && self.colorStates.colorManagerShadePopupId === color.id) || (self.colorStates.colorManagerComplementaryPopup === true && self.colorStates.colorManagerComplementaryPopupId === color.id) ? 'active' : ''}${mode === "light" && isFramework ? ' framework' : ''}${!hasRaw ? ' disable' : ''}"><div class="color-wrapper">`;
            content += `<div class="handle"><i class="fas fa-grip-vertical"></i></div>`;
            content += `<div class="btn-color-wrapper"><button class="brxc-color-input${mode === "light" && isFramework ? '-framework' : ''}${!isVariableOnly ? ' main-color': ''}" data-id="${color.id}" data-initial-color="${checkRow(color,hasRaw)}" data-balloon="${isVariableOnly ? color.raw : checkRow(color,hasRaw)}" data-balloon-pos="top-left" style="background:${isVariableOnly ? color.raw : checkRow(color,hasRaw)};"></button>`
            content += color.hasOwnProperty('raw') && self.helpers.isVarActiveOnPage(color.raw) ? `<div class="btn-color-check" data-balloon="active on the page" data-balloon-pos="right"><i class="fas fa-check"></i></i></div></div>` : '</div>';
            content += `<div class="brxc-color-type-toggle${isVariableOnly ? ' active' : ''}" data-balloon="${isVariableOnly ? 'variable' : 'color'}" data-balloon-pos="top">${isVariableOnly ? 'V' : 'C'}</div>`
            content += `<input type="text" class="color-name${hasRaw && !hasRawValue && isFramework && self.colorStates.colorManagerMode === "dark" ? ' inactive':''}" value="${color.name}" />`;
            content += `<div class="actions">`;

            if (isVariableOnly){
                content += `<div class="brxc-icon" data-balloon="Rename" data-balloon-pos="bottom-right" onClick="ADMINBRXC.renameColor(event,'${color.id}','${color.name}');"><span class="bricks-svg-wrapper"><i class="fas fa-pen"></i></span></div>
                            <div class="brxc-icon" data-balloon="Duplicate" data-balloon-pos="bottom-right" onClick="ADMINBRXC.duplicateColor('${color.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-clone"></i></span></div>
                            <div class="brxc-icon" data-balloon="Copy to Clipboard" data-balloon-pos="bottom-right" onClick="ADMINBRXC.copytoClipboardSimple('${color.raw}','${color.raw} successfully copied to clipboard');"><span class="bricks-svg-wrapper"><i class="fas fa-clipboard"></i></span></div>
                            <div class="brxc-icon" data-balloon="Delete" data-balloon-pos="bottom-right" onClick="ADMINBRXC.setDeleteColor('${color.id}', this)"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
            } else if(hasRaw && hasRawValue && !isFramework){
                content += `<div class="brxc-icon" data-balloon="Rename" data-balloon-pos="bottom-right" onClick="ADMINBRXC.renameColor(event,'${color.id}','${color.name}');"><span class="bricks-svg-wrapper"><i class="fas fa-pen"></i></span></div>`;
                if(self.colorStates.colorManagerMode === "light" && !isShade) content += `<div class="brxc-icon${self.colorStates.colorManagerComplementaryPopup === true && self.colorStates.colorManagerComplementaryPopupId === color.id ? ' active' : ''}" data-balloon="Generate Complementary Colors" data-balloon-pos="bottom-right" onClick='ADMINBRXC.colorStates.activeColor = ${JSON.stringify(color)};ADMINBRXC.setComplementaryWrapper("${self.colorStates.colorManagerComplementaryPopup}","${color.id}");'><span class="bricks-svg-wrapper"><i class="fas fa-palette"></i></span></div>`;
                if(self.colorStates.colorManagerMode === "light" && !isShade) content += `<div class="brxc-icon${self.colorStates.colorManagerShadePopup === true && self.colorStates.colorManagerShadePopupId === color.id ? ' active' : ''}" data-balloon="Generate Shades" data-balloon-pos="bottom-right" onClick='ADMINBRXC.colorStates.activeColor = ${JSON.stringify(color)};ADMINBRXC.setShadesWrapper("${self.colorStates.colorManagerShadePopup}","${color.id}");'><span class="bricks-svg-wrapper"><i class="fas fa-wand-magic-sparkles"></i></span></div>`;
                content += `<div class="brxc-icon${color.colorProperty ? ' active' : ''}" data-balloon="Add @property declarations" data-balloon-pos="bottom-right" onClick="ADMINBRXC.toggleColorProperty('${color.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-at"></i></span></div>`;
                if(self.colorStates.colorManagerMode === "dark") content += `<div class="brxc-icon" data-balloon="Convert to Dark Color" data-balloon-pos="bottom-right" onClick="ADMINBRXC.convertDarkColor('${color.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-right-left"></i></span></div>`;
                content += `<div class="brxc-icon" data-balloon="Duplicate" data-balloon-pos="bottom-right" onClick="ADMINBRXC.duplicateColor('${color.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-clone"></i></span></div>
                            <div class="brxc-icon" data-balloon="Copy to Clipboard" data-balloon-pos="bottom-right" onClick="ADMINBRXC.copytoClipboardSimple('${color.raw}','${color.raw} successfully copied to clipboard');"><span class="bricks-svg-wrapper"><i class="fas fa-clipboard"></i></span></div>
                            <div class="brxc-icon" data-balloon="Delete" data-balloon-pos="bottom-right" onClick="ADMINBRXC.setDeleteColor('${color.id}', this)"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
            } else if(hasRaw && hasRawValue && isFramework && self.colorStates.colorManagerMode === "dark"){
                content += `<div class="brxc-icon" data-balloon="Remove Dark Color" data-balloon-pos="bottom-right" onClick="ADMINBRXC.removeRawValue('${color.id}', this)"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
            } else if(!hasRaw && !isFramework){
                content += `<div class="brxc-icon" data-balloon="Convert to a CSS variable" data-balloon-pos="left" onClick="ADMINBRXC.convertColor('${color.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-right-left"></i></span></div>`;
            } else if(hasRaw && isFramework){
                content += `<div class="brxc-icon" data-balloon="Copy to Clipboard" data-balloon-pos="bottom-right" onClick="ADMINBRXC.copytoClipboardSimple('${color.raw}','${color.raw} successfully copied to clipboard');"><span class="bricks-svg-wrapper"><i class="fas fa-clipboard"></i></span></div>`;
            }

            content += `</div>`;

            if(color.hasOwnProperty('shadeChildren') && Array.isArray(color.shadeChildren) && color.shadeChildren.length > 0){
                content += `<div class="actions always-visible">`;
                content += `<div class="brxc-icon" data-balloon="${color.hasOwnProperty('isExpanded') && color.isExpanded === true ? 'Hide' : 'Show'} Shades" data-balloon-pos="bottom-right" onClick="ADMINBRXC.toggleExpandShades('${color.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-${color.hasOwnProperty('isExpanded') && color.isExpanded === true ? 'minus' : 'plus'}"></i></span></div>`;
                content += `</div>`;
            } else if(color.hasOwnProperty('shadeParent') && color.shadeParent){
                content += `<div class="actions always-visible">`;
                content += `<div class="brxc-icon links${!color.hasOwnProperty('isShade') || color.isShade !== true ? ' unlinked' : ''}" data-balloon="${color.hasOwnProperty('isShade') && color.isShade === true ? 'Unlink' : 'Link'} to parent color" data-balloon-pos="bottom-right" onClick="ADMINBRXC.toggleLinkShades('${color.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-${color.hasOwnProperty('isShade') && color.isShade === true ? 'link' : 'link-slash'}"></i></span></div>`;
                content += `</div>`;
            }

            content += `</div>`;
            // Shade popup
            if(self.colorStates.colorManagerShadePopup === true && self.colorStates.colorManagerShadePopupId === color.id){
                content += self.setShadesForm(color.id);
            }

            // Complementary popup
            if(self.colorStates.colorManagerComplementaryPopup === true && self.colorStates.colorManagerComplementaryPopupId === color.id){
                content += self.setComplementaryForm(color.id);
            }
            content += `</li>`;
            ind++;
        }

        content += '</ul>';
        if(!self.helpers.isFramework(activePalette.id)) {
            content += `<div class="brxc-add-color-wrapper">`;
            content += `<div class="brxc-import-css-colors${self.colorStates.colorManagerImportCSSVariables === true ? ' active' : ''}" data-balloon="Import CSS variables" data-balloon-pos="bottom-left" onclick="ADMINBRXC.toggleImportColorVariables('${self.colorStates.colorManagerImportCSSVariables === true ? 'true' : 'false'}');"><i class="fas fa-code"></i></div> `;
            content += self.colorStates.colorManagerImportCSSVariables === true ? `<textarea id="addNewColorCSS" rows="20" placeholder="Paste your CSS variables here"></textarea>` : `<input type="text" id="addNewColor" placeholder="Add a new color" onkeyup="ADMINBRXC.addNewColor(event);" />`;
            content += `</div>`;
            if(self.colorStates.colorManagerImportCSSVariables === true){
                content += `<div id="brxcImportVariableWrapper">
                                <div class="gridUI__input-wrapper">
                                    <label class="has-tooltip">
                                        <span>Import as Variables?</span>
                                        <div data-balloon="Toggle this option if you're importing variables that are defined elsewhere, but want them selectable inside the Variable Picker." data-balloon-pos="top" data-balloon-length="medium">
                                            <i class="fas fa-circle-question"></i>
                                        </div>
                                    </label>
                                    <i class="fas fa-toggle-${self.colorStates.colorManagerImportCSSVariablesskipValues === true ? 'on' : 'off'}" onClick="ADMINBRXC.colorStates.colorManagerImportCSSVariablesskipValues = !ADMINBRXC.colorStates.colorManagerImportCSSVariablesskipValues;ADMINBRXC.setColorManager();"></i>
                                </div>
                                <a class="brxc-overlay__action-btn primary" onclick="ADMINBRXC.importColorVariables();"><span>Import Colors</span></a>
                            </div>`;
            }
            
        }
        canvas.innerHTML = content;

        // Color Type Toggle
        const toggleTypes = canvas.querySelectorAll('.brxc-color-type-toggle')
        if(toggleTypes.length > 0){
            toggleTypes.forEach(el => {
                el.addEventListener('click', () => {
                    const colorId = el.parentElement.parentElement.dataset.id;
                    const palettes = self.vueState.colorPalette;
                    const activePalette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id === self.colorStates.activePalette);
                    if(!activePalette) return;
                    const colorObj = activePalette.colors.find(el => el && el.id === colorId);
                    if(!colorObj) return;
                    colorObj.hasOwnProperty('isVariableOnly') && colorObj.isVariableOnly ? delete colorObj.isVariableOnly : colorObj.isVariableOnly = true;
                    
                    // Regenerate Colors and rerender
                    self.generateColorCSS();
                    self.generateBuilderCSS();
                    self.setColorManager();
                })
            })
        }
        // Color Picker
        const btnMain = canvas.querySelectorAll('li .brxc-color-input.main-color');
        btnMain.forEach(el => {
            const mode = self.colorStates.colorManagerMode;
            let picker = new ColorPicker(el, el.dataset.initialColor);
    
      
            el.addEventListener('colorChange', self.debounce((event) => {
                const colorPickr = document.querySelector('#color_picker');
                const display = window.getComputedStyle(colorPickr).getPropertyValue("display");
                if(display && display === "none") self.setColorManagerBody();
                const color = event.detail.color.hsla;
                self.updateColor(color, event.target.dataset.id, mode);
            }, 100))
        })

        if(self.colorStates.colorManagerShadePopup === true) self.setScalePicker();

        //Drag and drop
        if(self.colorStates.colorManagerShadePopup !== true){
            const colorWrapper = canvas.querySelector('ul');

            new Sortable(colorWrapper, {
                multiDrag: true,
                selectedClass: "sortable-selected",
                animation: 150,
                handle: "li .handle",
                helper : 'clone',
                onEnd: function () {
                    const items = Array.from(colorWrapper.children).filter(el => el.dataset.parent === "true");
                    let index = 0;
                    items.forEach((item) => {
                        const target = Array.from(activePalette.colors).find(el => el && el.hasOwnProperty('id') && el.id === item.dataset.id);
                        if (!target) return;
    
                        self.helpers.moveArr(activePalette.colors, activePalette.colors.indexOf(target), index);
                        index++;
                        const children = Array.from(activePalette.colors).filter(el => el.hasOwnProperty('isShade') && el.isShade === true && el.shadeParent === target.id);
                        if(!children || children.length == 0) return;

                        children.forEach(child => {
                            self.helpers.moveArr(activePalette.colors, activePalette.colors.indexOf(child), index);
                            index++;
                        })
                    });

    
                    self.vueGlobalProp.$_showMessage('Color order successfully changed');
                    self.setColorManager();
                    self.helpers.saveChanges('colorPalette');
                    
                },
            })
        }

        // close when clicked outside
        const popup = document.querySelector('.bricks-control-popup');

        function closePopup() {
            document.removeEventListener('click', clickOutsideHandler);
        }

        function clickOutsideHandler(event) {
            if (!popup.contains(event.target)) {
                closePopup();
            }
        }
        function openPopup() {
            document.addEventListener('click', clickOutsideHandler);
        }
        if (popup) openPopup();

        // Reset values
        self.colorStates.colorManagerShadePopup = false;
        self.colorStates.colorManagerShadePopupId = false;
        self.colorStates.colorManagerComplementaryPopup = false;
        self.colorStates.colorManagerComplementaryPopupId = false;
        
    },
    toggleColorProperty: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);

        color.colorProperty = color.colorProperty === true ? false : true;
        self.setColorManagerBody();
    },
    toggleLinkShades: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        if(!color.hasOwnProperty('isShade')) return;
        color.isShade === true ? color.isShade = false : color.isShade = true;
        self.setColorManagerBody();
    },
    toggleExpandShades: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        if(!color.hasOwnProperty('isExpanded')) return;
        color.isExpanded === true ? color.isExpanded = false : color.isExpanded = true;
        self.setColorManagerBody();
    },
    toggleImportColorVariables: function(importCSS){
        const self = this;
        importCSS === 'true' ? self.colorStates.colorManagerImportCSSVariables = false : self.colorStates.colorManagerImportCSSVariables = true;
        self.setColorManagerBody();

    },
    importColorVariables: function(){
        const self = this;
        const value = document.querySelector('#addNewColorCSS').value;
        const cssVariablePattern = /(--[\w-]+):\s*([^;]+);/g;
        const parsedValue = value ? value.replaceAll('\n', '') : false;
        if (!parsedValue || parsedValue.length < 1) return;

        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)


        let incorrectColor = 0;
        let importedColors = 0;

        const matches = parsedValue.match(cssVariablePattern);
        if(!matches || !Array.isArray(matches) || matches.length < 1) return self.vueGlobalProp.$_showMessage(`No Matching Colors found`);

        matches.forEach(match => {
            const matchResult = match.match(cssVariablePattern);
            const split = matchResult[0].split(':');
            const name = split[0].substr(2);
            const value = split[1] ? split[1].trimStart().replaceAll(';', '') : false;
            let newColor = '';
            if (!self.colorStates.colorManagerImportCSSVariablesskipValues && !chroma.valid(value)) return incorrectColor++;

            const formattedName = self.helpers.formatForClasses(name);
            const raw = `var(--${self.helpers.setColorPrefix(formattedName, self.helpers.isFramework(false))})`;
            const id = self.vueGlobalProp.$_generateId();
            if(self.colorStates.colorManagerImportCSSVariablesskipValues){
                newColor = {
                    id: id,
                    name: formattedName,
                    raw: raw,
                    rawValue: {
                        light: '#fff',
                    },
                    isVariableOnly: true,
                    isExpanded: true,
                    shadeChildren: [],
                    complementaryChildren: [],
                };

            } else {
                const lightness = chroma(value).get('hsl', 'l');
                const colorDark = lightness ? chroma(value).set('hsl.l', 1 - lightness[2]).css('hsla') : false;

                newColor = {
                    id: id,
                    name: formattedName,
                    raw: raw,
                    rawValue: {
                        light: value,
                    },
                    isExpanded: true,
                    shadeChildren: [],
                    complementaryChildren: [],
                };

                colorDark ? (newColor.rawValue.dark = colorDark) : '';
            }
            palette.colors.push(newColor);
            importedColors++;
        });

        
        // Message
        if(importedColors === 0 && incorrectColor > 0){
            self.vueGlobalProp.$_showMessage(`No Matching Colors found<br>${incorrectColor} variables have been skipped due to incorrect color format`);
        } else if(importedColors === 0){
            self.vueGlobalProp.$_showMessage(`No Matching Colors found`);
        } else if(importedColors > 0 && incorrectColor > 0){
            self.vueGlobalProp.$_showMessage(`${importedColors} Colors have been successfully imported<br>${incorrectColor} variables have been skipped due to incorrect color format`);
        } else {
            self.vueGlobalProp.$_showMessage(`${importedColors} Colors have been successfully imported`);
        }

        setTimeout(() => {
            self.setColorManagerSearch();
            self.setColorManagerBody();
            self.generateColorCSS();
            self.generateBuilderCSS();
        }, 10);
    },

    convertColor: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const obj = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        
        let col = '';
        ['hex','rgb','hsl'].forEach(format => {
            if(obj.hasOwnProperty(format)){
                col = obj[format];
                delete obj[format];
            }
        })
        obj.name = self.helpers.formatForClasses(obj.name)
        obj.raw = `var(--${self.helpers.setColorPrefix(obj.name, self.helpers.isFramework(obj.id))})`;
        obj.rawValue = {
            light: col
        }

        self.generateColorCSS();
        self.generateBuilderCSS();
        self.setColorManagerBody();


    },
    convertDarkColor: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const obj = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);

        const lightColor = (obj.hasOwnProperty('rawValue') && obj.rawValue.hasOwnProperty('light')) ? chroma(obj.rawValue.light).get('hsl.l') : false;
        if (lightColor) obj.rawValue.dark = chroma(obj.rawValue.light).set('hsl.l', 1 - lightColor).css('hsla');;

        self.generateColorCSS();
        self.generateBuilderCSS();
        self.setColorManagerBody();
    },
    resetStates: function(){
        const self = this;
        //self.colorStates.colorManagerShadeNumber = 6,
        self.colorStates.colorManagerShadeBaseName = false;
        const mode = self.colorStates.colorManagerMode;
        if (self.colorStates.activeColor.hasOwnProperty('raw') && self.colorStates.activeColor.hasOwnProperty('rawValue') && self.colorStates.activeColor.rawValue.hasOwnProperty(mode)) self.colorStates.colorManagerShadeColors = [self.colorStates.activeColor.rawValue[mode]];
        self.colorStates.colorManagerShadeFinalColors = ['#ffffff'];
    },
    shadesSlider: function(event){
        const self = this;
        self.colorStates.colorManagerShadeNumber = parseInt(event.target.value);;
        self.setDynamicScaleCanvas();
    },
    addPreviousScaleColor: function(){
        const self = this;
        self.colorStates.colorManagerShadeColors.unshift(self.colorStates.colorManagerShadeColors[0]);
        const canvasScale = document.querySelector('#scaleCanvas');
        canvasScale.innerHTML = self.setColorScale();
        const canvasPreview = document.querySelector('#previewCanvas');
        canvasPreview.innerHTML = self.setColorPreview();
        self.setScalePicker();
    },
    addNextScaleColor: function(){
        const self = this;
        self.colorStates.colorManagerShadeColors.push(self.colorStates.colorManagerShadeColors[self.colorStates.colorManagerShadeColors.length - 1]);
        const canvasScale = document.querySelector('#scaleCanvas');
        canvasScale.innerHTML = self.setColorScale();
        const canvasPreview = document.querySelector('#previewCanvas');
        canvasPreview.innerHTML = self.setColorPreview();
        self.setScalePicker();
    },
    setScalePicker: function(){
        const self = this;
        const canvas = document.querySelector('#scaleCanvas');
        if(!canvas) return;
        const btnScales = canvas.querySelectorAll('.scale-color');
        if(!btnScales) return;

        // Picker
        btnScales.forEach(el => {
            let picker = new ColorPicker(el, el.dataset.initialColor);
            el.addEventListener('colorChange', self.debounce((event) => {
                const color = event.detail.color.hsla;
                self.colorStates.colorManagerShadeColors[el.dataset.index] = color;
                const canvasPreview = document.querySelector('#previewCanvas');
                canvasPreview.innerHTML = self.setColorPreview();
            }, 100))
        })

        //Drag and drop
        const scaleWrapper = canvas.querySelector('.scale-wrapper');

        new Sortable(scaleWrapper, {
            animation: 150,
            handle: ".scale-color",
            helper : 'clone',
            onEnd: function (evt) {
                if(evt.oldIndex !== evt.newIndex){
                    self.helpers.moveArr(self.colorStates.colorManagerShadeColors, evt.oldIndex -1, evt.newIndex -1);
                    const canvasPreview = document.querySelector('#previewCanvas');
                    canvasPreview.innerHTML = self.setColorPreview();
                }
            },
        })
    },
    deleteScaleColor: function(btn){
        const self = this;
        const index = Array.from(document.querySelectorAll('.brxc-color-input.scale-color')).indexOf(btn)
        self.colorStates.colorManagerShadeColors.splice(index, 1);
        const canvasScale = document.querySelector('#scaleCanvas');
        canvasScale.innerHTML = self.setColorScale();
        const canvasPreview = document.querySelector('#previewCanvas');
        canvasPreview.innerHTML = self.setColorPreview();
        self.setScalePicker();
    },
    setColorScale: function(){
        const self = this;
        let content = '';
        content += `<div class="control-inner control-inline">`;
        content += `<label class="has-tooltip"><span>Color Scale</span><div data-balloon="Choose the colors that compose the color scale." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="scale-wrapper">`;
        content += `<div class="dotted-border" data-balloon="Add previous color" data-balloon-pos="top-left" onclick="ADMINBRXC.addPreviousScaleColor();"><i class="fas fa-plus"></i></div>`;
        index = 0;
        self.colorStates.colorManagerShadeColors.forEach(color => {
            content += `<button class="brxc-color-input scale-color" data-index="${index}" data-initial-color="${color}" style="background:${color};">`;
            if(self.colorStates.colorManagerShadeColors.length > 1) content += `<div class="delete-scale-color" data-balloon="Delete" data-balloon-pos="top" onclick="event.preventDefault();event.stopPropagation();ADMINBRXC.deleteScaleColor(this.parentElement);"><i class="fas fa-xmark"></i></div>`;
            content += `</button>`
            index++;
        })
        content += `<div class="dotted-border" data-balloon="Add next color" data-balloon-pos="top-right" onclick="ADMINBRXC.addNextScaleColor();"><i class="fas fa-plus"></i></div>`;
        content += `</div></div>`;
        return content;

    },
    changeColorScheme: function(){
        const self = this;
        const canvas = document.querySelector('#previewComplementaryCanvas');
        canvas.innerHTML = self.setComplementaryColorPreview();

    },
    setColorPreview: function(){
        const self = this;
        const mode = self.colorStates.colorManagerMode;
        
        let content = '';
        content += `<div class="control-inner control-inline">`;
        content += `<label class="has-tooltip"><span>Preview</span><div data-balloon="Here is the preview of the shades that will be created." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="color-btn-wrapper">`;
        if (self.colorStates.activeColor.hasOwnProperty('raw') && self.colorStates.activeColor.hasOwnProperty('rawValue') && self.colorStates.activeColor.rawValue.hasOwnProperty(mode)) self.colorStates.colorManagerShadeColors.unshift(self.colorStates.activeColor.rawValue[mode]);
        const colors = chroma.scale(self.colorStates.colorManagerShadeColors)
                            .colors(parseInt(self.colorStates.colorManagerShadeNumber) + 1);
        let ind = 0;
        colors.forEach(color => {
            colors[ind] = chroma(color).css('hsl');
            ind++;
        })
        colors.shift();
        self.colorStates.colorManagerShadeFinalColors = colors;
        self.colorStates.colorManagerShadeColors.shift();
        let index = 0;
        colors.forEach(color => {
            content += `<button class="scale-color" data-index="${index}" data-initial-color="${color}" data-balloon="${color}" data-balloon-pos="top" style="background:${color};"></button>`;
            index++;
        })
        content += `</div></div>`;
        return content;
    },
    setDynamicScaleCanvas: function(){
        const self = this;
        const canvas = document.querySelector('#dynamicScaleCanvas');
        if(!canvas) return;
        canvas.innerHTML = self.dynamicScaleCanvas(self.colorStates.activeColor.id);
        self.setScalePicker();
    },
    dynamicScaleCanvas: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        let content = `<div class="brxc-overlay__panel-inline-btns-wrapper" style="margin-top:16px;">
                            <input type="radio" id="brxc-custom-shade-toggle-auto" name="brxc-custom-shade-toggle" class="brxc-input__checkbox" value="0" onclick="ADMINBRXC.colorStates.colorManagerShadeCustom = false;ADMINBRXC.colorStates.colorManagerShadePopup = true;ADMINBRXC.colorStates.colorManagerShadePopupId = '${colorId}';ADMINBRXC.setDynamicScaleCanvas();"${self.colorStates.colorManagerShadeCustom !== true ? ' checked=""' : ''}>
                            <label for="brxc-custom-shade-toggle-auto" class="brxc-overlay__panel-inline-btns">Auto-Shades</label>
                            <input type="radio" id="brxc-custom-shade-toggle-custom" name="brxc-custom-shade-toggle" class="brxc-input__checkbox" value="1" onclick="ADMINBRXC.colorStates.colorManagerShadeCustom = true;ADMINBRXC.colorStates.colorManagerShadePopup = true;ADMINBRXC.colorStates.colorManagerShadePopupId = '${colorId}';ADMINBRXC.setDynamicScaleCanvas();"${self.colorStates.colorManagerShadeCustom === true ? ' checked=""' : ''}>
                            <label for="brxc-custom-shade-toggle-custom" class="brxc-overlay__panel-inline-btns">Custom Scales</label>
                        </div>`;
        if(self.colorStates.colorManagerShadeCustom !== true){
            let showButton = false;
            const children = Array.from(palette.colors).filter(el => el && el.hasOwnProperty('shadeParent') && el.shadeParent === colorId);
            const lightChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeType') && el.shadeType === "Light") : false;
            const darkChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeType') && el.shadeType === "Dark") : false;
            const transparentChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeType') && el.shadeType === "Transparent") : false;
            
            // Light
            if(!lightChildren || lightChildren.length === 0){
                self.colorStates.colorManagerShadeLightValid = true;
                const lightEnabled = self.colorStates.colorManagerShadeLight;
                showButton = true;
                    content += `<div class="control-inner control-inline">
                                    <label class="has-tooltip"><span>Generate Light Shades<div data-balloon="Generate lighter versions of the current color. The script will generate the shades up to 95% of the color's lightness." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></span></label>
                                    <div class="" onclick="ADMINBRXC.toggleAutoShade('Light')"><i class="fas fa-toggle-${lightEnabled ? 'on' : 'off'}"></i></div>
                                </div>`;
                if(lightEnabled){
                    content += self.setAutoShadePreview('Light');
                }
            } else {
                self.colorStates.colorManagerShadeLightValid = false;
                self.colorStates.colorManagerShadeLight = true;
                    content += `<div class="control-inner control-inline">
                                    <label class="has-tooltip"><span>Generate Light Shades</span><div data-balloon="Generate lighter versions of the current color. The script will generate the shades up to 95% of the color's lightness." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                                    <div><i class="fas fa-toggle-off"></i></div>
                                </div>
                                <div><span class="existing-shades-message">Light shades have already been generated for this color. Remove the existing shades to generate new ones.</span></div>`;                
            }

            // Dark

            if(!darkChildren|| darkChildren.length === 0){
                self.colorStates.colorManagerShadeDarkValid = true;
                const darkEnabled = self.colorStates.colorManagerShadeDark;
                showButton = true;
                    content += `<div class="control-inner control-inline">
                                    <label class="has-tooltip"><span>Generate Dark Shades</span><div data-balloon="Generate darker versions of the current color. The script will generate the shades up to 5% of the color's lightness." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                                    <div class="" onclick="ADMINBRXC.toggleAutoShade('Dark')"><i class="fas fa-toggle-${darkEnabled ? 'on' : 'off'}"></i></div>
                                </div>`;
                if(darkEnabled){
                    content += self.setAutoShadePreview('Dark');
                }
            } else {
                self.colorStates.colorManagerShadeDarkValid = false;
                self.colorStates.colorManagerShadeDark = true;
                    content += `<div class="control-inner control-inline">
                                    <label class="has-tooltip"><span>Generate Dark Shades</span><div data-balloon="Generate darker versions of the current color. The script will generate the shades up to 5% of the color's lightness." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                                    <div><i class="fas fa-toggle-off"></i></div>
                                </div>
                                <div><span class="existing-shades-message">Dark shades have already been generated for this color. Remove the existing shades to generate new ones.</span></div>`;    
            }

            if(!transparentChildren || transparentChildren.length === 0){
                self.colorStates.colorManagerShadeTransparentValid = true;
                const transparentEnabled = self.colorStates.colorManagerShadeTransparent;
                showButton = true;
                    content += `<div class="control-inner control-inline">
                                    <label class="has-tooltip"><span>Generate Transparent Shades</span><div data-balloon="Generate transparent versions of the current color. The script will generate the shades up to 5% of the color's transparency." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                                    <div class="" onclick="ADMINBRXC.toggleAutoShade('Transparent')"><i class="fas fa-toggle-${transparentEnabled ? 'on' : 'off'}"></i></div>
                                </div>`;
                if(transparentEnabled){
                    content += self.setAutoShadePreview('Transparent');
                }
            } else {
                self.colorStates.colorManagerShadeTransparentValid = false;
                self.colorStates.colorManagerShadeTransparent = true;
                    content += `<div class="control-inner control-inline">
                                    <label class="has-tooltip"><span>Generate Transparent Shades</span><div data-balloon="Generate transparent versions of the current color. The script will generate the shades up to 5% of the color's transparency." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                                    <div><i class="fas fa-toggle-off"></i></div>
                                </div>
                                <div><span class="existing-shades-message">Transparent shades have already been generated for this color. Remove the existing shades to generate new ones.</span></div>`;
            }
            content += showButton ? `<a class="brxc-overlay__action-btn primary" style="margin-top:16px;" onclick="ADMINBRXC.generateShades('${color.id}');"><span>Generate Shades</span></a>` : '';
            
        } else {
            const children = Array.from(palette.colors).filter(el => el && el.hasOwnProperty('shadeParent') && el.shadeParent === colorId);
            const customChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeMode') && el.shadeMode === "custom") : false;

            if(!customChildren || customChildren.length === 0){
                    content += `<div class="control-inner control-inline">
                                <label class="has-tooltip"><span>Base Name</span><div data-balloon="For example, the base name of 'primary-l-1' is 'primary-l-'" data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                                <input id="nameInput" type="text" value="${color.name}-" oninput="ADMINBRXC.colorStates.colorManagerShadeBaseName = event.target.value;">
                            </div>`;
                    content += `<div id="scaleCanvas">${self.setColorScale()}</div>`;
                    content += `<div id="previewCanvas">${self.setColorPreview(color.id)}</div>`;
                    content += `<a class="brxc-overlay__action-btn primary" style="margin-top:16px;" onclick="ADMINBRXC.generateShades('${color.id}');"><span>Generate Scale</span></a>`;
            } else {
                    content += `<div><span class="existing-shades-message">A custom scale has already been generated for this color. Remove the existing scale to generate new ones.</span></div>`;
            }
        }
        return content;
    },
    setShadesForm: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);

        let content = `<div class="shade-form">`;
        content += `<div class="brxc-shade-wrapper bricks-control-popup bottom">
                        <div class="control-inner control-inline">
                            <label for="numberShades" class="has-tooltip"><span>Num Shades</span><div data-balloon="The number of shades you want to create." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            <div class="brxc__range">
                                <input type="range" min="2" max="20" step="1" value="${self.colorStates.colorManagerShadeNumber}" name="numberShades" id="numberShades" class="brxc-input__range" oninput="ADMINBRXC.shadesSlider(event);document.querySelector('#numberShadesValue').value = parseInt(event.target.value);">
                                <input type="number" min="2" max="20" id="numberShadesValue" value="${self.colorStates.colorManagerShadeNumber}" oninput="ADMINBRXC.shadesSlider(event);document.querySelector('#numberShades').value = parseInt(event.target.value);">
                            </div>
                        </div>
                        <div id="dynamicScaleCanvas">${self.dynamicScaleCanvas(colorId)}</div>`;
        content += `</div></div>`;

        return content;

    },
    toggleAutoShade: function(mode){
        const self = this;
        if(mode === "Light"){
            self.colorStates.colorManagerShadeLight === true ? self.colorStates.colorManagerShadeLight = false : self.colorStates.colorManagerShadeLight = true;
        } else if(mode === "Dark"){
            self.colorStates.colorManagerShadeDark === true ? self.colorStates.colorManagerShadeDark = false : self.colorStates.colorManagerShadeDark = true;
        } else if(mode === "Transparent"){
            self.colorStates.colorManagerShadeTransparent === true ? self.colorStates.colorManagerShadeTransparent = false : self.colorStates.colorManagerShadeTransparent = true;
        }
        self.setDynamicScaleCanvas();
    },
    setAutoShadePreview: function(mode){
        const self = this;
        const activeColor = self.colorStates.activeColor.rawValue.light;
        let targetColor;
        if(mode === 'Light') targetColor = chroma(activeColor).set('hsl.l', 0.98).css('hsla');
        if(mode === 'Dark') targetColor = chroma(activeColor).set('hsl.l', 0.05).css('hsla');
        if(mode === 'Transparent') targetColor = chroma(activeColor).alpha(0.05).css('hsla');
        const colors = chroma.scale([activeColor, targetColor])
                        .correctLightness()
                        .colors(parseInt(self.colorStates.colorManagerShadeNumber) + 1);
        let ind = 0;
        colors.forEach(color => {
            colors[ind] = chroma(color).css('hsla');
            ind++;
        })
        colors.shift();
        let content = `<div class="control-inner control-inline">
                            <label class="has-tooltip"><span>Preview ${mode} Shades</span><div data-balloon="Here is the preview of the shades that will be created." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            <div class="color-btn-wrapper">`;
                            colors.forEach(el => {
                                content += `<button class="scale-color" data-index="0" data-initial-color="${el}" data-balloon="${el}" data-balloon-pos="top" style="background:${el};"></button>`;
                            })
        content += `</div></div>`;
        return content;
    },
    setComplementaryColorPreview: function(){
        const self = this;
        const mode = self.colorStates.colorManagerMode;
        const activeColor = (self.colorStates.activeColor.hasOwnProperty('raw') && self.colorStates.activeColor.hasOwnProperty('rawValue') && self.colorStates.activeColor.rawValue.hasOwnProperty(mode)) ? self.colorStates.activeColor.rawValue[mode] : false;
        if(!activeColor) return;
        const hue = parseInt(chroma(activeColor).get('hsl', 'h'))

        let content = '';
        content += `<div class="control-inner control-inline">`;
        content += `<label class="has-tooltip"><span>Preview</span><div data-balloon="Here is the preview of the complementary colors that will be created." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="color-btn-wrapper">`;
    
        self.colorStates.colorManagerComplementaryFinalColors = [];

        // Contrast
        if(self.colorStates.colorManagerComplementaryScheme === 'complementary'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 180).css('hsla'));
        }

        // Split-Complementary
        if(self.colorStates.colorManagerComplementaryScheme === 'split-complementary'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 150).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 210).css('hsla'));
        }

        // Triade
        if(self.colorStates.colorManagerComplementaryScheme === 'triade'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 120).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 240).css('hsla'));
        }

        // Tetrade
        if(self.colorStates.colorManagerComplementaryScheme === 'tetrade'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 90).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 180).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 270).css('hsla'));
        }

        // Split-Tetradic
        if(self.colorStates.colorManagerComplementaryScheme === 'split-tetradic'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 60).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 180).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 240).css('hsla'));
        }

        // Quadratic
        if(self.colorStates.colorManagerComplementaryScheme === 'quadratic'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 120).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 240).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 300).css('hsla'));
        }

        // Compound
        if(self.colorStates.colorManagerComplementaryScheme === 'compound'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 60).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 180).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 300).css('hsla'));
        }

        // Analogous
        if(self.colorStates.colorManagerComplementaryScheme === 'analogous'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 30).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 60).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 90).css('hsla'));
        }

        // Split-Analogous
        if(self.colorStates.colorManagerComplementaryScheme === 'split-analogous'){
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 30).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 60).css('hsla'));
            self.colorStates.colorManagerComplementaryFinalColors.push(chroma(activeColor).set('hsl.h', hue + 150).css('hsla'));
        }

        self.colorStates.colorManagerComplementaryFinalColors.forEach(color => {
            content += `<button class="scale-color" data-initial-color="${color}" data-balloon="${color}" data-balloon-pos="top" style="background:${color};"></button>`;
        })
        content += `</div></div>`;
        return content;
    },
    setComplementaryForm: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);

        let content = `<div class="complementary-form">`;
        content += `<div class="brxc-shade-wrapper bricks-control-popup bottom">
                        <div class="control-inner control-inline">
                            <label class="has-tooltip"><span>Base Name</span><div data-balloon="For example, the base name of 'primary-l-1' is 'primary-l-'" data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            <input id="nameInput" type="text" value="${color.name}-" oninput="ADMINBRXC.colorStates.colorManagerComplementaryBaseName = event.target.value;">
                        </div>
                        <div class="control-inner control-inline">
                            <label for="Scheme" class="has-tooltip"><span>Scheme</span><div data-balloon="The color scheme you want to create." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            <div class="brxc-select">
                                <select value="${self.colorStates.colorManagerComplementaryScheme}" name="Scheme" id="Scheme" onchange="ADMINBRXC.colorStates.colorManagerComplementaryScheme = this.value;ADMINBRXC.changeColorScheme('${colorId}');">
                                    <option value="complementary"${self.colorStates.colorManagerComplementaryScheme === "complementary" ? ' selected':''}>Complementary</option>
                                    <option value="split-complementary"${self.colorStates.colorManagerComplementaryScheme === "split-complementary" ? ' selected':''}>Split-Complementary</option>
                                    <option value="triade"${self.colorStates.colorManagerComplementaryScheme === "triade" ? ' selected':''}>Perfect Triad</option>
                                    <option value="tetrade"${self.colorStates.colorManagerComplementaryScheme === "tetrade" ? ' selected':''}>Tetrade</option>
                                    <option value="split-tetradic"${self.colorStates.colorManagerComplementaryScheme === "split-tetradic" ? ' selected':''}>Split-Tetradic</option>
                                    <option value="quadratic"${self.colorStates.colorManagerComplementaryScheme === "quadratic" ? ' selected':''}>Quadratic</option>
                                    <option value="compound"${self.colorStates.colorManagerComplementaryScheme === "compound" ? ' selected':''}>Compound</option>
                                    <option value="analogous"${self.colorStates.colorManagerComplementaryScheme === "analogous" ? ' selected':''}>Analogous</option>
                                    <option value="split-analogous"${self.colorStates.colorManagerComplementaryScheme === "split-analogous" ? ' selected':''}>Split-Analogous</option>
                                </select>
                            </div>
                        </div>`;
        content += `<div id="previewComplementaryCanvas">${self.setComplementaryColorPreview(color.id)}</div>`;
        content += `<a class="brxc-overlay__action-btn primary" style="margin-top:16px;" onclick="ADMINBRXC.generateComplementary('${color.id}');"><span>Generate Colors</span></a>`;
        content += `</div></div>`;

        return content;

    },
    generateShades: function(colorId){
        const self = this;
        if(self.colorStates.colorManagerShadeCustom === true){
            self.generateCustomShades(colorId);
        } else {
            self.generateAutoShades(colorId);
        }
    },
    generateCustomShades: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);

        if(!color) return;

        let colorOrder = parseInt(palette.colors.indexOf(color));

        color.shadeArray = self.colorStates.colorManagerShadeColors;
        self.colorStates.colorManagerShadeFinalColors.forEach((el,index) => {
            function setSufix(name, number){
                const exist = Array.from(palette.colors).find(el => el && el.hasOwnProperty('name') && el.name === `${name}${number}`);
                if(!exist) return `${name}${number}`;
                number++;
                return setSufix(name, number);
            }
            const lightness = chroma(el).get('hsl', 'l');
            const elDark = chroma(el).set('hsl.l', 1 - lightness[2]).css('hsla');
            let name = (self.colorStates.colorManagerShadeBaseName) ? self.colorStates.colorManagerShadeBaseName : `${color.name}-`;
            name = setSufix(self.helpers.formatForClasses(name), 1);
            const id = self.vueGlobalProp.$_generateId();
            const raw = `var(--${self.helpers.setColorPrefix(name, self.helpers.isFramework(color.id))})`;
            const newColor = {
                id: id,
                name: name,
                raw: raw,
                rawValue: {
                    light: el,
                    dark: elDark
                },
                isShade: true,
                shadeMode: 'custom',
                shadeParent: colorId,
                shadeOrder: index,
            }
            if(color.hasOwnProperty('colorProperty') && color.colorProperty === true) newColor.colorProperty = true;
            if(color.hasOwnProperty('shadeChildren') && Array.isArray(color.shadeChildren)) color.shadeChildren.push(id);

            palette.colors.push(newColor);
            self.helpers.moveArr(palette.colors, palette.colors.length - 1, colorOrder + 1, 1);
            setTimeout(()=> {
                self.setColorManagerSearch();
                self.setColorManagerBody();
            },10)

            colorOrder++;

        })
        self.generateColorCSS();
        self.generateBuilderCSS();
    },
    generateAutoShades: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        let colorOrder = parseInt(palette.colors.indexOf(color));
        const activeColor = self.colorStates.activeColor.rawValue.light;
        let targetColor;

        function createScale(mode){
            if(mode === 'Light') targetColor = chroma(activeColor).set('hsl.l', 0.98).css('hsla');
            if(mode === 'Dark') targetColor = chroma(activeColor).set('hsl.l', 0.05).css('hsla');
            if(mode === 'Transparent') targetColor = chroma(activeColor).alpha(0.05).css('hsla');
            const colors = chroma.scale([activeColor, targetColor])
                                .correctLightness()
                                .colors(parseInt(self.colorStates.colorManagerShadeNumber) + 1);
            let ind = 0;
            colors.forEach(color => {
                colors[ind] = chroma(color).css('hsla');
                ind++;
            })
            colors.shift();
            return colors;
        }
        
        const modes = [];
        if(self.colorStates.colorManagerShadeLight === true && self.colorStates.colorManagerShadeLightValid === true) modes.push('Light');
        if(self.colorStates.colorManagerShadeDark === true && self.colorStates.colorManagerShadeDarkValid === true) modes.push('Dark');
        if(self.colorStates.colorManagerShadeTransparent === true && self.colorStates.colorManagerShadeTransparentValid === true) modes.push('Transparent')

        modes.forEach(mode => {
            const colors = createScale(mode);
            const suffix = `-${mode[0].toLowerCase()}-`
            colors.forEach((el, index) => {

                function setSufix(name, number){
                    const exist = Array.from(palette.colors).find(el => el && el.hasOwnProperty('name') && el.name === `${name}${number}`);
                    if(!exist) return `${name}${number}`;
                    number++;
                    return setSufix(name, number);
                }
                const lightness = chroma(el).get('hsl', 'l');
                const elDark = chroma(el).set('hsl.l', 1 - lightness[2]).css('hsla');
                const name = setSufix(self.helpers.formatForClasses(`${color.name}${suffix}`), 1);
                const raw = `var(--${self.helpers.setColorPrefix(name, self.helpers.isFramework(color.id))})`;
                const id = self.vueGlobalProp.$_generateId();
                const newColor = {
                    id: id,
                    name: name,
                    raw: raw,
                    rawValue: {
                        light: el,
                        dark: elDark
                    },
                    isShade: true,
                    shadeMode: 'auto',
                    shadeType: mode,
                    shadeParent: colorId,
                    shadeOrder: index,
                }

                if(color.hasOwnProperty('colorProperty') && color.colorProperty === true) newColor.colorProperty = true;
                if(color.hasOwnProperty('shadeChildren') && Array.isArray(color.shadeChildren)) color.shadeChildren.push(id);

                palette.colors.push(newColor);
                self.helpers.moveArr(palette.colors, palette.colors.length - 1, colorOrder + 1, 1);
                colorOrder++;
    
            })
        })

        setTimeout(()=> {
            self.setColorManagerSearch();
            self.setColorManagerBody();
            self.generateColorCSS();
            self.generateBuilderCSS();
        },10)
    },
    generateComplementary: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        let colorOrder = parseInt(palette.colors.indexOf(color));

        self.colorStates.colorManagerComplementaryFinalColors.forEach((el,index) => {
            function setSufix(name, number){
                const exist = Array.from(palette.colors).find(el => el && el.hasOwnProperty('name') && el.name === `${name}${number}`);
                if(!exist) return `${name}${number}`;
                number++;
                return setSufix(name, number);
            }
            const lightness = chroma(el).get('hsl', 'l');
            const elDark = chroma(el).set('hsl.l', 1 - lightness[2]).css('hsla');
            let name = (self.colorStates.colorManagerComplementaryBaseName) ? self.colorStates.colorManagerComplementaryBaseName : `${color.name}-`;
            name = setSufix(self.helpers.formatForClasses(name), 1);
            const raw = `var(--${self.helpers.setColorPrefix(name, self.helpers.isFramework(color.id))})`;
            const id = self.vueGlobalProp.$_generateId();
            const newColor = {
                id: id,
                name: name,
                raw: raw,
                rawValue: {
                    light: el,
                    dark: elDark
                },
                isComplementary: true,
                complementaryParent: colorId,
                complementaryOrder: index,
                shadeChildren: [],
                isExpanded: true,
            }
            if(color.hasOwnProperty('complementaryChildren') && Array.isArray(color.complementaryChildren)) color.complementaryChildren.push(id);

            palette.colors.push(newColor);
            self.helpers.moveArr(palette.colors, palette.colors.length - 1, colorOrder + 1, 1);
            setTimeout(()=> {
                self.setColorManagerSearch();
                self.setColorManagerBody();
            },10)

            colorOrder++;

        })
        self.generateColorCSS();
        self.generateBuilderCSS();
    },
    setShadesWrapper: function(popup, colorId){
        const self = this;
        if(popup === 'true' && self.colorStates.colorManagerShadePopupLastId === colorId) return self.setColorManagerBody();
        self.colorStates.colorManagerShadePopup = true;
        self.colorStates.colorManagerShadePopupId = colorId;
        self.colorStates.colorManagerShadePopupLastId = colorId;
        self.setColorManagerBody();


    },
    setComplementaryWrapper: function(popup, colorId){
        const self = this;
        if(popup === 'true' && self.colorStates.colorManagerComplementaryPopupLastId === colorId) return self.setColorManagerBody();
        self.colorStates.colorManagerComplementaryPopup = true;
        self.colorStates.colorManagerComplementaryPopupId = colorId;
        self.colorStates.colorManagerComplementaryPopupLastId = colorId;
        self.setColorManagerBody();


    },
    renameColor: function(event, colorId, initial){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const input = event.target.parentElement.previousElementSibling;
        input.classList.add('editable');
        const end = input.value.length; 
        input.setSelectionRange(end, end);
        input.focus();

        function renameColor(color, oldName, newName){
            if(color.hasOwnProperty('name') && color.name.includes(oldName)){
                color.name = color.name.replaceAll(oldName, newName);
                color.raw = `var(--${self.helpers.setColorPrefix(self.helpers.formatForClasses(color.name), false)})`;
                
            }
        }

        function saveName(input){
            if (input.value === initial || input.value === '') return self.setColorManagerBody();
            const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
            const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
            const oldName = color.name;

            // Rename Shades
            if(color.hasOwnProperty('shadeChildren') && Array.isArray(color.shadeChildren) && color.shadeChildren.length > 0){
                color.shadeChildren.forEach(shade => {
                    const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === shade);
                    if(!color) return;
                    renameColor(color, oldName, input.value);

                })
            }

            // Change current color
            color.name = input.value;
            color.raw = `var(--${self.helpers.setColorPrefix(self.helpers.formatForClasses(input.value), false)})`;
            

            // Remove input
            input.classList.remove('editable');
            input.blur();

            // Regenerate CSS
            self.generateColorCSS();
            self.generateBuilderCSS();
            self.setColorManagerBody();
            self.vueGlobalProp.$_showMessage('Color(s) correctly renamed!');
        }

        input.addEventListener("blur", () =>{
            saveName(input);
        })
        input.addEventListener("keydown", (event) =>{
            if(event.key === "Enter"){
                saveName(input);
            }
        })
    },
    addNewColor: function(event){
        if(event.key !== "Enter") return;
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette);
        const name = event.target.value;
        const id = self.vueGlobalProp.$_generateId();
        const raw = `var(--${self.helpers.setColorPrefix(self.helpers.formatForClasses(name), false)})`;
        function createColor(){
            const newColor = {
                id: id,
                name: name,
                raw: raw,
                rawValue: {
                    light: "#ffffff",
                    dark: "#000000",
                },
                complementaryChildren: [],
                shadeChildren: [],
                isExpanded: true,
            }
            palette.colors.push(newColor);

            self.vueGlobalProp.$_showMessage(`Color ${name} correctly created!`);
            self.setColorManagerSearch();
            self.setColorManagerBody();
        }
        createColor();
        self.generateColorCSS();
        self.generateBuilderCSS();

    },
    setDeleteColor: function(colorId,target){
        const oldContent = target.innerHTML;
        const oldBalloon = target.dataset.balloon;
        const oldFunction = `ADMINBRXC.setDeleteColor('${colorId}',this)`;
        const newContent = '<span class="bricks-svg-wrapper"><i class="fas fa-check"></i></span>';
        const newBalloon = 'Confirm?';
        const newFunction = `ADMINBRXC.deleteColor('${colorId}')`;

        target.setAttribute("onClick", newFunction);
        target.setAttribute("data-balloon", newBalloon);
        target.innerHTML = newContent;
        setTimeout(() => {
            target.setAttribute("onClick", oldFunction);
            target.setAttribute("data-balloon", oldBalloon);
            target.innerHTML = oldContent;
        }, 2000)
    },
    deleteColor: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);

        if(!color) return;

        // Remove Shade from parent
        if(color.hasOwnProperty('isShade') && color.isShade === true && color.hasOwnProperty('shadeParent')){
            const parent = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === color.shadeParent);
            if(parent.hasOwnProperty('shadeChildren') && Array.isArray(parent.shadeChildren) && parent.shadeChildren.length > 0){
                const index = parseInt(parent.shadeChildren.indexOf(colorId));
                if(index === -1) return;
                parent.shadeChildren.splice(index, 1);
            }
        }

        function deleteColor(color){
            palette.colors.splice(parseInt(palette.colors.indexOf(color)),1);
        }
        
        // Delete Shades
        if(color.hasOwnProperty('shadeChildren') && Array.isArray(color.shadeChildren) && color.shadeChildren.length > 0){
            color.shadeChildren.forEach(shade => {
                const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === shade);
                if(!color) return;
                deleteColor(color);
            })
        }

        // Delete color
        deleteColor(color);

        // Regenerate CSS
        self.generateColorCSS();
        self.generateBuilderCSS();
        setTimeout(()=> {
            self.setColorManagerSearch();
            self.setColorManagerBody();
        },10)

    },
    removeRawValue: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        if (color.hasOwnProperty('rawValue')) delete color.rawValue;
        self.generateColorCSS();
        self.generateBuilderCSS();
        setTimeout(()=> {
            self.setColorManagerBody();
        },10)
    },
    duplicateColor: function(colorId){
        const self = this;
        const palettes = self.vueState.colorPalette;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette)
        const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        const colorOrder = !color.hasOwnProperty('shadeChildren') || color.shadeChildren.length < 1 ? palette.colors.indexOf(color) : palette.colors.length;

        function duplicateColor(color, parentID){
            const parentColor = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === parentID);
            if(!parentColor) return;

            const newColor = {...color};
            const id = self.vueGlobalProp.$_generateId();
            newColor.id = id;
            newColor.shadeParent = parentID;
            newColor.name = `(Copy) ${newColor.name}`;
            newColor.raw = `var(--${self.helpers.setColorPrefix(self.helpers.formatForClasses(newColor.name), false)})`;
            newColor.rawValue = JSON.parse(JSON.stringify(color.rawValue));
            palette.colors.push(newColor);

            parentColor.shadeChildren.push(id);
            self.helpers.moveArr(palette.colors, palette.colors.length - 1, parseInt(palette.colors.length), 1);
        }

        const name = `(Copy) ${color.name}`;
        const id = self.vueGlobalProp.$_generateId();
        const newColor = JSON.parse(JSON.stringify({...color}));
        newColor.id = id;
        newColor.name = name;
        newColor.raw = `var(--${self.helpers.setColorPrefix(self.helpers.formatForClasses(name), false)})`;
        newColor.rawValue = JSON.parse(JSON.stringify(color.rawValue));
        newColor.shadeChildren = [];
        newColor.complementaryChildrenChildren = [];


        palette.colors.push(newColor);
        self.helpers.moveArr(palette.colors, palette.colors.length - 1, parseInt(colorOrder + 1), 1);

        // Delete Shades
        if(color.hasOwnProperty('shadeChildren') && Array.isArray(color.shadeChildren) && color.shadeChildren.length > 0){
            color.shadeChildren.forEach(shade => {
                const color = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === shade);
                if(!color) return;
                duplicateColor(color, id);
            })
        }
        setTimeout(()=> {
            self.setColorManagerSearch();
            self.setColorManagerBody();
        },10)

    },
    updateColor: function(color, colorId, mode = false){
        const self = this;
        !mode ? mode = self.colorStates.colorManagerMode : '';
        const palettes = self.vueState.colorPalette;

        let activeColor = false;
        const palette = Array.from(palettes).find(el => el && el.hasOwnProperty('id') && el.id == self.colorStates.activePalette);
        const maybeColor = Array.from(palette.colors).find(el => el && el.hasOwnProperty('id') && el.id === colorId);
        if (maybeColor) activeColor = maybeColor; 
        if (activeColor && !activeColor.hasOwnProperty('rawValue')) activeColor.rawValue = {};
        if (activeColor && activeColor.hasOwnProperty('raw') && activeColor.hasOwnProperty('rawValue')) activeColor.rawValue[mode] = color;
        if (activeColor && activeColor.hasOwnProperty('isVariableOnly')) delete activeColor.isVariableOnly
        

        // Shades
        if(mode === "light" && activeColor && activeColor.hasOwnProperty('shadeChildren') && Array.isArray(activeColor.shadeChildren) && activeColor.shadeChildren.length > 0){

            let targetColor;

            function createScale(mode, numShades, arr = false){
                if(mode === 'Light') targetColor = chroma(color).set('hsl.l', 0.98).css('hsla');
                if(mode === 'Dark') targetColor = chroma(color).set('hsl.l', 0.05).css('hsla');
                if(mode === 'Transparent') targetColor = chroma(color).alpha(0.05).css('hsla');
                if(mode === 'Custom') targetColor = [color, ...arr];
                const colors = mode === "Custom" ? chroma.scale(targetColor).colors(parseInt(numShades) + 1) : chroma.scale([color, targetColor]).colors(parseInt(numShades) + 1);
                let ind = 0;
                colors.forEach(color => {
                    colors[ind] = chroma(color).css('hsla');
                    ind++;
                })
                colors.shift();
                return colors;
            }

            function updateValue(colors,arr){
                if(colors && Array.isArray(colors) && colors.length > 0){
                    colors.forEach((el,index) => {
                        const color = arr.find(el => el && el.hasOwnProperty('isShade') && el.isShade && el.hasOwnProperty('shadeOrder') && parseInt(el.shadeOrder) === index);
                        if(!color) return;
                        const lightness = chroma(el).get('hsl', 'l');
                        const elDark = chroma(el).set('hsl.l', 1 - lightness[2]).css('hsla');
                        color.rawValue.light = el;
                        color.rawValue.dark = elDark;

                    })
                }

            }

            const children = Array.from(palette.colors).filter(el => el && el.hasOwnProperty('shadeParent') && el.shadeParent === colorId);
            const lightChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeType') && el.shadeType === "Light") : false;
            const darkChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeType') && el.shadeType === "Dark") : false;
            const transparentChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeType') && el.shadeType === "Transparent") : false;
            const customChildren = children && children.length > 0 ? Array.from(children).filter(el => el && el.hasOwnProperty('shadeMode') && el.shadeMode === "custom") : false;

            // Light
            if(lightChildren && lightChildren.length > 0){
                const newColors = createScale('Light', lightChildren.length);
                updateValue(newColors, lightChildren);
            }

            // Dark
            if(darkChildren && darkChildren.length > 0){
                const newColors = createScale('Dark', darkChildren.length);
                updateValue(newColors, darkChildren);
            }

            // Transparent
            if(transparentChildren && transparentChildren.length > 0){
                const newColors = createScale('Transparent', transparentChildren.length);
                updateValue(newColors, transparentChildren);
            }

            // Custom
            if(customChildren && customChildren.length > 0){
                const shadeArray = activeColor.hasOwnProperty('shadeArray') && activeColor.shadeArray.length > 0 ? activeColor.shadeArray : false;
                if(shadeArray && shadeArray.length > 0) {
                    const newColors = createScale('Custom', customChildren.length, shadeArray);
                    updateValue(newColors, customChildren);
                }
            }
        }
        self.helpers.saveChanges('colorPalette');
        self.generateColorCSS();
        self.generateBuilderCSS();
    },
    generateColorCSS: function() {
        const self = this;
        const mode = self.colorStates.colorManagerMode;
        const palettes = self.vueState.colorPalette;
        let css = '';

        if(!self.helpers.isGlobalColorsTabActive()) return css;

        palettes.forEach(palette => {
            if((palette.hasOwnProperty('status') && palette.status === "disabled" ) || !palette.hasOwnProperty('colors')) return;
            const vars = Array.from(palette.colors).filter(el => el && el.hasOwnProperty('raw') && el.hasOwnProperty('rawValue') && (!el.hasOwnProperty('isVariableOnly') || el.isVariableOnly !== true) );
            vars.forEach(el => {
                const name = self.helpers.setColorPrefix(self.helpers.formatForClasses(el.name), self.helpers.isFramework(el.id));
                const hasLight = el.rawValue.hasOwnProperty('light');
                const hasDark = el.rawValue.hasOwnProperty('dark');
                if(mode === 'dark' && hasDark){
                    //css.push([name,el.rawValue.dark])
                    css += `--${name}:${el.rawValue.dark};`;
                } else if(hasLight) {
                    //css.push([name,el.rawValue.light])
                    css += `--${name}:${el.rawValue.light};`;
                }
            });
        });
        
        self.colorStates.generatedCSS = css;
    },
    
    
    // Class Manager
    
    removeDuplicateClass: function(){
        const self = this;
        const arr = Array.from(self.vueState.globalClasses).filter(el => el && el.new === true);
        if (arr.length < 1) return;
        arr.forEach(el => {
            delete el.new;
        })
    },
    bulkClassesReset: function(){
        const self = this;
        document.querySelector('[name="brxcClassManagercontain"]').value = '';
        document.querySelector('[name="brxcClassManagerexclude"]').value = '';
        self.states.classManagerBulkActionTargetContain = '';
        self.states.classManagerBulkActionTargetExclude = '';
        self.states.classManagerBulkActionTargetGroup = 'All';
        self.states.classManagerBulkActionLock = 'All';
        self.states.classManagerBulkActionHasStyles = 'All';
        self.states.classManagerBulkActionIsActive = 'All';
        self.states.classManagerBulkActionOld = '';
        self.states.classManagerBulkActionNew = '';
        self.states.classManagerBulkActionPrefix = '';
        self.states.classManagerBulkActionSuffix = '';
        self.states.classManagerBulkActionNewGroup = '';
        self.states.classManagerBulkAssignElements = true;
        self.states.classManagerBulkRemoveOldClass = false;
        self.states.classManagerBulkDeleteOldClass = false;
        self.setClassManagerBulk();
    },
    bulkDeleteClasses: function(){
        const self = this;
        let showMessage = 'Global Classes successfully removed!';

        const cls = document.querySelectorAll('#brxcClassBulkActionList ul li.bulk-action-Delete[data-id]:not([data-enable="false"]');
        if(cls.length < 1) return self.vueGlobalProp.$_showMessage('Abort: No Class found!');

        cls.forEach(cl => {
            const clId = cl.dataset.id;

            // Remove from elements
            if(self.states.classManagerBulkRemoveOldClass === true || self.states.classManagerBulkDeleteOldClass === true){

                let filteredEls;

                // All post
                if(self.states.classManagerType === "global"){
                    const content = self.helpers.getContent() || [];
                    filteredEls = Array.from(content).filter(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.includes(clId));
                
                // Component
                } else {
                    const compElements = self.helpers.getComponentElements([],self.helpers.getFinalObject(true)?.id);
                    filteredEls = Array.from(compElements).filter(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.includes(clId));
                }
                
                if(filteredEls && filteredEls.length > 0){
                    filteredEls.forEach(element => {
                        const index = element.settings._cssGlobalClasses.indexOf(clId);
                        element.settings._cssGlobalClasses.splice(index, 1);
                    })
                }
            }

            // Delete Classes
            if(self.states.classManagerBulkDeleteOldClass === true){
                setTimeout(() => {
                    const activeClass = self.vueGlobalProp.$_getGlobalClass(clId);
                    if(!activeClass) return;

                    const index = parseInt(self.vueState.globalClasses.indexOf(activeClass))
                    self.vueState.globalClasses.splice(index,1);

                    // Move to Trash
                    if(self.vueState.globalClassesTrash && Array.isArray(self.vueState.globalClassesTrash)){
                        activeClass.deletedAt = Date.now();
                        activeClass.originalIndex = index;
                        activeClass.user_id = bricksData.loadData.currentUserId;

                        self.vueState.globalClassesTrash.push(activeClass);
                        showMessage = 'Global Classes correctly moved to trash!';
                    }
                },5)
            }
        })
        
        setTimeout(() => {
            self.vueGlobalProp.$_showMessage(showMessage);
            self.bulkClassesReset();
            self.setClassManagerBulkActionsList();
        },100)
    },
    bulkDuplicateClasses: function(){
        const self = this;
        const items = document.querySelectorAll('#brxcClassBulkActionList ul li.bulk-action-Duplicate[data-id]:not([data-enable="false"]');

        if(items.length < 1) return self.vueGlobalProp.$_showMessage('Abort: No Class found!');

        function replaceRootCustomCss(target, obj, oldName, newName){
            if(obj.settings.hasOwnProperty(target)) return obj.settings[target] = obj.settings[target].replaceAll(`.${oldName}`, `.${newName}`);

        }
        function loopCustomCss(obj, oldName, newName){
            let target = "_cssCustom";
            if(obj.settings.hasOwnProperty(target)) replaceRootCustomCss(target, obj, oldName, newName);
            const bps = self.vueState.breakpoints
            bps.forEach(bp => {
                target += `:${bp.key}`;
                if(obj.settings.hasOwnProperty(target)) replaceRootCustomCss(target, obj, oldName, newName);
            })
        }
        
        items.forEach(el => {
            setTimeout(() => {
                const oldId = el.dataset.id;
                const oldObj = self.vueGlobalProp.$_getGlobalClass(oldId);
                if(!oldObj) return;

                const obj = JSON.parse(JSON.stringify(oldObj));
                const objOrder = self.vueState.globalClasses.indexOf(oldObj);

                self.vueState.globalClasses.push(obj);
                const newId = self.vueGlobalProp.$_generateId();
                const oldName = obj.name;
                let newName = el.dataset.name !== "false" ? el.dataset.name : el.querySelector('input[type="text"]').value  && el.querySelector('input[type="text"]').value.length > 0 ? el.querySelector('input[type="text"]').value : oldName;
                const newClass = self.vueState.globalClasses[self.vueState.globalClasses.length - 1];
                newClass.id = newId;
                newName = self.helpers.checkClassName(newName.replaceAll(' ',''));
                newClass.name = newName;
                loopCustomCss(newClass, oldName, newName);
                self.helpers.moveArr(self.vueState.globalClasses, self.vueState.globalClasses.length - 1, parseInt(objOrder + 1), 1);
                setTimeout(() => {
                    self.states.classManagerActiveClass = newId;
                }, 10);

                // Content
                let filteredEls;

                // All post
                if(self.states.classManagerType === "global"){
                    const content = self.helpers.getContent() || [];
                    filteredEls = Array.from(content).filter(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.includes(oldId));
                
                // Component
                } else {
                    const compElements = self.helpers.getComponentElements([],self.helpers.getFinalObject(true).id);
                    filteredEls = Array.from(compElements).filter(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.includes(oldId));
                }

                if(filteredEls && filteredEls.length > 0){
                    filteredEls.forEach(element => {
                        // Assign to element
                        if(self.states.classManagerBulkAssignElements === true){
                            element.settings._cssGlobalClasses.push(newId);
                        }
                        // Remove old class
                        if(self.states.classManagerBulkRemoveOldClass === true){
                            const index = element.settings._cssGlobalClasses.indexOf(oldId);
                            element.settings._cssGlobalClasses.splice(index, 1);
                        }
                    })
                }

                // Delete Original class
                if(self.states.classManagerBulkDeleteOldClass === true){
                    const index = self.vueState.globalClasses.indexOf(oldObj);
                    self.vueState.globalClasses.splice(index, 1);

                    // Move to Trash
                    if(self.vueState.globalClassesTrash && Array.isArray(self.vueState.globalClassesTrash)){
                        oldObj.deletedAt = Date.now();
                        oldObj.originalIndex = index;
                        oldObj.user_id = bricksData.loadData.currentUserId;

                        self.vueState.globalClassesTrash.push(oldObj);
                    }
                }
                    
            },10)
        })
        setTimeout(() => {
            self.vueGlobalProp.$_showMessage('Classes successfully duplicated!');
            self.helpers.saveChanges('globalClasses');
            self.bulkClassesReset();
            self.setClassManagerBulkActionsList();
        },100)
    },
    bulkRenameClasses: function(){
        const self = this;
        const items = document.querySelectorAll('#brxcClassBulkActionList ul li[data-id]:not([data-enable="false"]');

        if(items.length < 1) return self.vueGlobalProp.$_showMessage('Abort: No Class found!');

        function replaceRootCustomCss(target, obj, oldName, newName){
            if(obj.settings.hasOwnProperty(target)) return obj.settings[target] = obj.settings[target].replaceAll(`.${oldName}`, `.${newName}`);

        }
        function loopCustomCss(obj, oldName, newName){
            let target = "_cssCustom";
            if(obj.settings.hasOwnProperty(target)) replaceRootCustomCss(target, obj, oldName, newName);
            const bps = self.vueState.breakpoints
            bps.forEach(bp => {
                target += `:${bp.key}`;
                if(obj.settings.hasOwnProperty(target)) replaceRootCustomCss(target, obj, oldName, newName);
            })
        }

        items.forEach(el => {
            const id = el.dataset.id;
            const obj = self.vueGlobalProp.$_getGlobalClass(id);
            if(!obj) return;

            const oldName = obj.name;
            const tempName = el.dataset.name !== "false" ? el.dataset.name : el.querySelector('input[type="text"]').value  && el.querySelector('input[type="text"]').value.length > 0 ? el.querySelector('input[type="text"]').value : oldName;
            const newName = self.helpers.checkClassName(tempName.replaceAll(' ',''));
            obj.name = newName;
            loopCustomCss(obj, oldName, newName);
        })
        setTimeout(() => {
            self.vueGlobalProp.$_showMessage('Classes successfully renamed!');
            self.bulkClassesReset();
            self.setClassManagerBulkActionsList();
        },100)
    },
    renameBulkedClass: function(event, bulkedName){
        const prev = event.target.parentElement.previousElementSibling;
        const parent = event.target.parentElement.parentElement;
        if(!event) return;
        prev.innerHTML = `.<input type="text" value="${bulkedName}">`;
        parent.setAttribute('data-name', false);
        const input = prev.querySelector('input');
        input.focus();
        input.select()

    },

    enableBulkedClass: function(event){
        const li = event.target.closest('li');
        if(event.target.classList.contains('enable')){
            li.setAttribute('data-enable', 'false')
            event.target.classList.remove('enable');
            event.target.classList.add('disable');
            event.target.setAttribute('data-balloon', 'Skipped');
            event.target.querySelector('i').setAttribute('class', 'fas fa-toggle-off');
        } else {
            li.setAttribute('data-enable', 'true');
            event.target.classList.add('enable');
            event.target.classList.remove('disable');
            event.target.setAttribute('data-balloon', 'Included');
            event.target.querySelector('i').setAttribute('class', 'fas fa-toggle-on');
        }
    },
    bulkGroupClasses: function(){
        const self = this;

        const cls = document.querySelectorAll('#brxcClassBulkActionList ul li.bulk-action-Group[data-id]:not([data-enable="false"])');
        if(cls.length < 1) return self.vueGlobalProp.$_showMessage('Abort: No Class found!');
        
        if(!self.states.classManagerCategories.includes(self.states.classManagerBulkActionNewGroup)) self.helpers.createClassCategory(self.states.classManagerBulkActionNewGroup)
        cls.forEach(el => {
            const clId = el.dataset.id;
            const obj = self.vueGlobalProp.$_getGlobalClass(clId);
            if(!obj) return;

            obj.category = self.helpers.getClassCategoryIdByName(self.states.classManagerBulkActionNewGroup);
        })
        setTimeout(() => {
            self.vueGlobalProp.$_showMessage(`Classes successfully assigned to ${self.states.classManagerBulkActionNewGroup}!`);
            self.bulkClassesReset();
            self.setClassManagerBulkActionsList();
        },100)
    },
    bulkExportClasses: function(){
        const self = this;

        const cls = document.querySelectorAll('#brxcClassBulkActionList ul li.bulk-action-Export[data-id]:not([data-enable="false"]');
        if(cls.length < 1) return self.vueGlobalProp.$_showMessage('Abort: No Class found!');

        const globalClasses = [];

        cls.forEach(cl => {
            const obj = self.vueGlobalProp.$_getGlobalClass(cl.dataset.id);
            if(!obj) return;
            globalClasses.push(obj);
        })
        
        self.vueGlobalProp.$_exportAsJsonFile(globalClasses, 'bricks-css-classes');
        
        setTimeout(() => {
            self.vueGlobalProp.$_showMessage(`Classes successfully exported!`);
            self.bulkClassesReset();
            self.setClassManagerBulkActionsList();
        },100)
    },
    bulkLockClasses: function(){
        const self = this;

        const cls = document.querySelectorAll('#brxcClassBulkActionList ul li.bulk-action-Lock[data-id]:not([data-enable="false"]');
        if(cls.length < 1) return self.vueGlobalProp.$_showMessage('Abort: No Class found!');

        const lockedClasses = Array.from(cls).map(el => el.dataset.id);
        self.vueState.globalClassesLocked = [...new Set(self.vueState.globalClassesLocked.concat(lockedClasses))];
        
        
        setTimeout(() => {
            self.vueGlobalProp.$_showMessage(`Classes successfully locked!`);
            self.bulkClassesReset();
            self.setClassManagerBulkActionsList();
        },100)
    },
    bulkUnlockClasses: function(){
        const self = this;

        const cls = document.querySelectorAll('#brxcClassBulkActionList ul li.bulk-action-Unlock[data-id]:not([data-enable="false"]');
        if(cls.length < 1) return self.vueGlobalProp.$_showMessage('Abort: No Class found!');

        const unlockedClasses = Array.from(cls).map(el => el.dataset.id);
        self.vueState.globalClassesLocked = Array.from(self.vueState.globalClassesLocked).filter(el => !unlockedClasses.includes(el));
        
        
        setTimeout(() => {
            self.vueGlobalProp.$_showMessage(`Classes successfully locked!`);
            self.bulkClassesReset();
            self.setClassManagerBulkActionsList();
        },100)
    },
    loadMoreClasses: function(num){
        const self = this;
        self.states.classManagerMaxClasses = num;
    },
    setClassManagerBulk: function(){
        const self = this;
        self.states.classManagerMaxClasses = 50;
        self.setClassManagerBulkActionsList();
        self.setClassManagerBulkActions();
    },
    setClassManagerBulkActionsList: function(){
        const canvas = document.querySelector('#brxcClassBulkActionList');
        const self = this;
        const contentArr = self.helpers.getContent() || [];
        let cls;
        
        // Type
        if(self.states.classManagerType === "global") {
            cls = self.vueState.globalClasses;
         } else {
            let globalClasses = [];
            const tempClasses = self.helpers.getComponentClasses([],self.helpers.getFinalObject(true)?.id);
            
            if(tempClasses.length > 0){
                tempClasses.forEach(el => {
                    const classObj = self.vueGlobalProp.$_getGlobalClass(el);
                    if(classObj) globalClasses.push(classObj)
                })
                cls = globalClasses.concat(Array.from(self.vueState.globalClasses).filter(el => el && el.new === true))
            }
         }

         let content = '';

         if(Array.isArray(cls) && cls.length > 0 ) {
            // filters
            const contain = self.states.classManagerBulkActionTargetContain.replaceAll(' ', '').split(',');
            const exclude = self.states.classManagerBulkActionTargetExclude.replaceAll(' ', '').split(',');
            const checkContain = (e) => (contain.length === 1 && contain[0] === '') || contain.some(target => target !== '' && e.name.includes(target));
            const checkExclude = (e) => (exclude.length === 1 && exclude[0] === '') || exclude.every(target => target === '' || !e.name.includes(target));
            const checkGroup = (e) => {
                if(self.states.classManagerBulkActionTargetGroup === "All"){
                    return true;
                } else if(self.states.classManagerBulkActionTargetGroup === "Uncategorized"){
                    return !e.hasOwnProperty('category');
                } else {
                    return e.category === self.states.classManagerBulkActionTargetGroup;
                }
            }
            const checkLock = (e) => self.states.classManagerBulkActionLock !== "All" ? (self.states.classManagerBulkActionLock === "locked" ? self.vueGlobalProp.$_isLocked(e.id) : !self.vueGlobalProp.$_isLocked(e.id)) : true;
            const checkStyle = (e) => self.states.classManagerBulkActionHasStyles !== "All" ? (self.states.classManagerBulkActionHasStyles === "has-styles" ? self.vueGlobalProp.$_generateCss('globalClass', e.id, ['block']) !== '' : self.vueGlobalProp.$_generateCss('globalClass', e.id, ['block']) === '') : true;
            const checkIsActive = (e) => self.states.classManagerBulkActionIsActive !== "All" ? (self.states.classManagerBulkActionIsActive === "is-active" ? typeof Array.from(contentArr).find(el2 => el2 && el2.settings._cssGlobalClasses && Array.isArray(el2.settings._cssGlobalClasses) && el2.settings._cssGlobalClasses.includes(e.id)) !== "undefined" : typeof Array.from(contentArr).find(el2 => el2 && el2.settings._cssGlobalClasses && Array.isArray(el2.settings._cssGlobalClasses) && el2.settings._cssGlobalClasses.includes(e.id)) === "undefined") : true;
            
            cls = cls.filter(el =>
                el 
                && checkContain(el)
                && checkExclude(el)
                && checkGroup(el)
                && checkLock(el)
                && checkStyle(el)
                && checkIsActive(el)
            );
    
            content += `<ul>`;
            if(cls.length > 0) {
                let index = 1;
                cls.slice(0, self.states.classManagerMaxClasses).forEach(el => {
                    const tempName = `<span class="brxc_changes">${self.states.classManagerBulkActionPrefix.replaceAll(' ','')}</span>` + (self.states.classManagerBulkActionOld === '' || self.states.classManagerBulkActionNew === "" ? el.name : el.name.replaceAll(self.states.classManagerBulkActionOld, `<span class="brxc_changes">${self.states.classManagerBulkActionNew.replaceAll(' ','')}</span>`)) + `<span class="brxc_changes">${self.states.classManagerBulkActionSuffix.replaceAll(' ','')}</span>`;
                    const newName = self.helpers.checkClassName(tempName, true);
                    const newNameWithoutTags = newName.replaceAll('<span class="brxc_changes">', '').replaceAll('</span>', '');
                    if(self.states.classManagerBulkActionType === "Duplicate") content += `<li class="active"><div class="span-wrapper"><span>.${el.name}</span></div></li>`;
                    const classicNames = ['Delete', 'Group', 'Export', 'Lock'];
                    content += `<li class="bulk-action-${self.states.classManagerBulkActionType}" data-id="${el.id}" data-name="${newNameWithoutTags}"><div class="span-wrapper"><span>.${classicNames.includes(self.states.classManagerBulkActionType) ? el.name : newName}</span></div>`;
                    content += `<div class="brxc-bulk-action-wrapper">`
                    if(self.states.classManagerBulkActionType === "Rename" || self.states.classManagerBulkActionType === "Duplicate"){
                        content += `<div class="brxc-icon" data-balloon="Rename" data-balloon-pos="left" onClick="ADMINBRXC.renameBulkedClass(event, '${newNameWithoutTags}');"><span class="bricks-svg-wrapper"><i class="fas fa-pen"></i></span></div>`;
                        
                    } 
                    content += `<div class="brxc-icon enable" data-balloon="Included" data-balloon-pos="left" onClick="ADMINBRXC.enableBulkedClass(event);"><span class="bricks-svg-wrapper"><i class="fas fa-toggle-on"></i></span></div>`;
                    content += `</div>`
                    content +=`</li>`;
                    if(index === self.states.classManagerMaxClasses && self.states.classManagerMaxClasses < cls.length) content += `<li onclick="ADMINBRXC.loadMoreClasses(${cls.length});ADMINBRXC.setClassManagerBulkActionsList();"><div class="span-wrapper"><span class="max-results">Load ${cls.length - 50} more classes....</span></div></li>`;
                    index++;
                })
            }
            content += '</ul>';
         }
         
        canvas.innerHTML = content;

    },
    setClassManagerBulkActions: function(){
        const self = this;
        const canvas = document.querySelector('#brxcClassBulkActionCanvas');
        let content = '';
        content +=`<fieldset>
                    <legend>Filters</legend>
                    <div><label class="has-tooltip"><span>Include String:</span><div data-balloon="Type a keyword to filter the classes that you want to target. For multiple keywords, separate each word by a comma." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                    <div class="brxc__text"><input type="text" name="brxcClassManagercontain" id="brxcClassManagercontain" placeholder="Type here the keywords you want to include" onInput="ADMINBRXC.states.classManagerBulkActionTargetContain = this.value;ADMINBRXC.setClassManagerBulkActionsList();"></div></div>
                    <div><label class="has-tooltip"> <span>Exclude String</span><div data-balloon="Type keywords that will exclude the classes from the selection. For multiple keywords, separate each word by a comma." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                    <div class="brxc__text"><input type="text" name="brxcClassManagerexclude" id="brxcClassManagerexclude" placeholder="Type here the keywords you want to exclude" onInput="ADMINBRXC.states.classManagerBulkActionTargetExclude = this.value;ADMINBRXC.setClassManagerBulkActionsList();"></div></div>`;
        content += `<div><label class="has-tooltip"><span>Group:</span><div data-balloon="Filter the selection by any Class Group." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="brxc-select"><select name="brxc-bulkActionsOptions" id="bulkActionsOptions" class="brxc-bulkActionsOptions" value="${self.states.classManagerBulkActionTargetGroup}" onChange="ADMINBRXC.states.classManagerBulkActionTargetGroup = this.value;ADMINBRXC.setClassManagerBulkActionsList();">`;
        content += `<option value="All">All</option>`;
        content += `<option value="Uncategorized">Uncategorized</option>`;
        const sortedCats = Array.from(self.vueState.globalClassesCategories).filter(el => el && el.name).map(el => el && el.name).sort((a, b) => a.localeCompare(b, undefined, {sensitivity: 'base'}));
        sortedCats.forEach(el => {
            content += `<option value="${self.helpers.getClassCategoryIdByName(el)}">${el}</option>`;
        })
        content += `</select></div></div>`;
        content += `<div><label class="has-tooltip"><span>Locked/Unlocked:</span><div data-balloon="Filter the selection by their Lock status." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="brxc-select"><select name="brxc-bulkActionsOptionsLock" id="bulkActionsOptionsLock" class="brxc-bulkActionsOptions" value="${self.states.classManagerBulkActionLock}" onChange="ADMINBRXC.states.classManagerBulkActionLock = this.value;ADMINBRXC.setClassManagerBulkActionsList();"><option value="All">All</option><option value="locked">Locked</option><option value="unlocked">Unlocked</option></select></div></div>`;
        content += `<div><label class="has-tooltip"><span>Have Styles:</span><div data-balloon="Filter the selection of the classes that contain custom styles." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="brxc-select"><select name="brxc-bulkActionsOptionsHasStyles" id="bulkActionsOptionsHasStyles" class="brxc-bulkActionsOptions" value="${self.states.classManagerBulkActionHasStyles}" onChange="ADMINBRXC.states.classManagerBulkActionHasStyles = this.value;ADMINBRXC.setClassManagerBulkActionsList();"><option value="All">All</option><option value="has-styles">Have Styles</option><option value="has-no-styles">Have No Styles</option></select></div></div>`;
        content += `<div><label class="has-tooltip"><span>Active on Page:</span><div data-balloon="Filter the selection of the classes that are used on this page." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        content += `<div class="brxc-select"><select name="brxc-bulkActionsOptionsIsActive" id="bulkActionsOptionsIsActive" class="brxc-bulkActionsOptions" value="${self.states.classManagerBulkActionIsActive}" onChange="ADMINBRXC.states.classManagerBulkActionIsActive = this.value;ADMINBRXC.setClassManagerBulkActionsList();"><option value="All">All</option><option value="is-active">Active on Page</option><option value="is-not-active">Inactive on Page</option></select></div></div>`;
        content += `</fieldset>`;
        if(self.states.classManagerBulkActionType === "Duplicate" || self.states.classManagerBulkActionType === "Rename"){
            content += `<fieldset><legend>Action</legend>`;
            content += `<div><label class="has-tooltip"><span>Find:</span><div data-balloon="Type here the string that you want to replace." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc__text"><input type="text" name="brxcClassManagerOld" id="brxc-bulkActionsOld" placeholder="Type here the string you want to replace" value="${self.states.classManagerBulkActionOld}" onInput="ADMINBRXC.states.classManagerBulkActionOld = this.value;ADMINBRXC.setClassManagerBulkActionsList();"></div></div>`;
            content += `<div><label class="has-tooltip"><span>Replace with:</span><div data-balloon="Type here the new string that will replace the old one." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc__text"><input type="text" name="brxcClassManagerNew" id="brxc-bulkActionsNew" placeholder="Type here the new string" value="${self.states.classManagerBulkActionNew}" onInput="ADMINBRXC.states.classManagerBulkActionNew = this.value;ADMINBRXC.setClassManagerBulkActionsList();"></div></div>`;
            content += `<div><label class="has-tooltip"><span>Add a prefix:</span><div data-balloon="Add a prefix to the renamed classes" data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc__text"><input type="text" name="brxcClassManagerNew" id="brxc-bulkActionsPrefix" placeholder="Type here the prefix" value="${self.states.classManagerBulkActionPrefix}" onInput="ADMINBRXC.states.classManagerBulkActionPrefix = this.value;ADMINBRXC.setClassManagerBulkActionsList();"></div></div>`;
            content += `<div><label class="has-tooltip"><span>Add a suffix:</span><div data-balloon="Add a suffix to the renamed classes" data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc__text"><input type="text" name="brxcClassManagerNew" id="brxc-bulkActionsSuffix" placeholder="Type here the suffix" value="${self.states.classManagerBulkActionSuffix}" onInput="ADMINBRXC.states.classManagerBulkActionSuffix = this.value;ADMINBRXC.setClassManagerBulkActionsList();"></div></div>`;
            if(self.states.classManagerBulkActionType === "Rename") content += `</fieldset>`;
        } 
        if(self.states.classManagerBulkActionType === "Duplicate"){
            content += `<div><label class="has-tooltip"><span>Assign duplicated classes to same elements:</span><div data-balloon="If yes, the duplicated classes will be added to the same elements where the original classes are assigned. This will apply on the current post only - not sitewide." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                            <input type="radio" id="brxc-class-converter-assign-yes" name="brxc-class-converter-assign-elements" class="brxc-input__checkbox" value="0"${self.states.classManagerBulkAssignElements === false ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkAssignElements = false">
                            <label for="brxc-class-converter-assign-yes" class="brxc-overlay__panel-inline-btns">No</label>
                            <input type="radio" id="brxc-class-converter-assign-no" name="brxc-class-converter-assign-elements" class="brxc-input__checkbox" value="1"${self.states.classManagerBulkAssignElements === true ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkAssignElements = true">
                            <label for="brxc-class-converter-assign-no" class="brxc-overlay__panel-inline-btns">Yes</label>
                        </div></div>`;
            content += `<div><label class="has-tooltip"><span>Remove old classes from all the elements:</span><div data-balloon="If yes, the original classes will be removed from all the elements on this ${self.states.classManagerType === "global" ? 'post' : 'component'}. This will apply on the current post only - not sitewide." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                            <input type="radio" id="brxc-class-converter-remove-yes" name="brxc-class-converter-remove-elements" class="brxc-input__checkbox" value="0"${self.states.classManagerBulkRemoveOldClass === false ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkRemoveOldClass = false">
                            <label for="brxc-class-converter-remove-yes" class="brxc-overlay__panel-inline-btns">No</label>
                            <input type="radio" id="brxc-class-converter-remove-no" name="brxc-class-converter-remove-elements" class="brxc-input__checkbox" value="1"${self.states.classManagerBulkRemoveOldClass === true ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkRemoveOldClass = true">
                            <label for="brxc-class-converter-remove-no" class="brxc-overlay__panel-inline-btns">Yes</label>
                        </div></div>`;
            content += `<div><label class="has-tooltip"><span>Delete old classes from the Global Classes list:</span><div data-balloon="If yes, the original classes will be deleted from the Global Classes list. This will apply sitewide and impact all your posts/pages." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                            <input type="radio" id="brxc-class-converter-delete-yes" name="brxc-class-converter-delete-elements" class="brxc-input__checkbox" value="0"${self.states.classManagerBulkDeleteOldClass === false ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkDeleteOldClass = false">
                            <label for="brxc-class-converter-delete-yes" class="brxc-overlay__panel-inline-btns">No</label>
                            <input type="radio" id="brxc-class-converter-delete-no" name="brxc-class-converter-delete-elements" class="brxc-input__checkbox" value="1"${self.states.classManagerBulkDeleteOldClass === true ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkDeleteOldClass = true">
                            <label for="brxc-class-converter-delete-no" class="brxc-overlay__panel-inline-btns">Yes</label>
                        </div></div>`;
            content += `</fieldset>`;
        } else if(self.states.classManagerBulkActionType === "Group"){
            content += `<fieldset><legend>Action</legend>`;
            content += `<div><label class="has-tooltip"><span>Assign classes to the following group:</span><div data-balloon="Write here the group you want to assign the classes." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc__text"><input type="text" name="brxcClassManagerNewGroup" id="brxc-bulkActionsNewGroup" placeholder="Type here the group you want to assign the classes" value="${self.states.classManagerBulkActionNewGroup}" onInput="ADMINBRXC.states.classManagerBulkActionNewGroup = this.value;ADMINBRXC.setClassManagerBulkActionsList();"></div></div>`;
            content += `</fieldset>`;
        } else if(self.states.classManagerBulkActionType === "Delete"){
            content += `<fieldset><legend>Action</legend>`;
            content += `<div><label class="has-tooltip"><span>Remove classes from all the elements:</span><div data-balloon="If yes, the targeted classes will be removed from all the elements on this ${self.states.classManagerType === "global" ? 'post' : 'component'}. This will apply on the current post only - not sitewide." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                            <input type="radio" id="brxc-class-converter-remove-yes" name="brxc-class-converter-remove-elements" class="brxc-input__checkbox" value="0"${self.states.classManagerBulkRemoveOldClass === false ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkRemoveOldClass = false">
                            <label for="brxc-class-converter-remove-yes" class="brxc-overlay__panel-inline-btns">No</label>
                            <input type="radio" id="brxc-class-converter-remove-no" name="brxc-class-converter-remove-elements" class="brxc-input__checkbox" value="1"${self.states.classManagerBulkRemoveOldClass === true ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkRemoveOldClass = true">
                            <label for="brxc-class-converter-remove-no" class="brxc-overlay__panel-inline-btns">Yes</label>
                        </div></div>`;
            content += `<div><label class="has-tooltip"><span>Delete classes from the Global Classes list:</span><div data-balloon="If yes, the original classes will be deleted from the Global Classes list. This will apply sitewide and impact all your posts/pages." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            content += `<div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                            <input type="radio" id="brxc-class-converter-delete-yes" name="brxc-class-converter-delete-elements" class="brxc-input__checkbox" value="0"${self.states.classManagerBulkDeleteOldClass === false ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkDeleteOldClass = false">
                            <label for="brxc-class-converter-delete-yes" class="brxc-overlay__panel-inline-btns">No</label>
                            <input type="radio" id="brxc-class-converter-delete-no" name="brxc-class-converter-delete-elements" class="brxc-input__checkbox" value="1"${self.states.classManagerBulkDeleteOldClass === true ? ' checked=""' : ''} onclick="ADMINBRXC.states.classManagerBulkDeleteOldClass = true">
                            <label for="brxc-class-converter-delete-no" class="brxc-overlay__panel-inline-btns">Yes</label>
                        </div></div>`;
            content += `</fieldset>`;
        }
        content += `<div id="bulk${self.states.classManagerBulkActionType}ClassesCTA" class="brxc-overlay__action-btn-wrapper right sticky-bottom generate-content active"><div class="brxc-overlay__action-btn" onclick="ADMINBRXC.bulkClassesReset()"><span>Reset</span></div><div class="brxc-overlay__action-btn primary" onclick="ADMINBRXC.bulk${self.states.classManagerBulkActionType}Classes()"><span>${self.states.classManagerBulkActionType} Classes</span></div></div>`;

        canvas.innerHTML = content;

        const group = document.querySelector('#bulkActionsOptions');
        if (group) group.value = self.states.classManagerBulkActionTargetGroup;
        const lock = document.querySelector('#bulkActionsOptionsLock');
        if (lock) lock.value = self.states.classManagerBulkActionLock;
        const hasStyle = document.querySelector('#bulkActionsOptionsHasStyles');
        if (hasStyle) hasStyle.value = self.states.classManagerBulkActionHasStyles;
        const isActive = document.querySelector('#bulkActionsOptionsIsActive');
        if (isActive) isActive.value = self.states.classManagerBulkActionIsActive;

        const newGroup = document.querySelector('#brxc-bulkActionsNewGroup');
        if (newGroup){
            newGroup.addEventListener('keydown', () => {
                self.autocomplete(newGroup,self.vueState.globalClassesCategories.map(el => el && el.name),false);
            })
        } 
    },
    openClassManager: function(type) {
        const self = this;
        if(typeof self.vueState.globalClassesCategories === "undefined"){
            return alert('The class manager requires Bricks 1.9.5+ to be installed. Please upgrade your theme.')
        }
        ADMINBRXC.removeDuplicateClass();
        ADMINBRXC.states.classManagerType = type;
        ADMINBRXC.setClassManager();
        ADMINBRXC.setClassManagerBulk();
        ADMINBRXC.openModal(false, "#brxcClassManagerOverlay")
    },
    setClassManager: function(){
        const self = this;
        self.states.classManagerMaxClasses = 50;
        self.setCatList();
        self.setClassList();
        self.setClassContent();
    },
    setCatList: function(){
        const self = this;
        const listWrapper = document.querySelector('#brxcClassManagerOverlay #brxcCatListCanvas');
        if(!listWrapper || !Array.isArray(self.states.classManagerCategories)) return;
        let cats = '<ul>';
        let categoryFound;
        let count;

        function isActive (cat) {
            if(self.helpers.getClassCategoryIdByName(cat) === self.states.classManagerActiveCategory) return true;
            return false;
        }

        // All
        count = self.vueState.globalClasses.length;
        cats += `<li class="${self.states.classManagerActiveCategory === "All" ? 'active' : ''}"${self.states.classManagerActiveCategory === "All" ? ' data-active="true"' : ''} data-id="All" onClick="ADMINBRXC.classManagerFilterCat(event)"><input type="text" value="All" readonly/><span class="count">${count}</span></li>`
        
        // Uncategorized
        count = Array.from(self.vueState.globalClasses).filter(el => el && (!el.category || self.helpers.getClassCategoryObjById(el.category) === false)).length;
        cats += `<li class="${self.states.classManagerActiveCategory === "Uncategorized" ? 'active' : ''}"${self.states.classManagerActiveCategory === "Uncategorized" ? ' data-active="true"' : ''} data-id="Uncategorized" onClick="ADMINBRXC.classManagerFilterCat(event)"><input type="text" value="Uncategorized" readonly/><span class="count">${count}</span></li>`

        // Categories
        const sortedCats = Array.from(self.vueState.globalClassesCategories).filter(el => el && el.name).map(el => el && el.name).sort((a, b) => a.localeCompare(b, undefined, {sensitivity: 'base'}));
        sortedCats.forEach(cat => {
            categoryFound = self.helpers.getClassCategoryObjByName(cat)
            count = Array.from(self.vueState.globalClasses).filter(el => el && el.hasOwnProperty('category') && categoryFound && categoryFound.id === el.category).length;
            cats += `<li class="${isActive(cat) ? 'active' : ''}"${isActive(cat) ? ' data-active="true"' : ''} data-id="${categoryFound.id}" ondragenter="this.classList.add('dragged')" ondragleave="this.classList.remove('dragged')" ondrop="event.preventDefault();ADMINBRXC.onDropCatList(this);" ondragover="event.preventDefault();" onClick="ADMINBRXC.classManagerFilterCat(event)"><input type="text" data-initial="${cat}" value="${cat}"${categoryFound.id !== self.states.classManagerActiveCategory ? ' readonly' : ''}/>${categoryFound.id === self.states.classManagerActiveCategory ? `<div class="deleteCat" onClick="event.stopPropagation();ADMINBRXC.deleteCategory('${self.states.classManagerActiveCategory}')" data-balloon="Delete category" data-balloon-pos="top-right"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>` : `<span class="count">${count}</span>`}</li>`
            
        })

        // Trash
        if(self.vueState.hasOwnProperty('globalClassesTrash') && Array.isArray(self.vueState.globalClassesTrash)){
            count = self.vueState.globalClassesTrash.length;
            cats += `<li class="${self.states.classManagerActiveCategory === "Trash" ? 'active' : ''} trash"${self.states.classManagerActiveCategory === "Trash" ? ' data-active="true"' : ''} data-id="Trash" onClick="ADMINBRXC.classManagerFilterCat(event)"><i class="ti-trash"></i><input type="text" value="Trash" readonly/><span class="count">${count}</span></li>`
        }

        cats += '</ul><input type="text" id="addNewCat" placeholder="+ New category" onkeyup="ADMINBRXC.addNewCategory(event);" />';
        if (self.helpers.isAIActive() && self.globalSettings.isAIApiKeyEmpty === "0" && self.states.classManagerCategories.length > 1) cats += `<a class="brxc-overlay__action-btn" style="margin-top: 12px;" onclick="ADMINBRXC.classCategoriesAI(this);"><span>Assign with AI</span></a>`;
        listWrapper.innerHTML = cats;

        // rename cat
        const input = listWrapper.querySelector('li.active input');
        if(input){
            input.addEventListener('keyup', (event) => {
                if(event.key !== "Enter") return;
                if(event.target.value === event.target.dataset.initial) return self.setCatList();
                if(self.states.classManagerCategories.includes(event.target.value)) return self.vueGlobalProp.$_showMessage(`ABORT: category "${event.target.value}" already exists`);
                const activeObj = self.helpers.getClassCategoryObjById(self.states.classManagerActiveCategory)
                activeObj.name = event.target.value;
                self.populateClassCategories();
                self.vueGlobalProp.$_showMessage(`Category correctly renamed to ${event.target.value}`)
                self.setCatList();
                self.setClassContent();
            })
        }
        
    },
    generateClassCategoriesAI: function (response){
        const self = this;
        const classes = JSON.parse(response).classes;
        const matchingClasses = classes.filter(el => el && el.hasOwnProperty('category') && el.category !== "noMatch" && self.helpers.getClassCategoryIdByName(el.category));
        if(matchingClasses.length > 0){
            matchingClasses.forEach(cls => {
                const obj = Array.from(self.vueState.globalClasses).find(el => el && el.hasOwnProperty('id') && cls.id === el.id);
                if (obj && (!obj.hasOwnProperty('category') || self.helpers.getClassCategoryObjById(obj.category) === false) ) {
                    obj.category = self.helpers.getClassCategoryIdByName(cls.category)
                } else {
                    console.log('Error')
                }
            })
        }
        self.populateClassCategories();
        self.setCatList();
        self.setClassList();
    },
    classCategoriesAI: function(target){
        const self = this;
        const obj = [];
        const defaultModel = self.globalSettings.defaultAIModel;
        self.vueState.globalClasses.forEach(cls => {
            if(!cls.hasOwnProperty('category') || self.helpers.getClassCategoryObjById(cls.category) === false){
                obj.push({
                    id: cls.id,
                    name: cls.name.replaceAll('__', ' ').replaceAll('_', ' ').replaceAll('--', ' ').replaceAll('-', ' '),
                })
            }
        })
        target.classList.add('disable');
        const categories = Array.from(self.vueState.globalClassesCategories).map(el => el && el.name)
        categories.shift();
        categories.push('Others');
        const json = {
            "model": defaultModel,
            "messages": [
              {
                "role":"user",
                "content": `Given the following object: ${JSON.stringify(obj)}. Assign each object to an existing category. Check the name provided in each object to determine if it can be related to a provided category. If no match is found, assign it to "noMatch".`,
              }
            ],
            "functions":[{
                "name":"generateClassCategoriesAI",
                "description":"Assign categories to objects.",
                "parameters":{
                   "type":"object",
                   "properties":{
                      "classes":{
                         "type":"array",
                         "items":{
                            "type":"object",
                            "properties":{
                               "id":{
                                  "type":"string",
                                  "description":"The object's ID"
                               },
                               "category":{
                                  "type":"string",
                                  "description":"The object's category",
                                  "enum": categories
                               }
                            }
                         }
                      }
                   },
                   "required":[
                      "classes"
                   ]
                }
             }],
            "function_call": "auto",
            "temperature": 0
          }

        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce,
            },
            success: function(response) {
                const post = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'Authorization' : 'Bearer '+ response,
                        },
                      body: JSON.stringify(json)
                    });
                    const content = await rawResponse.json();
                    if(content.error){
                        self.insertErrorMessage('classManager', false, '#brxcClassManagerOverlay', content.error.message);
                        target.classList.remove('disable');
                    } else {
                        target.classList.remove('disable');
                        self.generateClassCategoriesAI(content.choices[0].message.function_call.arguments);
                    }
                };
                post();
            },
            error: function(response){
                console.log('Something went wrong with the OpenAI AJAX request: ' + response);
                target.classList.remove('disable');
            }
        });
    },
    onDropCatList: function(target){
        const self = this;
        if(self.states.classManagerStartDrag && Array.isArray(self.states.classManagerStartDrag)){
            self.states.classManagerStartDrag.forEach(id => {
                const obj = self.vueGlobalProp.$_getGlobalClass(id);
                if(obj) obj.category = target.dataset.id;
            })
        }
        self.vueGlobalProp.$_showMessage(`Category ${target.dataset.id} correctly assigned!`)
        self.setCatList();
        self.setClassList();
        self.setClassContent();
    },
    onDropVariableCatList: function(target){
        const self = this;
        if(self.cssVariablesStates.onDrag && Array.isArray(self.cssVariablesStates.onDrag)){
            self.cssVariablesStates.onDrag.forEach(id => {
                const obj = self.helpers.getGlobalVariableObjById(id);
                obj.category = target.dataset.id;
            })
        }
        self.setCSSVariableManager();
    },
    deleteCategory: function(catId){
        const self = this;
        const obj = self.helpers.getClassCategoryObjById(catId);
        self.vueState.globalClassesCategories.splice(self.vueState.globalClassesCategories.indexOf(obj), 1);
        self.states.classManagerActiveCategory = "All";

        const cls = Array.from(self.vueState.globalClasses).filter(el => el && el.hasOwnProperty('category') && el.category === catId);
        let hasChanges = false
        cls.forEach(el => {
            hasChanges = true
            delete el.category;
        })
        if(hasChanges) self.helpers.saveChanges('globalClasses');

        self.populateClassCategories();
        self.setCatList();
        self.setClassList();
        self.setClassContent();
    },
    addNewCategory: function(event){
        const self = this;

        if(event.key !== "Enter") return;

        const values = event.target.value.split(',').map(item => item.trim());
        if(values.length < 1) return;

        let hasChanges = false;

        values.forEach(name => {
            if(Array.from(self.vueState.globalClassesCategories).map(obj => obj && obj.name).includes(name)) {
                return self.vueGlobalProp.$_showMessage('ABORT: category already exists');
            } else {
                hasChanges = true;
                self.helpers.createClassCategory(name);
                self.helpers.saveChanges('globalClasses');

            }
        })
        if(hasChanges === true) {
            //self.states.classManagerCategories.sort();
            self.states.classManagerActiveCategory = self.helpers.getClassCategoryIdByName(values[values.length - 1]);
            self.setCatList();
            self.setClassList();
        };  
    },
    classManagerFilterCat: function(event){
        const self = this;
        target = (event.target.dataset.id) ? event.target : event.target.parentElement;
        if(target.dataset.active === 'true') return;
        self.states.classManagerActiveCategory = target.dataset.id;
        self.setCatList();
        self.setClassList();
    },
    setClassList: function(){
        const self = this;
        const listWrapper = document.querySelector('#brxcClassManagerOverlay #brxcClassListCanvas');
        const template = self.helpers.getTemplateType();
        const isClassTrash = self.vueState.hasOwnProperty('globalClassesTrash') && Array.isArray(self.vueState.globalClassesTrash);
        let count = 0;
        let classes = '<ul>';
        let globalClasses;
        const fullList = self.states.classManagerSearch === '' && self.states.classManagerType ===  "global" && self.states.classManagerFilterLocked === false && self.states.classManagerFilterActive === false && self.states.classManagerFilterStyle === false;

        // Type
        if(self.states.classManagerActiveCategory === "Trash"){
            globalClasses = self.vueState.globalClassesTrash;
        } else if(self.states.classManagerType === "global") {
            globalClasses = self.vueState.globalClasses;
         } else {
            globalClasses = [];
            const tempClasses = self.helpers.getComponentClasses([],self.helpers.getFinalObject(true)?.id);

            if(tempClasses.length > 0){
                tempClasses.forEach(el => {
                    const classObj = self.vueGlobalProp.$_getGlobalClass(el);
                    if(classObj) globalClasses.push(classObj)
                })
                globalClasses = globalClasses.concat(Array.from(self.vueState.globalClasses).filter(el => el && el.new === true))
            }
         }
         // Uncategorized
         if(self.states.classManagerActiveCategory === "Uncategorized"){
            globalClasses = Array.from(globalClasses).filter(el => el && (!el.category || self.helpers.getClassCategoryObjById(el.category) === false));
        
        // Cat
         } else if(self.states.classManagerActiveCategory !== "All" && self.states.classManagerActiveCategory !== "Trash"){
            globalClasses = Array.from(globalClasses).filter(el => el && el.hasOwnProperty('category') && el.category === self.states.classManagerActiveCategory);
         }

         // Search
        globalClasses = (self.states.classManagerSearch === '') ? globalClasses : Array.from(globalClasses).filter(el => el.name.includes(self.states.classManagerSearch));

        // Filter By Style
        if (self.states.classManagerFilterStyle === "has-styles") {
            globalClasses = Array.from(globalClasses).filter(el1 => el1 && self.vueGlobalProp.$_generateCss('globalClass',el1.id,['block']) !== '');
        } else if (self.states.classManagerFilterStyle === "has-no-styles"){
            globalClasses = Array.from(globalClasses).filter(el1 => el1 && self.vueGlobalProp.$_generateCss('globalClass',el1.id,['block']) === '');
        }

        // Filter By Active
        if (self.states.classManagerFilterActive === 'is-active') {
            globalClasses = Array.from(globalClasses).filter(el1 => el1 && Array.from(self.vueState[template]).find(el => el && el.settings._cssGlobalClasses && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.includes(el1.id)));
        } else if (self.states.classManagerFilterActive === 'is-not-active') {
            globalClasses = Array.from(globalClasses).filter(el1 => {
                const matchingElements = Array.from(self.vueState[template]).filter(el => el &&
                  el.settings._cssGlobalClasses &&
                  Array.isArray(el.settings._cssGlobalClasses) &&
                  el.settings._cssGlobalClasses.includes(el1.id)
                );
                return matchingElements.length === 0;
            });
        }
        
        // Filter By Status
        if(self.states.classManagerFilterLocked === "locked"){
            globalClasses = Array.from(globalClasses).filter(el => el && el.hasOwnProperty('id') && self.vueGlobalProp.$_isLocked(el.id));
        } else if(self.states.classManagerFilterLocked === "unlocked"){
            globalClasses = Array.from(globalClasses).filter(el => el && el.hasOwnProperty('id') && !self.vueGlobalProp.$_isLocked(el.id));
        }

        index = 1;
        globalClasses.slice(0, self.states.classManagerMaxClasses).forEach(cls => {

            const active = Array.from(self.vueState[template]).find(el => el && el.settings._cssGlobalClasses && Array.isArray(el.settings._cssGlobalClasses) && el.settings._cssGlobalClasses.includes(cls.id)) ? 'active' : '';
            classes += `<li data-order="${index - 1}" class="${active}${self.states.classManagerActiveClass === cls.id ? ' selected' : ''}" data-id="${cls.id}">
                            <div class="span-wrapper" onClick="ADMINBRXC.selectClass('${cls.id}', this);"${!fullList ? ` data-id="${cls.id}" draggable=true` : ''}>
                                <div class="handle"><i class="fas fa-grip-vertical"></i></div>
                                <span>.${cls.name}</span>
                            </div>
                            <div class="actions">`;
            classes += `${self.vueGlobalProp.$_generateCss('globalClass',cls,['block']) !== '' ? `<div class="css3-icon" data-balloon="Has styles assigned" data-balloon-pos="bottom-right""><span class="bricks-svg-wrapper"><i class="fab fa-css3-alt"></i></span></div>` : ''}
                        ${self.vueGlobalProp.$_isLocked(cls.id) ? `<div class="lock-icon" data-balloon="Unlock class" data-balloon-pos="bottom-right" onclick="ADMINBRXC.changeLockStatus('${cls.id}', 'unlock');"><span class="bricks-svg-wrapper"><i class="fas fa-lock"></i></span></div>` : `<div class="unlock-icon" data-balloon="Lock class" data-balloon-pos="bottom-right" onclick="ADMINBRXC.changeLockStatus('${cls.id}', 'lock');"><span class="bricks-svg-wrapper"><i class="fas fa-unlock"></i></span></div>`}`
            if(self.states.classManagerActiveCategory !== "Trash"){
                classes += `<div class="clone-icon" data-balloon="Duplicate class" data-balloon-pos="bottom-right" onClick="ADMINBRXC.duplicateClass('${cls.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-clone"></i></span></div>
                            <div class="clone-icon" data-balloon="Copy to Clipboard" data-balloon-pos="bottom-right" onClick="ADMINBRXC.copytoClipboardSimple('${cls.name}','${cls.name} successfully copied to clipboard');"><span class="bricks-svg-wrapper"><i class="fas fa-clipboard"></i></span></div>`;
            } else {
                classes += `<div class="clone-icon" data-balloon="Restore class" data-balloon-pos="bottom-right" onClick="ADMINBRXC.restoreClass('${cls.id}');"><span class="bricks-svg-wrapper"><i class="fas fa-trash-restore"></i></span></div>`
            }
            classes += `<div class="trash-icon" data-balloon="${isClassTrash && self.states.classManagerActiveCategory !== "Trash" ? 'Move to Trash' : 'Delete class permanently'}" data-balloon-pos="bottom-right" onClick="ADMINBRXC.deleteClass${self.states.classManagerActiveCategory === "Trash" ? 'Permanently' : ''}('${cls.id}');"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>
                            </div>
                        </li>`;
            if(index === self.states.classManagerMaxClasses && self.states.classManagerMaxClasses < globalClasses.length) classes += `<li class="ignore-drag" onclick="ADMINBRXC.loadMoreClasses(${globalClasses.length});ADMINBRXC.setClassList();"><div class="span-wrapper"><span class="max-results">Load ${globalClasses.length - 50} more classes....</span></div></li>`;
            index++;
        })
        classes += '</ul>';
        if(self.states.classManagerActiveCategory !== "Trash") classes += `<div class="brxc-class-manager__footer"><input type="text" id="addNewClass" placeholder="Add a new class" onkeyup="ADMINBRXC.addNewClass(event);" /></div>`;
        listWrapper.innerHTML = classes;

        //Drag and drop
        if(fullList){
            const classWrapper = listWrapper.querySelector('ul');
            new Sortable(classWrapper, {
                multiDrag: true,
                selectedClass: "sortable-selected", // Class name for selected item
                animation: 150,
                handle: "li .handle",
                filter: ".ignore-drag",
                helper : 'clone',
                onStart: function (evt) {
                    evt.items.length > 0 ? self.states.classManagerStartDrag = evt.items.map(el => el.dataset.id) : self.states.classManagerStartDrag = [evt.item.dataset.id];
                },
                onEnd: function (evt) {
                    const items = Array.from(classWrapper.children).filter(child => child && !child.classList.contains('ignore-drag'));
                    const reorderedClasses = [];
                    const newOrder = items.map(item => parseInt(item.getAttribute('data-order')));
                    newOrder.forEach(el => {
                        reorderedClasses.push(self.vueState.globalClasses[el])
                    })
                    reorderedClasses.forEach((el, ind) => {
                        self.vueState.globalClasses[ind] = JSON.parse(JSON.stringify(el));
                    })
                    self.setClassList();
                    self.setClassContent();
                    self.helpers.saveChanges('globalClasses');
                    setTimeout(() => evt.item.querySelector('.span-wrapper').click(), 0);
                },
            })
        } else {
            const items = listWrapper.querySelectorAll('ul li .span-wrapper');
            items.forEach(el => {
                el.addEventListener('mousedown', (e) => {
                    self.states.classManagerStartDrag = [el.dataset.id];
                })
            })
        }

    },
    setClassContent: function(del = false){
        const self = this;
        const classId = self.states.classManagerActiveClass;
        const arr = self.states.classManagerActiveCategory === "Trash" ? self.vueState.globalClassesTrash : self.vueState.globalClasses;
        const obj = arr.find(el => el && el.id === classId);
        if(!obj) return;

        const contenttWrapper = document.querySelector('#brxcClassManagerOverlay #brxcClassContentCanvas');

        const target = self.helpers.createTarget('_cssCustom');
        const targetSass = self.helpers.createTarget('_cssCustomSass');

        if (classId === '' || del) return contenttWrapper.innerHTML = '<label class="brxc-input__label"><span>Select a class in the left menu.</span></label>';
        // Header
        let header = `<div class="brxc-class-manager__content-header">`
        header += `<div style="width: 100%;"><label class="brxc-input__label has-tooltip"><span>Name</span><span class="brxc__light">(ID: ${obj.id})</span><div data-balloon="To rename the current class, just type the new name inside the input and press ENTER" data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label><input id="nameInput"type="text" value="${obj.name}"/></div>`;
        header += `<div style="width: 75%;position: relative;"><label class="brxc-input__label has-tooltip"><span>Category</span><div data-balloon="To assign the class to specific category, just type the new name inside the input and press ENTER" data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label><input id="catInput"type="text" value="${obj.hasOwnProperty('category') && self.helpers.getClassCategoryNameById(obj.category) !== false ? self.helpers.getClassCategoryNameById(obj.category) : ''}"/></div>`;
        if(self.states.classManagerActiveCategory !== "Trash"){
            header += `<div style="position:relative;"><label class="brxc-input__label has-tooltip"><span>Order</span><div data-balloon="Changing this value will impact the order of the current class inside the Class Dropdown." data-balloon-pos="bottom-right" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
            header += `<input type="text" id="orderInput" value="${arr.indexOf(obj) + 1}"/>`;
            header += `<span class="units">/ ${self.vueState.globalClasses.length}</span></div>`;
        }
        // deleted at
        if(self.states.classManagerActiveCategory === "Trash") {
            const timestamp = obj.deletedAt; 
            const date = new Date(timestamp); 
            const humanDate = date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
              }); 
            header += `<div style="width: 100%;"><label class="brxc-input__label"><span>Deleted at</span></label><input id="deletedAtInput"type="text" value="${humanDate}" readonly/></div>`;
        }
        
        header += `</div>`;

        // Status
        let status = `<div class="wrapper"><div class="left-wrapper"><div class="brxc-class-manager__content-status"><label class="brxc-input__label has-tooltip"><span>Status</span><div data-balloon="Click on the following buttons to lock/unlock the current class" data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label><div class="brxc-overlay__action-btn-wrapper">`
        status += `<div class="brxc-overlay__action-btn${self.vueGlobalProp.$_isLocked(classId) ? ' primary' : ''}" onClick="ADMINBRXC.changeLockStatus('${classId}','lock');">Locked</div>`;
        status += `<div class="brxc-overlay__action-btn${!self.vueGlobalProp.$_isLocked(classId) ? ' primary' : ''}" onClick="ADMINBRXC.changeLockStatus('${classId}','unlock');">Unlocked</div>`;
        status += `</div></div>`;

        // Descriptiom
        let description = `<div class="brxc-class-manager__content-description"><label class="brxc-input__label has-tooltip"><span>Description</span><div data-balloon="Type a description of the class. This field is only for management purposes and has no effect on frontend" data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`;
        description += `<textarea style="margin:0" placeholder="Give your class a description here" oninput="ADMINBRXC.updateClassDescription('${classId}', event.currentTarget.value);">${obj.hasOwnProperty('description') ? obj.description : ''}</textarea>`;
        description += `</div>`
        
        // Class used on the following elements
        let used = '';
        const fullArr = self.helpers.getPageContentAndPageComponents();
        const activeElements = fullArr.filter(el => el.obj && el.obj.hasOwnProperty('settings') && el.obj.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.obj.settings._cssGlobalClasses) && el.obj.settings._cssGlobalClasses.includes(classId));
        if(activeElements.length > 0){
            used += `<div class="brxc-class-manager__content-used"><label class="brxc-input__label has-tooltip"><span>Class used <strong>${activeElements.length} time(s)</strong> on the following elements</span><div data-balloon="The following elements have the current class assigned. Clicking on a button will close the Class Manager and open the selected element inside the builder." data-balloon-pos="bottom" data-balloon-length="large"><i class="fas fa-circle-question"></i></div></label>`;
            used += `<ul class="brxc-overlay__action-btn-wrapper">`; 
            activeElements.forEach(el => {
                used += `<li class="" data-balloon="Open" data-balloon-pos="top" onClick="ADMINBRXC.openElement('${el.obj.id}');ADMINBRXC.closeModal(event, event.target, '#brxcClassManagerOverlay');">
                            <div class="icon"><i class="${bricksData.elements[el.obj.name].icon}"></i></div>
                            <span>${el.obj.label ? self.helpers.escapeHtmlSpecialChars(el.obj.label) : bricksData.elements[el.obj.name].label}</span>
                        </li>`
            })
            used += `</ul></div></div>`; 
        } else {
            used += `<div><label class="brxc-input__label"><span>Used on this page</span></label><p class="no-result" data-control="info">This class isn't set on any element inside this page</p></div></div>`;
        }

        let css = `<div class="brxc-class-manager__content-css">`;
        
        // Custom CSS
        if(self.states.classManagerActiveCategory !== "Trash"){
            css += `<div class="label-wrapper"><label class="brxc-input__label has-tooltip"><span>Custom CSS</span>${self.globalSettings.superPowerCSSEnableSass === "1" ? '<span class="highlight">SASS</span>' : ''}<div data-balloon="The following CSS will be applied to the current class and can be modified inside the Style tab -> Custom CSS control. Click the breakpoint icons to wrap your CSS code inside your desired media-query" data-balloon-pos="bottom-left" data-balloon-length="large"><i class="fas fa-circle-question"></i></div></label>`;
            css += `<ul class="action-wrapper">`;
            if(!self.vueGlobalProp.$_isLocked(obj.id)){
                css += `<li class="brxc-group-icon${self.states.classManagerisAIopen ? ` active` : ""}" data-balloon="Generate CSS with AI" data-balloon-pos="bottom" onclick="ADMINBRXC.activateCSSAI();"><span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-robot" style="width:100%;"></i></span></li>`;
                css += `<li class="brxc-group-icon" data-balloon="Insert %root% {}" data-balloon-pos="bottom" onclick="ADMINBRXC.addRootTag(event, '.brxc-class-manager__content-css');"><span class="bricks-svg-wrapper"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" class="brxc__svg-path"><path d="M28.5 40v-3h6q1.05 0 1.775-.725Q37 35.55 37 34.5v-5q0-1.85 1.125-3.3 1.125-1.45 2.875-2v-.4q-1.75-.5-2.875-1.975T37 18.5v-5q0-1.05-.725-1.775Q35.55 11 34.5 11h-6V8h6q2.3 0 3.9 1.6t1.6 3.9v5q0 1.05.725 1.775Q41.45 21 42.5 21H44v6h-1.5q-1.05 0-1.775.725Q40 28.45 40 29.5v5q0 2.3-1.6 3.9T34.5 40Zm-15 0q-2.3 0-3.9-1.6T8 34.5v-5q0-1.05-.725-1.775Q6.55 27 5.5 27H4v-6h1.5q1.05 0 1.775-.725Q8 19.55 8 18.5v-5q0-2.3 1.6-3.9T13.5 8h6v3h-6q-1.05 0-1.775.725Q11 12.45 11 13.5v5q0 1.85-1.125 3.325T7 23.8v.4q1.75.55 2.875 2T11 29.5v5q0 1.05.725 1.775Q12.45 37 13.5 37h6v3Z"></path></svg></span></li>`;
            }
            
            css += `</ul><ul class="breakpoint-wrapper">`;
            self.vueState.breakpoints.forEach(bp =>{
                let svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M27.744,2.5h-25.488c-0.968,0 -1.756,0.788 -1.756,1.755v17.489c0,0.968 0.788,1.755 1.756,1.755h12.244v3h-5.5c-0.276,0 -0.5,0.224 -0.5,0.5c0,0.276 0.224,0.5 0.5,0.5h12c0.276,0 0.5,-0.224 0.5,-0.5c0,-0.276 -0.224,-0.5 -0.5,-0.5h-5.5v-3h12.244c0.968,0 1.756,-0.788 1.756,-1.755v-17.489c0,-0.967 -0.788,-1.755 -1.756,-1.755Zm-1.244,18h-23v-15h23v15Z" fill="currentColor"></path></svg></span>';
                if( bp.icon === "laptop") {
                    svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M80.14,400c-17.7503,0 -32.14,-14.3897 -32.14,-32.14v-239.72c0,-17.7503 14.3897,-32.14 32.14,-32.14h351.72c17.7503,0 32.14,14.3897 32.14,32.14v239.72c0,17.7503 -14.3897,32.14 -32.14,32.14Z" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path><path fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-width="32" d="M16,416h480"></path></svg></span>';
                }
                if( bp.icon === "tablet-landscape") {
                    svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g transform="matrix(1,0,0,1,0,512)"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M128,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h256c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" transform="matrix(6.12323e-17,-1,1,6.12323e-17,0,0)"></path></g></svg></span>';
                }
                if( bp.icon === "tablet-portrait") {
                    svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M128,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h256c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path></svg></span>';
                }
                if( bp.icon === "phone-landscape") {
                    svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g transform="matrix(1,0,0,1,0,512)"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M176,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h160c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" transform="matrix(6.12323e-17,-1,1,6.12323e-17,0,0)"></path></g><path d="M16,336v-24l9.23706e-14,1.20797e-06c-6.67141e-07,-4.41828 3.58172,-8 8,-8v0h-6.99382e-07c8.83656,3.86258e-07 16,-7.16344 16,-16v-64v0c0,-8.83656 -7.16344,-16 -16,-16v0h-3.49691e-07c-4.41828,-1.93129e-07 -8,-3.58172 -8,-8c0,0 0,-2.84217e-14 0,-2.84217e-14v-24" stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path></svg></span>';
                }
                if( bp.icon === "phone-portrait") {
                    svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"><path d="M176,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h160c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z"></path><path d="M176,16h24l-3.49691e-07,7.10543e-15c4.41828,-1.93129e-07 8,3.58172 8,8v0l1.7053e-13,2.41593e-06c1.33428e-06,8.83656 7.16345,16 16,16h64l-6.99382e-07,-1.42109e-14c8.83656,3.86258e-07 16,-7.16344 16,-16v0l1.13687e-13,1.20797e-06c-6.67141e-07,-4.41828 3.58172,-8 8,-8h24"></path></g></svg></span>';
                }
                let selector = `_cssCustom`;
                if(bp.key !== 'desktop'){
                    selector += `:${bp.key}`;
                }
                css += `<li class="brxc-group-icon${self.vueState.breakpointActive === bp.key ? ' active' : ''}${obj.settings.hasOwnProperty(selector) && obj.settings[selector] !== '' ? ' has-styles' : ''}" data-balloon="${bp.label}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.vueState.breakpointActive = '${bp.key}';ADMINBRXC.setClassContent();">${svg}</li>`;
            })
            css += '</ul></div>';
            if(self.states.classManagerisAIopen && !self.vueGlobalProp.$_isLocked(obj.id)) css += `<div id="submitCSSPromptWrapper"><input type="text" id="submitCSSPrompt" placeholder="Submit your prompt here and hit ENTER" onkeydown="ADMINBRXC.callAPIforClassManagerCSS(event)" /></div>`;
            let cssTarget = self.globalSettings.superPowerCSSEnableSass === "1" && obj.settings.hasOwnProperty('_cssCustomSass') ? targetSass : target;
            const textareaContent = obj.settings.hasOwnProperty(cssTarget) ? obj.settings[cssTarget] : '';
            css += `<div class="brxc-codemirror__wrapper"><textarea data-type="class-manager-custom-css">${self.vueGlobalProp.$_replaceCustomCssRoot('.' + obj.name,'%root%', textareaContent)}</textarea>`;
            css += `<div class="brxc-overlay__action-btn" style="margin-left: auto" onclick="ADMINBRXC.copytoClipboard(this, this.previousElementSibling.CodeMirror.getValue(), 'Copied!', 'Copy to Clipboard')"><span>Copy to Clipboard</span></div></div>`;
        }
        
        // Generated CSS
        css += `<label class="brxc-input__label has-tooltip"><span>Generated CSS</span><div data-balloon="The following CSS is the generated code by Bricks on the frontend, thus it's read-only" data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>`; 
        css += self.setStyleCSS("globalClass", obj, ['block']);
        css += '</div></div>'
        contenttWrapper.innerHTML = header + status + description + used + css;

        // Custom CSS

        function mountCM(classId, isLocked){
            const customCSS = document.querySelector('textarea[data-type="class-manager-custom-css"]');
            if(customCSS){

            }
            const options = self.codeMirrorOptions(document.querySelector('textarea[data-type="class-manager-custom-css"]'));
            options.styleActiveLine = true;
            options.autoCloseBrackets = true;
            options.matchBrackets = true;
            options.selfContain = true;
            options.autofocus = true;
            options.search = { bottom: false };
            options.profile = "xhtml"

            const MyCM = CodeMirror.fromTextArea(document.querySelector('textarea[data-type="class-manager-custom-css"]'), self.codeMirrorOptions(options))
            emmetCodeMirror(MyCM);
            setTimeout(() => {
                MyCM.focus();
                MyCM.setCursor(MyCM.lineCount(), 0);
                if (isLocked) {
                    MyCM.getWrapperElement().classList.add("disable");
                    MyCM.setOption('readOnly',  true);
                }
            }, 1)
            MyCM.getWrapperElement().setAttribute("data-type", "at");
            MyCM.setOption('gutters', []);
            MyCM.on("keydown", function (cm, event) {
                if (!cm.state.completionActive &&
                    ((event.key >= '0' && event.key <= '9') ||    // Digits 0-9
                        (event.key >= 'a' && event.key <= 'z') ||    // Letters a-z
                        event.key === '(' || event.key === '!' ||    // Opening parenthesis (
                        event.key === '-') &&                        // Dash
                    !event.metaKey && !event.altKey && event.key !== '{' && event.key !== '}' &&
                    !event.ctrlKey) {
                    CodeMirror.commands.autocomplete(cm, null, { completeSingle: false });
                }

                if(event.metaKey && event.shiftKey && event.key === "7" ){
                    cm.toggleComment();
                }

                if (event.key === 'Tab') {
                    self.helpers.replaceRWithRoot(cm, event)
                }
            })
            let sass = false;
            if(self.globalSettings.superPowerCSSEnableSass === "1"){
                self.destroySassInstances();
                sass = self.createSassInstance();
            }

            MyCM.on("keyup", function (cm) {
                const obj = self.vueGlobalProp.$_getGlobalClass(classId);
                if (!obj) return;

                const selector = `.${obj.name}`;
                const newValue = self.vueGlobalProp.$_replaceCustomCssRoot('%root%', selector, cm.getValue());

                if(Object.getPrototypeOf(obj.settings).length === 0) obj.settings = {};

                if (newValue === "") {
                    delete obj.settings[target];
                    if(self.globalSettings.superPowerCSSEnableSass === "1") delete obj.settings[targetSass];
                } else {
                    if(self.globalSettings.superPowerCSSEnableSass === "1"){
                        const dataOptions = { indent_size: 2 }
                        obj.settings[targetSass] = newValue;

                        // Compiled CSS
                        if(sass){
                            sass.compile( newValue, function(result) {
                                if (result.status === 0) {
                                    const strippedComment = self.helpers.removeCommentedCSS(result.text) ? self.helpers.removeCommentedCSS(result.text) : false;
                                    if(strippedComment){
                                        const vanillaCSS = css_beautify( strippedComment, dataOptions);
                                        obj.settings[target] = vanillaCSS;
                                    }
                                }
                            });
                        }
                    } else {
                        obj.settings[target] = newValue;
                    }
                }

                // Generated CSS
                const generatedCSS = contenttWrapper.querySelector('[data-type="generated-css"]');
                const dataOptions = { indent_size: 2 }
                setTimeout(() => {generatedCSS.CodeMirror.setValue(css_beautify(self.vueGlobalProp.$_generateCss('globalClass', classId, ['block']).replaceAll('.brxe-block', ''), dataOptions))}, 100);
                
                // Save Global Classes
                self.helpers.saveChanges('globalClasses');
            });
        }

        if(self.states.classManagerActiveCategory !== "Trash") mountCM(classId, self.vueGlobalProp.$_isLocked(classId))

        // Generated CSS
        const textarea= contenttWrapper.querySelector('textarea.brxc-style-overview-css');
        if(textarea) {
            const dataOptions = { indent_size: 2 }
            const dataObj = textarea.textContent.replaceAll('.brxe-block', '');
            const options = self.codeMirrorOptions(textarea);
            options.autofocus = false;
            const MyCM = CodeMirror.fromTextArea(textarea, self.codeMirrorOptions(options));
            MyCM.getWrapperElement().setAttribute('data-type', 'generated-css');
            MyCM.setValue(css_beautify(dataObj, dataOptions));
            MyCM.setOption('readOnly',  true);
            MyCM.setOption('gutters', []);
        };

        // Name event
        const nameInput = contenttWrapper.querySelector('#nameInput');
        if(nameInput){
            nameInput.addEventListener('keyup', function(e){
                if (e.key === 'Enter'){

                    function replaceRootCustomCss(target, obj, oldName, newName){
                        if(obj.settings.hasOwnProperty(target)) return obj.settings[target] = obj.settings[target].replaceAll(`.${oldName}`, `.${newName}`);
            
                    }
                    function loopCustomCss(obj, oldName, newName){
                        let target = "_cssCustom";
                        if(obj.settings.hasOwnProperty(target)) replaceRootCustomCss(target, obj, oldName, newName);
                        const bps = self.vueState.breakpoints
                        bps.forEach(bp => {
                            target += `:${bp.key}`;
                            if(obj.settings.hasOwnProperty(target)) replaceRootCustomCss(target, obj, oldName, newName);
                        })
                    }

                    const arr = self.states.classManagerActiveCategory === "Trash" ? self.vueState.globalClassesTrash : self.vueState.globalClasses;
                    const obj = arr.find(el => el && el.hasOwnProperty('id') && el.id === self.states.classManagerActiveClass);
                    if(!obj || !obj.hasOwnProperty('name')) return;

                    const oldName = obj.name;
                    if(nameInput.value.length < 1) return self.vueGlobalProp.$_showMessage('Insert at least 1 character');
                    if(!self.helpers.isValidCSSClassName(nameInput.value)) return self.vueGlobalProp.$_showMessage('Invalid Character in the class name');
                    if(oldName === nameInput.value) return;
                    if(Array.from(self.vueState.globalClasses).find(el => el && el.hasOwnProperty('name') && el.name === nameInput.value)) return self.vueGlobalProp.$_showMessage('Class Name already exists!');
                    
                    obj.name = nameInput.value;
                    loopCustomCss(obj, oldName, nameInput.value);
                    self.setClassList();
                    self.setClassContent();
                    self.vueGlobalProp.$_showMessage('Class successfully renamed!');
                    self.helpers.saveChanges('globalClasses');
                }
            })
        }

        // Cat event
        const catInput = contenttWrapper.querySelector('#catInput');
        if(catInput){
            catInput.addEventListener('keyup', function(e){
                if (e.key === 'Enter'){
                    const arr = self.states.classManagerActiveCategory === "Trash" ? self.vueState.globalClassesTrash : self.vueState.globalClasses;
                    const obj = arr.find(el => el && el.hasOwnProperty('id') && el.id === self.states.classManagerActiveClass);
                    if(!obj) return;

                    const oldCat = obj.category;
                    const oldCatObj = self.helpers.getClassCategoryNameById(oldCat);
                    if(catInput.value.length < 1) {
                        delete obj.category;
                        return self.vueGlobalProp.$_showMessage('Category successfully removed!')
                    }
                    if(oldCat && oldCatObj.name === catInput.value) return;
                    let newCatId;
                    if(!Array.from(self.vueState.globalClassesCategories).map(el => el && el.name).includes(catInput.value)) {
                        newCatId = self.vueGlobalProp.$_generateId()
                        self.vueState.globalClassesCategories.push({
                            id: newCatId,
                            name: catInput.value,
                        })
                        obj.category = newCatId;
                        self.states.classManagerActiveCategory = newCatId;
                    } else {
                        newCatId = self.helpers.getClassCategoryIdByName(catInput.value);
                        obj.category = newCatId;
                    }
                    self.states.classManagerActiveCategory = newCatId;
                    self.populateClassCategories();
                    self.setCatList();
                    self.setClassList();
                    self.setClassContent();
                    self.vueGlobalProp.$_showMessage(`Class successfully assigned to the category ${catInput.value}!`);
                    self.helpers.saveChanges('globalClasses');
                }
            })
            catInput.addEventListener('keydown', () =>{
                self.autocomplete(catInput,Array.from(self.vueState.globalClassesCategories).map(el => el && el.name),false)
            })
        }

        // Order event
        const orderInput = contenttWrapper.querySelector('#orderInput');
        if(orderInput){
            orderInput.addEventListener('keyup', function(e){
                if (e.key === 'Enter'){
                    self.changeClassOrder(self.states.classManagerActiveClass,parseInt(orderInput.value - 1) );
                    self.helpers.saveChanges('globalClasses');
                }
            })
        }
    },
    updateClassDescription(classId, value){
        const self = this;
        const arr = self.states.classManagerActiveCategory === "Trash" ? self.vueState.globalClassesTrash : self.vueState.globalClasses;
        const classObj = arr.find(el => el && el.hasOwnProperty('id') && el.id === classId);
        classObj.description = value;
    },
    applyCSSAIgenerated: function(generatedCSS){
        const self = this;
        const target = self.helpers.createTarget('_cssCustom');
        const css = JSON.parse(generatedCSS).css;
        const arr = self.states.classManagerActiveCategory === "Trash" ? self.vueState.globalClassesTrash : self.vueState.globalClasses;
        const classObj = arr.find(el => el && el.hasOwnProperty('id') && el.id === self.states.classManagerActiveClass);
        if(classObj) classObj.settings[target] = css_beautify(css, { indent_size: 2 });
        setTimeout(self.setClassContent(), 5);
    },
    callAPIforClassManagerCSS: function(event,target){
        const self = this;
        if(event.key !== "Enter") return;
        const input = (event.target.value.length > 0) ? `${event.target.value}` : '';
        if (input === '') return;
        const defaultModel = self.globalSettings.defaultAIModel;
        const wrapper = document.querySelector('#submitCSSPromptWrapper');
        var z = document.createElement('span'); // is a node
        z.setAttribute('class', 'brxc-overlay__action-btn primary disable');
        wrapper.appendChild(z);
        const arr = self.states.classManagerActiveCategory === "Trash" ? self.vueState.globalClassesTrash : self.vueState.globalClasses;
        const activeClassObj = arr.find(el => el && el.hasOwnProperty('id') && el.id === self.states.classManagerActiveClass);
        if(!activeClassObj) return;
        const activeClassName = activeClassObj.name
        const cm = document.querySelector('textarea[data-type="class-manager-custom-css"] + .CodeMirror').CodeMirror;
        const existingCSS = self.vueGlobalProp.$_replaceCustomCssRoot('%root%', `.${activeClassName }`,cm.getValue());

        let message = `Add CSS code targeting the class .${activeClassName}. The CSS code should do this:${input}.`
        if(existingCSS !== '') message += `The existing CSS code is the following: ${existingCSS}. Please merge your code with the existing one in a unique declaration (if possible).`;
    
        //target.classList.add('disable');
        const json = {
            "model": defaultModel,
            "messages": [
              {
                "role": "user",
                "content": `${message}`
              }
            ],
            "functions":[{
                "name":"applyCSSAIgenerated",
                "description":"Generate CSS code based on the instructions provided.",
                "parameters":{
                   "type":"object",
                   "properties":{
                        "css":{
                            "type":"string",
                            "description":"The CSS code"
                        }
                   }
                }
             }],
            "function_call": "auto" 
          }

        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce,
            },
            success: function(response) {
                const post = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'Authorization' : 'Bearer '+ response,
                        },
                      body: JSON.stringify(json)
                    });
                    const content = await rawResponse.json();
                    const disable = document.querySelector('#submitCSSPromptWrapper .brxc-overlay__action-btn.primary.disable');
                    disable.remove();
                    if(content.error){
                        self.insertErrorMessage('classManager', false, '#brxcClassManagerOverlay', content.error.message);
                    } else {
                        self.applyCSSAIgenerated(content.choices[0].message.function_call.arguments);
                    }
                };
                post();
            },
            error: function(response){
                console.log('Something went wrong with the OpenAI AJAX request: ' + response);
                target.classList.remove('disable');
            }
        });


    },
    activateCSSAI: function(){
        const self = this;
        self.states.classManagerisAIopen ? self.states.classManagerisAIopen = false : self.states.classManagerisAIopen = true;
        self.setClassContent();
    },
    savePost: function(btn){
        const self = this;
        self.vueGlobalProp.$_savePost();
        btn.classList.add('disable');
        setTimeout(() => {
            btn.classList.remove('disable');
        }, 2000)
    },
    duplicateClass: function(classId){
        const self = this;
        const originalObj = self.vueGlobalProp.$_getGlobalClass(classId);
        if(!originalObj) return;

        const obj = JSON.parse(JSON.stringify(originalObj));
        const objOrder = self.vueState.globalClasses.indexOf(originalObj);

        function checkName(classname){
            if(Array.from(self.vueState.globalClasses).find(el => el && el.hasOwnProperty('name') && el.name === `${classname}-new`)){
                return checkName(`${classname}-new`);
            } else {
                return `${classname}-new`;
            }
        }

        self.vueState.globalClasses.push(obj);
        const newId = self.vueGlobalProp.$_generateId();
        const oldName = obj.name;
        const newClass = self.vueState.globalClasses[self.vueState.globalClasses.length - 1];
        newClass.id = newId;
        newClass.name = checkName(newClass.name);
        newClass.settings = JSON.parse(JSON.stringify(newClass.settings).replaceAll(oldName, newClass.name));
        newClass.new = true;
        self.helpers.moveArr(self.vueState.globalClasses, self.vueState.globalClasses.length - 1, parseInt(objOrder + 1), 1);
        setTimeout(() => {
            self.helpers.saveChanges('globalClasses');
            self.states.classManagerActiveClass = newId;
            self.setClassList();
            self.setClassContent();
            self.setCatList();
        }, 10);
        

    },
    addNewClass: function(event){
        const self = this;

        if(event.key !== "Enter") return;
        const values = event.target.value.split(' ');
        if(values.length < 1) return;

        values.forEach(el => {
            if(!self.helpers.isValidCSSClassName(el)) return self.vueGlobalProp.$_showMessage('Invalid Character in the class name');
            const exist = Array.from(self.vueState.globalClasses).find(el2 => el2 && el2.hasOwnProperty('name') && el2.name === el);
            if(typeof exist === "object") {
                self.states.classManagerActiveClass = exist.id;
                if(self.states.classManagerActiveCategory && self.states.classManagerActiveCategory !== "All" && self.states.classManagerActiveCategory !== "Uncategorized") exist.category = self.states.classManagerActiveCategory;
                
                self.vueGlobalProp.$_showMessage('Class already exists');
            } else {
                const id = self.vueGlobalProp.$_generateId();
                const obj = {
                    id: id,
                    name: el,
                    settings: {},
                    new: true,
                };
                if(self.states.classManagerActiveCategory && self.states.classManagerActiveCategory !== "All" && self.states.classManagerActiveCategory !== "Uncategorized") obj.category = self.states.classManagerActiveCategory;
                
                self.vueState.globalClasses.push(obj);
                self.states.classManagerActiveClass = id;
                self.vueGlobalProp.$_showMessage('Class successfully created');
            }
        })
        setTimeout(() => {
            self.setClassContent();
            self.setClassList();
            self.setCatList();
        },10)  
    },
    deleteClass: function(classId){
        const self = this;

        // Move to Trash
        if(self.vueState.hasOwnProperty('globalClassesTrash') && Array.isArray(self.vueState.globalClassesTrash) && self.states.classManagerActiveCategory !== "Trash"){
            self.vueGlobalProp.$_moveGlobalClassesToTrash(classId);
        
        // Remove class from Global Classes
        } else {
            const arr =  self.states.classManagerActiveCategory === "Trash" ? self.vueState.globalClassesTrash : self.vueState.globalClasses;
            const classObj = arr.find(el => el && el.id === classId);
            if(!classObj) return;

            const classIndex = parseInt(arr.indexOf(classObj));

            // Remove class from Global Classes
            arr.splice(classIndex,1);
        }

        if(self.states.classManagerActiveClass === classId) self.states.classManagerActiveClass = '';

        setTimeout(()=> {
            self.setClassList();
            self.setClassContent(true);
            self.setCatList();
        },10)

    },
    deleteClassPermanently: function(classId) {
        const self = this;
    
        if (self.states.classManagerActiveClass === classId) self.states.classManagerActiveClass = '';
    
        self.vueGlobalProp.$_deleteClassesPermanently(classId)
            .then(() => {
                setTimeout(() => {
                    self.setClassList();
                    self.setClassContent(true);
                    self.setCatList();
                }, 0);
            })
            .catch(error => {
                console.error("Error deleting class:", error);
            });
    },
    restoreClass: function(classId){
        const self = this;

        self.vueGlobalProp.$_restoreGlobalClasses(classId);

        setTimeout(()=> {
            self.setClassList();
            self.setClassContent(true);
            self.setCatList();
        },10)

    },
    selectClass: function(classId, target){
        const self = this;
        self.states.classManagerActiveClass = classId;
        const lists = document.querySelectorAll('#brxcClassListCanvas li');
        lists.forEach(list => {
            list.classList.remove('selected');
        })
        const selected = document.querySelector(`#brxcClassListCanvas li[data-id="${classId}"]`);
        if(selected) selected.classList.add('selected');
        self.setClassContent()
    },
    changeClassOrder: function(classId, newOrder){
        const self = this;
        const classObj = self.vueGlobalProp.$_getGlobalClass(classId);
        if(!classObj) return;

        const oldOrder = self.vueState.globalClasses.indexOf(classObj);
        if(oldOrder === newOrder){
            return;
        } else{
            self.helpers.moveArr(self.vueState.globalClasses, oldOrder, newOrder, 1);
            self.vueGlobalProp.$_showMessage('Class order successfullt changed');
        }
        self.helpers.saveChanges('globalClasses');
        self.setClassList();

    },
    changeLockStatus: function(classId, status){
        const self = this;
        if (status === "lock" && !self.vueState.globalClassesLocked.includes(classId)){
            self.vueState.globalClassesLocked.push(classId);
            self.vueGlobalProp.$_showMessage('Class successfully locked');
        } else if(status === "unlock" && self.vueState.globalClassesLocked.includes(classId)){
            const index = self.vueState.globalClassesLocked.indexOf(classId);
            self.vueState.globalClassesLocked.splice(index,1);
            self.vueGlobalProp.$_showMessage('Class successfully unlocked');
        }
        self.helpers.saveChanges('globalClassesLocked');
        self.setClassContent();
        self.setClassList();

    },
    openElement: function(id){
        const self = this;
        const obj = self.helpers.getElementObject(id)
        self.vueState.activePanel = "element";
        self.vueState.activeId = id;
        self.vueState.activeElement = obj;

        if(self.vueState.hasOwnProperty('components') && self.vueState.components.some(el => el.id === id)){
            self.vueState.activeComponent = self.vueState.components.find(el => el.id === id);
        }

        if(self.helpers.isElementInComponent(id)){
            self.vueState.activeComponent = self.helpers.getComponentByElementId(id)
        }

        // const el = FRAMEBRXC.vueGlobalProp.$_getElementNode(obj);
        // if(el){
        //     setTimeout(()=>{
        //         el.scrollIntoView({ behavior: "smooth"});
        //     },10)
        // }
        
    },
    filterClassesByStyle: function(btn){
        const self = this;
        if (self.states.classManagerFilterStyle === false){
            self.states.classManagerFilterStyle = "has-no-styles";
            btn.classList.add("locked");
        } else if (self.states.classManagerFilterStyle === "has-no-styles"){
            self.states.classManagerFilterStyle = "has-styles";
            btn.classList.remove("locked")
            btn.classList.add("unlocked");
        } else {
            self.states.classManagerFilterStyle = false;
            btn.classList.remove("unlocked")
        }
        self.setClassList();
    },
    filterClassesByActive: function(btn){
        const self = this;
        if (self.states.classManagerFilterActive === false){
            self.states.classManagerFilterActive = "is-not-active";
            btn.classList.add("locked");
        } else if (self.states.classManagerFilterActive === "is-not-active"){
            self.states.classManagerFilterActive = "is-active";
            btn.classList.remove("locked")
            btn.classList.add("unlocked");
        } else {
            self.states.classManagerFilterActive = false;
            btn.classList.remove("unlocked")
        }
        self.setClassList();
    },
    filterClassesByStatus: function(btn){
        const self = this;
        if (self.states.classManagerFilterLocked === false){
            self.states.classManagerFilterLocked = "locked";
            btn.classList.add("locked");
        } else if (self.states.classManagerFilterLocked === "locked"){
            self.states.classManagerFilterLocked = "unlocked";
            btn.classList.remove("locked")
            btn.classList.add("unlocked");
        } else {
            self.states.classManagerFilterLocked = false;
            btn.classList.remove("unlocked")
        }
        self.setClassList();
    },
    resetFilter: function(btn){
        const self = this;
        btn.parentElement.previousElementSibling.previousElementSibling = '';
        self.states.classManagerSearch = '';
        self.states.classManagerFilterLocked = false;
        self.states.classManagerFilterActive = false;
        self.states.classManagerFilterStyle = false;
        self.setClassList();
    },
    setColumnNumber: function(num){
        let wrapper = document.querySelector('#bricks-panel-elements #bricks-panel-elements-categories');
        if(!wrapper) return;
        wrapper.setAttribute('data-col', num);
    },
    collapseElementsState : 'collapse',
    collapseElements: function(){
        const self = this;
        const panel = document.querySelector('#bricks-panel-elements');
        if(!panel) return;

        const cats = panel.querySelectorAll('#bricks-panel-elements-categories li.category');
        if(!cats || cats.lentgh < 1) return;
        
        if(self.collapseElementsState === "collapse"){
            cats.forEach(cat => {
                const title = cat.querySelector('.category-title ');
                if(!title) return;
                if(title.classList.contains('expand')){
                    const svg = cat.querySelector('.wrap + span.bricks-svg-wrapper')
                    if(!svg) return;
                    svg.click();
                }
            })
            self.collapseElementsState = "expand";
        } else {
            cats.forEach(cat => {
                const title = cat.querySelector('.category-title ');
                if(!title) return;
                if(!title.classList.contains('expand')){
                    const svg = cat.querySelector('.wrap + span.bricks-svg-wrapper')
                    if(!svg) return;
                    svg.click();
                }
            })
            self.collapseElementsState = "collapse";
        }
    },
    setElementsColumns: function(){
        const self = this;
        if (self.vueState.activePanel !== 'elements') return;

        const header = document.querySelector('#bricks-panel-inner #bricks-panel-elements #bricks-panel-header')
        const oldMenu = document.querySelector('#bricks-panel-view');
        if(oldMenu) oldMenu.remove();
    
        const wrapper = document.createElement("UL");
        wrapper.setAttribute("id", "bricks-panel-view");
        header.after(wrapper);
        self.addIconToFields('li','brxc-header-icon brxc-header-icon__hover', false, '1-col', 'bottom-right', 'ADMINBRXC.setColumnNumber(1)', true, '<span class="bricks-svg-wrapper"><i class="ti-layout-column3-alt"></i></span>', wrapper, 'child');
        self.addIconToFields('li','brxc-header-icon brxc-header-icon__hover', false, '2-col', 'bottom-right', 'ADMINBRXC.setColumnNumber(2)', true, '<span class="bricks-svg-wrapper"><i class="ti-layout-column2-alt"></i></span>', wrapper, 'child');
        self.addIconToFields('li','brxc-header-icon brxc-header-icon__hover', false, '3-col', 'bottom-right', 'ADMINBRXC.setColumnNumber(3)', true, '<span class="bricks-svg-wrapper"><i class="ti-layout-column3-alt"></i></span>', wrapper, 'child');
        self.addIconToFields('li','brxc-header-icon brxc-header-icon__hover', false, '4-col', 'bottom-right', 'ADMINBRXC.setColumnNumber(4)', true, '<span class="bricks-svg-wrapper"><i class="ti-layout-column4-alt"></i></span>', wrapper, 'child');
        
        const expandSVG = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g fill="currentColor" fill-rule="evenodd"><path d="M2,8l5.32907e-15,7.54979e-08c-4.16963e-08,-0.276142 0.223858,-0.5 0.5,-0.5h11l-2.18557e-08,8.88178e-16c0.276142,-1.20706e-08 0.5,0.223858 0.5,0.5c1.20706e-08,0.276142 -0.223858,0.5 -0.5,0.5h-11l-2.78181e-08,-3.55271e-15c-0.276142,-4.49893e-08 -0.5,-0.223858 -0.5,-0.5Zm6,-1.5l-2.18557e-08,-8.88178e-16c0.276142,1.20706e-08 0.5,-0.223858 0.5,-0.5v-4.5v0c0,-0.276142 -0.223858,-0.5 -0.5,-0.5c-0.276142,0 -0.5,0.223858 -0.5,0.5v4.5l5.32907e-15,7.54979e-08c4.16963e-08,0.276142 0.223858,0.5 0.5,0.5Z"></path><path d="M10.354,3.854l2.23014e-08,-2.2245e-08c0.195509,-0.195015 0.195909,-0.511597 0.000893739,-0.707106c-0.000297551,-0.000298304 -0.000595479,-0.000596232 -0.000893784,-0.000893784l-2,-2l4.41373e-09,4.4249e-09c-0.195015,-0.195509 -0.511597,-0.195909 -0.707106,-0.000893793c-0.000298304,0.000297551 -0.000596232,0.000595479 -0.000893784,0.000893784l-2,2l-2.1107e-09,2.1107e-09c-0.195509,0.195509 -0.195509,0.512491 4.22141e-09,0.708c0.195509,0.195509 0.512491,0.195509 0.708,-4.22141e-09l1.646,-1.647l1.646,1.647l-3.52833e-08,-3.53726e-08c0.195015,0.195509 0.511597,0.195909 0.707106,0.000893854c0.000298304,-0.000297551 0.000596233,-0.000595479 0.000893784,-0.000893784Zm-2.354,5.646h-2.18557e-08c0.276142,-1.20706e-08 0.5,0.223858 0.5,0.5v4.5v0c0,0.276142 -0.223858,0.5 -0.5,0.5c-0.276142,0 -0.5,-0.223858 -0.5,-0.5v-4.5l5.32907e-15,7.54979e-08c-4.16963e-08,-0.276142 0.223858,-0.5 0.5,-0.5Z"></path><path d="M10.354,12.146l2.23014e-08,2.2245e-08c0.195509,0.195015 0.195909,0.511597 0.000893739,0.707106c-0.000297551,0.000298304 -0.000595479,0.000596232 -0.000893784,0.000893784l-2,2l4.41373e-09,-4.4249e-09c-0.195015,0.195509 -0.511597,0.195909 -0.707106,0.000893793c-0.000298304,-0.000297551 -0.000596232,-0.000595479 -0.000893784,-0.000893784l-2,-2l-2.1107e-09,-2.1107e-09c-0.195509,-0.195509 -0.195509,-0.512491 4.22141e-09,-0.708c0.195509,-0.195509 0.512491,-0.195509 0.708,4.22141e-09l1.646,1.647l1.646,-1.647l-3.52833e-08,3.53726e-08c0.195015,-0.195509 0.511597,-0.195909 0.707106,-0.000893854c0.000298304,0.000297551 0.000596233,0.000595479 0.000893784,0.000893784Z"></path></g></svg></span>';
        const collapseSVG = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g fill="currentColor" fill-rule="evenodd"><path d="M2,8l5.32907e-15,7.54979e-08c-4.16963e-08,-0.276142 0.223858,-0.5 0.5,-0.5h11l-2.18557e-08,8.88178e-16c0.276142,-1.20706e-08 0.5,0.223858 0.5,0.5c1.20706e-08,0.276142 -0.223858,0.5 -0.5,0.5h-11l-2.78181e-08,-3.55271e-15c-0.276142,-4.49893e-08 -0.5,-0.223858 -0.5,-0.5Zm6,-7h-2.18557e-08c0.276142,-1.20706e-08 0.5,0.223858 0.5,0.5v4.5v0c0,0.276142 -0.223858,0.5 -0.5,0.5c-0.276142,0 -0.5,-0.223858 -0.5,-0.5v-4.5l5.32907e-15,7.54979e-08c-4.16963e-08,-0.276142 0.223858,-0.5 0.5,-0.5Z"></path><path d="M10.354,3.646l2.23014e-08,2.2245e-08c0.195509,0.195015 0.195909,0.511597 0.000893739,0.707106c-0.000297551,0.000298304 -0.000595479,0.000596232 -0.000893784,0.000893784l-2,2l4.41373e-09,-4.4249e-09c-0.195015,0.195509 -0.511597,0.195909 -0.707106,0.000893793c-0.000298304,-0.000297551 -0.000596232,-0.000595479 -0.000893784,-0.000893784l-2,-2l-2.1107e-09,-2.1107e-09c-0.195509,-0.195509 -0.195509,-0.512491 4.22141e-09,-0.708c0.195509,-0.195509 0.512491,-0.195509 0.708,4.22141e-09l1.646,1.647l1.646,-1.647l-3.52833e-08,3.53726e-08c0.195015,-0.195509 0.511597,-0.195909 0.707106,-0.000893854c0.000298304,0.000297551 0.000596233,0.000595479 0.000893784,0.000893784Zm-2.354,11.354h-2.18557e-08c0.276142,1.20706e-08 0.5,-0.223858 0.5,-0.5v-4.5v0c0,-0.276142 -0.223858,-0.5 -0.5,-0.5c-0.276142,0 -0.5,0.223858 -0.5,0.5v4.5l5.32907e-15,7.54979e-08c4.16963e-08,0.276142 0.223858,0.5 0.5,0.5Z"></path><path d="M10.354,12.354l2.23014e-08,-2.2245e-08c0.195509,-0.195015 0.195909,-0.511597 0.000893739,-0.707106c-0.000297551,-0.000298304 -0.000595479,-0.000596232 -0.000893784,-0.000893784l-2,-2l4.41373e-09,4.4249e-09c-0.195015,-0.195509 -0.511597,-0.195909 -0.707106,-0.000893793c-0.000298304,0.000297551 -0.000596232,0.000595479 -0.000893784,0.000893784l-2,2l-2.1107e-09,2.1107e-09c-0.195509,0.195509 -0.195509,0.512491 4.22141e-09,0.708c0.195509,0.195509 0.512491,0.195509 0.708,-4.22141e-09l1.646,-1.647l1.646,1.647l-3.52833e-08,-3.53726e-08c0.195015,0.195509 0.511597,0.195909 0.707106,0.000893854c0.000298304,-0.000297551 0.000596233,-0.000595479 0.000893784,-0.000893784Z"></path></g></svg></span>';
        const finalSVG = self.collapseElementsState === "collapse" ? collapseSVG : expandSVG;
        const balloon = self.collapseElementsState === "collapse" ? "Collapse All" : "Expand All";
        self.addIconToFields('li','brxc-header-icon brxc-header-icon__hover', false, balloon, 'bottom-right', 'ADMINBRXC.collapseElements()', true, finalSVG, wrapper, 'child');
    },
    panelSwitch: function(el){
        const self = this;
        if(el.dataset.panelGroup) {
            self.vueState.activePanelGroup = el.dataset.panelGroup
            const items = document.querySelectorAll('#bricks-panel-element .brxce-panel-shortcut__wrapper li');
            if(items && items.length > 0){
                items.forEach(item => {
                    item.dataset.panelGroup === el.dataset.panelGroup ? item.classList.add('active') : item.classList.remove('active');
                })
            }
        } else{
            self.vueState.activePanelGroup = ''
        }
        if (el.dataset.panel) self.vueState.activePanelTab = el.dataset.panel;
        
    },
    panelShortcuts: function(){
        const self = this;

        const panelElement = document.querySelector('#bricks-panel-element');
        if( !panelElement) return

        let wrapper = panelElement.querySelector('.brxce-panel-shortcut__wrapper');
        if (wrapper) wrapper.remove();
        
        if(!self.helpers.isElementActive()) return;
        
        panelElement.setAttribute("data-active", "true");

        const panelHeader = panelElement.querySelector('#bricks-panel-header')
        if (!panelHeader) return;

        //component
        if(self.helpers.isComponentPanelOpen()) return;

        let activeTabs = [];

        const elementObj = self.helpers.getFinalObject(true);
        const elementObjWithClasses = self.helpers.getFinalObject();

        function calculateActiveTabs(){
            const name = elementObj.name;
            const settings = elementObjWithClasses?.settings;
            const activeBp = self.vueState.breakpointActive;
            const activePseudo = self.vueState.pseudoClassActive;

            let suffix = "";
            if(activeBp !== "desktop") suffix += `:${activeBp}`;
            if(activePseudo !== "") suffix += activePseudo;

            for(const key of Object.keys(settings)){
                const setting = key.split(':')[0];
                if(key === "_cssClasses" || key === "_cssId" || key === "_attributes" || key === `${setting}${suffix}`){
                    if(bricksData.elements[name]?.controls[setting] && bricksData.elements[name]?.controls[setting].hasOwnProperty('group')) activeTabs.push(bricksData.elements[name].controls[setting].group);
                } 
            }
            return activeTabs = [...new Set(activeTabs)];
        }

        calculateActiveTabs();

        var keyboard = 0;
        wrapper = `<div class="brxce-panel-shortcut__wrapper"><div class="brxce-panel-shortcut__container">`;
        if (Object.values(self.globalSettings.shortcutsTabs).includes('content')) {
            wrapper += `<li ${self.vueState.activePanelTab === "content" ? 'class="active"' : ''}data-panel="content" data-balloon="Content" data-order="${keyboard}" data-balloon-pos="right"><span class="bricks-svg-wrapper"><i class="fas fa-pen"></i></span><span class="keyboard-shortcut">${keyboard}</span></li>`;
        }
        if(Object.values(self.globalSettings.classFeatures).includes("disable-id-styles") && self.forceClassStlyesStates.showLock === true) {
            wrapper += `</div></div>`;
            panelHeader.insertAdjacentHTML('afterend', wrapper);
            const activePanel = panelElement.querySelector('[data-panel="content"]')
            activePanel?.classList.add('active')
            return;
        }

        if(!bricksData.elements[elementObj.name]) return; 
        const controlGroups = bricksData.elements[elementObj.name].controlGroups;
        
        function createIcon(activeTab, balloon, icon ){
            keyboard++;
            return `<li class="${activeTabs.includes(activeTab) ? 'has-settings' : ''}${self.vueState.activePanelTab === "style" && activeTab === self.vueState.activePanelGroup ? ' active' : ''}" data-panel="style" data-panel-group="${activeTab}"${keyboard < 10 ? ` data-order="${keyboard}"` : ''} data-balloon="${balloon}" data-balloon-pos="right"><span class="bricks-svg-wrapper"><i class="${icon}"></i></span>${keyboard < 10 ? `<span class="keyboard-shortcut">${keyboard}</span>` : '' }</li>`;
        }

        function createIconConfig(tabKey, balloon, icon) {
            return {
                tabKey,
                balloon,
                icon
            };
        }

        const shortcutConfigs = [
            createIconConfig('_layout', 'Layout', 'fas fa-layer-group'),
            createIconConfig('_typography', 'Typography', 'fas fa-font'),
            createIconConfig('_background', 'Background', 'fas fa-image'),
            createIconConfig('_border', 'Border', 'fas fa-border-all'),
            createIconConfig('_gradient', 'Gradient / Overlay', 'fas fa-brush'),
            createIconConfig('_shapes', 'Shape Dividers', 'fas fa-shapes'),
            createIconConfig('_transform', 'Transform', 'fas fa-wand-magic-sparkles'),
            createIconConfig('_filter', 'Filters / Transitions', 'fas fa-filter'),
            createIconConfig('_css', 'CSS', 'fab fa-css3-alt'),
            createIconConfig('_classes', 'Classes / ID', 'fas fa-id-card'),
            createIconConfig('_attributes', 'Attributes', 'fas fa-database'),
            createIconConfig('_generated-code', 'Generated Code', 'fab fa-html5'),
            createIconConfig('_pageTransition', 'Page Transition', 'fas fa-clone'),
        ];

        shortcutConfigs.forEach(config => {
            const { tabKey, balloon, icon } = config;

            if (Object.values(self.globalSettings.shortcutsTabs).includes(tabKey.replaceAll('_','')) && typeof controlGroups !== "undefined" && controlGroups.hasOwnProperty(tabKey)) {
                wrapper += createIcon(tabKey, balloon, icon);
            }
        });

        wrapper += `</div></div>`;

        panelHeader.insertAdjacentHTML('afterend', wrapper);

        const items = document.querySelectorAll('#bricks-panel-element .brxce-panel-shortcut__wrapper li');
        setTimeout(() => {
            items.forEach(item => {
                item.addEventListener('mousedown', () => {
                    self.vueState.brxc.clickedOnLeftPanelShortcuts = true;
                    if(self.vueState.activePanelTab === "style" && self.vueState.activePanelGroup === item.dataset.panelGroup) {
                        self.vueState.activePanelGroup = '';
                    } else {
                        self.panelSwitch(item)
                    }
                })
                // if(self.vueState.activePanelTab === "style" && item.dataset.panelGroup === self.vueState.activePanelGroup) {
                //     item.classList.add('active');
                // }
            })
        }, 1)
    },
    setColorsforStructureIndicators: function (){
        const self = this;
        const color = self.globalSettings.structurePanelTagIndicatorColors;
        if(color){
            const structurePanel = document.querySelector('#bricks-structure');
            structurePanel.setAttribute('data-indicators-color', color);
        }

    },
  
    groupClassIndicator() {
        const self = this;
        if (!self.helpers.isElementActive()) return;

        const panel = document.querySelector("#bricks-panel-element");
        const elements = panel.querySelectorAll("[data-control-group]");
        if (!elements || elements.length < 1) return;
        
        // Remove Existing classes from the title
        elements.forEach(el => {
            const controlGroupTitle = el.querySelector('.control-group-title');
            controlGroupTitle.classList.remove('has-class-styles');
            controlGroupTitle.classList.remove('has-id-styles');
          });

        let settingKeys;
        const elementObj = self.helpers.getFinalObject(true);
        
        // ID
        if(!self.helpers.isClassActive()){
            const classIds = elementObj.settings?.['_cssGlobalClasses'] || false;
            if (!classIds) return;
        
            settingKeys = classIds.flatMap(cls => {
                const obj = self.vueGlobalProp.$_getGlobalClass(cls);
                if(!obj) return;

                const clsSettings = obj.settings;
                const keys = Object.keys(clsSettings);
                return keys.filter(
                    key => self.helpers.keyMatchBreakpoint(key, self.vueState.breakpointActive) 
                    && self.helpers.keyMatchPseudo(key, self.vueState.pseudoClassActive));
            });

        // Class
        } else {
            settingKeys = Object.keys(elementObj.settings).filter(
                    key => self.helpers.keyMatchBreakpoint(key, self.vueState.breakpointActive) 
                    && self.helpers.keyMatchPseudo(key, self.vueState.pseudoClassActive));
        }
    
        settingKeys = [...new Set(settingKeys.map(key => key && key.split(':')[0]))];
        let categories = settingKeys.flatMap(key => bricksData.elements[elementObj.name].controls[key]?.group || []);
    
        categories = [...new Set(categories)];
        if (!categories || categories.length < 1) return;
        
        // Add class to title
        const customClass = !self.helpers.isClassActive() ? 'has-class-styles' : 'has-id-styles';
        categories.forEach(cat => {
            const panelTitle = panel.querySelector(`[data-control-group="${cat}"] .control-group-title`);
            panelTitle.classList.add(customClass);
        })
    },
    classIndicator() {
        const self = this;
        if(!self.helpers.isElementActive()) return;
    
        const panel = document.querySelector("#bricks-panel-element");
        const els = panel?.querySelectorAll("[data-controlkey^='_']");
    
        if (!els || !els.length) return;
    
        // Remove existing attributes
        els.forEach((el) => {
            el.removeAttribute("data-has-class-style");
            el.removeAttribute("data-has-id-style");
        });

        const activeElementSettings = self.helpers.getFinalObject()?.settings;
        if(!activeElementSettings.hasOwnProperty('_cssGlobalClasses') || activeElementSettings._cssGlobalClasses.length < 1) return;

        function buildKey(el) {
            let key = el.dataset.controlkey;
            if (self.vueState.breakpointActive !== "desktop") {
                key += `:${self.vueState.breakpointActive}`;
            }
            if (self.vueState.pseudoClassActive !== "") {
                key += self.vueState.pseudoClassActive;
            }
            return key;
        }
    
        const isClassActive = self.helpers.isClassActive();
        let finalKeys = isClassActive
            ? Object.keys(activeElementSettings).filter(el => el && el.startsWith("_") && activeElementSettings[el] !== "")
            : self.helpers.getClassKeysFromGlobalSettings(activeElementSettings._cssGlobalClasses);
    
        const attr = isClassActive ? 'hasIdStyle' : 'hasClassStyle';
        els.forEach((el) => {
            if (finalKeys.includes(buildKey(el))) {
                el.dataset[attr] = "true";
            }
        });
        
        if(isClassActive){
            const globalClasses = activeElementSettings._cssGlobalClasses.slice();
            globalClasses.splice(globalClasses.indexOf(self.vueState.activeClass.id),1);
            if(globalClasses.length < 1) return;

            finalKeys = self.helpers.getClassKeysFromGlobalSettings(globalClasses);
    
            els.forEach((el) => {
                const key = buildKey(el);
                if (finalKeys.includes(key)) {
                    el.dataset['hasClassStyle'] = "true";
                }
            });
        }
    },

    breakpointIndicator: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        // Const
        const panel = document.querySelector("#bricks-panel-element");
        const groups = panel.querySelectorAll('.control-group');
        if (groups.length < 1) return;
        const activePseudo = self.vueState.pseudoClassActive;
        const activeClass = self.vueState.activeClass;
        const elementObj = self.helpers.getFinalObject(true);
        const elementObjWithClasses = self.helpers.getFinalObject();
        const activeBp = self.vueState.breakpointActive;

        
        function mountIcons(){
            const name =  elementObj?.name;
            const settings =  elementObjWithClasses?.settings;
            
            if(!settings) return;
            
            const activePseudo = self.vueState.pseudoClassActive;
    
            // Render
            groups.forEach((group,index) => {
                const groupName = group.dataset.controlGroup;
                self.vueState.breakpoints.forEach(bp => {
                    const icon = group.querySelector(`.brxc-group-icon[data-device="${bp.key}"]`);
                    if(icon) icon.remove();

                    let hasStyles = false;
                    let suffix = "";
                    if(bp.key !== "desktop") suffix += `:${bp.key}`;
                    if(activePseudo !== "") suffix += activePseudo;

                    for(const key of Object.keys(settings)){
                        const setting = key.split(':')[0];
                        if(key === `${setting}${suffix}`){
                            if(bricksData.elements[name].controls[setting] && bricksData.elements[name].controls[setting].hasOwnProperty('group') && bricksData.elements[name].controls[setting].group === groupName) {
                                hasStyles = true;
                            }
                        } 
                    }
    
                    if(hasStyles){
                        let svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M27.744,2.5h-25.488c-0.968,0 -1.756,0.788 -1.756,1.755v17.489c0,0.968 0.788,1.755 1.756,1.755h12.244v3h-5.5c-0.276,0 -0.5,0.224 -0.5,0.5c0,0.276 0.224,0.5 0.5,0.5h12c0.276,0 0.5,-0.224 0.5,-0.5c0,-0.276 -0.224,-0.5 -0.5,-0.5h-5.5v-3h12.244c0.968,0 1.756,-0.788 1.756,-1.755v-17.489c0,-0.967 -0.788,-1.755 -1.756,-1.755Zm-1.244,18h-23v-15h23v15Z" fill="currentColor"></path></svg></span>';
                        if( bp.icon === "laptop") {
                            svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M80.14,400c-17.7503,0 -32.14,-14.3897 -32.14,-32.14v-239.72c0,-17.7503 14.3897,-32.14 32.14,-32.14h351.72c17.7503,0 32.14,14.3897 32.14,32.14v239.72c0,17.7503 -14.3897,32.14 -32.14,32.14Z" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path><path fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-width="32" d="M16,416h480"></path></svg></span>';
                        }
                        if( bp.icon === "tablet-landscape") {
                            svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g transform="matrix(1,0,0,1,0,512)"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M128,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h256c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" transform="matrix(6.12323e-17,-1,1,6.12323e-17,0,0)"></path></g></svg></span>';
                        }
                        if( bp.icon === "tablet-portrait") {
                            svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M128,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h256c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path></svg></span>';
                        }
                        if( bp.icon === "phone-landscape") {
                            svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g transform="matrix(1,0,0,1,0,512)"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M176,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h160c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" transform="matrix(6.12323e-17,-1,1,6.12323e-17,0,0)"></path></g><path d="M16,336v-24l9.23706e-14,1.20797e-06c-6.67141e-07,-4.41828 3.58172,-8 8,-8v0h-6.99382e-07c8.83656,3.86258e-07 16,-7.16344 16,-16v-64v0c0,-8.83656 -7.16344,-16 -16,-16v0h-3.49691e-07c-4.41828,-1.93129e-07 -8,-3.58172 -8,-8c0,0 0,-2.84217e-14 0,-2.84217e-14v-24" stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path></svg></span>';
                        }
                        if( bp.icon === "phone-portrait") {
                            svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"><path d="M176,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h160c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z"></path><path d="M176,16h24l-3.49691e-07,7.10543e-15c4.41828,-1.93129e-07 8,3.58172 8,8v0l1.7053e-13,2.41593e-06c1.33428e-06,8.83656 7.16345,16 16,16h64l-6.99382e-07,-1.42109e-14c8.83656,3.86258e-07 16,-7.16344 16,-16v0l1.13687e-13,1.20797e-06c-6.67141e-07,-4.41828 3.58172,-8 8,-8h24"></path></g></svg></span>';
                        }
                        let newClass = 'brxc-group-icon';
                        if(self.vueState.breakpointActive === bp.key) newClass = 'brxc-group-icon active';
                        self.addIconToFields('li', newClass, [['data-device', bp.key]] , bp.label, 'top', false, true, svg, group.querySelector('.control-group-title'), 'child');
                    }
                })
     
            })
            
    
            const groupIcons = panel.querySelectorAll('.brxc-group-icon');
            if(groupIcons.length < 1 ) return;
            groupIcons.forEach(el => {
                el.addEventListener('click', (e) => {
                    e.preventDefault();
                    const parentGroup = e.target.closest('li.control-group');
                    if(parentGroup.classList.contains('open')) e.stopPropagation();
                    self.vueState.breakpointActive = el.dataset.device;
                })
            })
        }
        
        mountIcons();

        // Recalculate indicators on changes
        setTimeout(() => {
            if(activePseudo !== self.vueState.pseudoClassActive ||
               elementObjWithClasses !== self.helpers.getFinalObject() ||
               activeBp !== self.vueState.breakpointActive) {
                   mountIcons();
            }
        }, 150)

    },
    lockedClassIndicator: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;
        const classes = document.querySelectorAll('#bricks-panel-element #bricks-panel-element-classes .element-classes li');
        if (classes.length < 1) return;
        classes.forEach(el => {
            el.removeAttribute("data-locked");
            const name = el.querySelector('.name')
            const id = name.dataset.classId;
            if (self.vueGlobalProp.$_isLocked(id)) el.setAttribute("data-locked", "true");
        })
    },
    focusOnFirstClassStates: {
        lastElementFocus: '',
        isComponentActive: false, 
    },
    focusOnFirstClass: function(){
        const self = this;
        
        setTimeout(() => {
            if(!self.helpers.isElementActive()) return

            const elementObj = self.helpers.getFinalObject(true);

            if(!elementObj || !elementObj.hasOwnProperty('id') || self.focusOnFirstClassStates.lastElementFocus === elementObj.id && self.focusOnFirstClassStates.isComponentActive === self.helpers.isComponentActive()) {
                //if (self.helpers.isClassActive() === false) self.vueState.activeClass = '';
                return;
            } 
            else if (self.vueState.activePanel === "element"){
                self.focusOnFirstClassStates.isComponentActive = self.helpers.isComponentActive();
                self.focusOnFirstClassStates.lastElementFocus = elementObj.id;
                if(elementObj.hasOwnProperty('settings') && elementObj.settings.hasOwnProperty('_cssGlobalClasses')){
                    const firstUnlocked = Array.from(elementObj.settings._cssGlobalClasses).find(el => el && self.vueGlobalProp.$_getGlobalClass(el) && self.vueGlobalProp.$_isLocked(el) === false)
                    if(firstUnlocked) {
                        self.vueState.activeClass = JSON.parse(JSON.stringify(self.vueGlobalProp.$_getGlobalClass(firstUnlocked)));
                        self.forceClassStlyesStates.showLock = false;
                        self.vueState.rerenderControls = Date.now();
                    }
                }
            }
        },0)
    },
    setTagInStructurePanel: function(id,tag){
        const self = this;
        self.vueState.brxc.tagDropdownActive = false;
        const obj = self.helpers.getElementObject(id);
        if(typeof obj !== "undefined" && !obj.hasOwnProperty('settings')) obj.settings = {};
        obj.settings.tag = tag;
        self.showTagInStructurePanel();
        self.vueState.rerenderControls = Date.now();
    },
    setCustomTagInStructurePanel: function(input, event, optionType){
        const self = this;
        if(event.key === "Enter"){
            const elementObj = self.helpers.getFinalObject(true);
            if(optionType === "text"){
                elementObj.settings.tag = input.value
            } else if(optionType === "select"){
                elementObj.settings.tag = "custom";
                elementObj.settings.customTag = input.value;
            }
            self.vueState.rerenderControls = Date.now();
        }
    },
    
    showTagInStructurePanel: function(){
        const self = this;
        const structurePanel = document.querySelector('#bricks-structure');
        if(!structurePanel) return;

        const els = structurePanel.querySelectorAll('#bricks-structure main .element');
        if (els.length < 1) return;

        if(self.vueState.brxc.tagsView === 'none') {
            els.forEach(el => {
                const wrapper = el.querySelector('.brxc-tag-btn-wrapper');
                if (wrapper) wrapper.remove();
            })
            structurePanel.removeAttribute('data-tag-color');
            return;
        }

        els.forEach(el => {
            const oldBtn = el.querySelector('.brxc-tag-btn-wrapper');
            if(oldBtn) oldBtn.remove();

            const obj = self.helpers.getElementObject(el.dataset.id);
            const tag = self.helpers.getElementTag(obj);
            if(!tag) return;
            
            const title = el.querySelector('.title .icon')
            const optionType = typeof bricksData.elements[obj.name].controls !== "undefined" && bricksData.elements[obj.name].controls.hasOwnProperty('tag') ? bricksData.elements[obj.name].controls.tag.type : false;
            const options = typeof bricksData.elements[obj.name].controls !== "undefined" && bricksData.elements[obj.name].controls.hasOwnProperty('tag') ? bricksData.elements[obj.name].controls.tag.options : false;
            self.helpers.createTagBtn(title, tag, optionType, options, el.dataset.id);
        })

        if(self.vueState.brxc.tagsView === 'developer'){
            structurePanel.setAttribute('data-tag-color', 'true');
            self.vueState.brxc.tagdropDownVisible = true;
        }
    },
    showTagInStructurePanelCustomTags: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;
        const input = document.querySelector('input#customTag');
        if(!input || input.dataset.listening === "true") return;
        input.setAttribute('data-listening', "true");
        input.addEventListener('keyup', () => {
            self.showTagInStructurePanel();
        })

    },
    expandAllChildren: function(event){
        const self = this;
        const parent = event.target.closest('[data-id]');
        if(!parent) return;
        const toggles = parent.querySelectorAll('.bricks-svg-wrapper.toggle')
        if(toggles.length < 1) return;
        toggles.forEach(toggle => {
            const parent = toggle.closest('[data-id]');
            if (!parent) return;
            const target = parent.querySelector('.bricks-structure-list')
            if (!target) return;
            const status = window.getComputedStyle(target).getPropertyValue("display");
            if(status && status === 'none') toggle.click();
        })
        const toggle = parent.querySelector('.structure-item')
        if(toggle) toggle.click();

        self.vueState.rerenderControls = Date.now();

    },
    collapseAllChildren: function(event){
        const self = this;
        const parent = event.target.closest('[data-id]');
        if(!parent) return;
        const toggles = parent.querySelectorAll('.bricks-svg-wrapper.toggle')
        if(toggles.length < 1) return;
        toggles.forEach(toggle => {
            const parent = toggle.closest('[data-id]');
            if (!parent) return;
            const target = parent.querySelector('.bricks-structure-list')
            if (!target) return;
            const status = window.getComputedStyle(target).getPropertyValue("display");
            if(status && status !== 'none') toggle.click();
        })
        const toggle = parent.querySelector('.structure-item')
        if(toggle) toggle.click();
        
        self.vueState.rerenderControls = Date.now();

    },
    replaceColorsPalette: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;
        const grid = document.querySelector('#bricks-panel-element ul.color-palette.grid');
        if(!grid) return;
        const btns = grid.querySelectorAll('li.color .color-button');
        btns.forEach(btn => {
            const balloon = btn.dataset.balloon;
            if(!balloon.startsWith('var(')) return;
            btn.style.backgroundColor = balloon;
        })

    },
    previousTheme: false,
    checkForThemeChange: function(){
        const self = this;
        if(self.previousTheme === false) self.previousTheme = self.vueState.themeStyleActive;
        if(self.previousTheme !== self.vueState.themeStyleActive) {
            self.previousTheme = self.vueState.themeStyleActive;
            self.generateVariableCSS('theme');
            self.generateBuilderCSS();
        }
    },
    dynamicDataStates: {
        initialized: false,
        input: false,
        search: '',
        activeGroups: ['all'],
        groups: false,
        recentSearch: [],
    },
    addDynamicDataTrigger: async function(){
        const self = this;
        setTimeout(() => {
            self.fields['dynamicDataModal']['includedFields'].forEach(field => {
                let elements;
                if (typeof field === 'string') {
                    elements = Array.from(document.querySelectorAll(field));
                } else {
                    // Get elements with the selector
                    const filteredElements = Array.from(document.querySelectorAll(field.selector));
        
                    // Check if they have any of the specified child elements
                    elements = filteredElements.filter(el =>
                        el && field.hasChild.some(child => child && el.querySelector(child))
                    );
                }
        
                const wrappers = elements.filter(
                    item => item && !item.parentNode.closest(self.fields['dynamicDataModal']['excludedFields'])
                );
                if (wrappers.length < 1) return;
                wrappers.forEach(wrapper => {
                    if(wrapper.dataset.listening === "true") return;
                    wrapper.setAttribute('data-listening', 'true');
                    wrapper.addEventListener('click', (event) => {
                        event.stopPropagation();
                        event.preventDefault();
                        self.dynamicDataStates.input = wrapper.parentElement.querySelector('.has-dynamic-data, textarea, input[type="text"]');
                        self.dynamicDataStates.search = '';
                        document.querySelector('#brxcDynamicDataModalOverlay input[type="search"]').value = '';
                        self.dynamicDataInit();
                        self.openModal(false, "#brxcDynamicDataModalOverlay", document.querySelector('#brxcDynamicDataModalOverlay input[type="search"]'))
                    })
                })
            })
        }, 150)
    },
    dynamicDataInit: function(){
        const self = this;
        const overlay = document.querySelector('#brxcDynamicDataModalOverlay');
        const canvas = overlay.querySelector('#brxcDynamicDataCanvas');
        const filters = overlay.querySelector('#brxcDynamicDataFilters');
        if(!canvas || !filters) return;

        // Set Categories
        self.dynamicDataStates.categories = [...new Set(bricksData.dynamicTags.map(item => item.group))];

        // Mount data
        self.dynamicDataCategories();
        self.dynamicDataMount();
    },
    dynamicDataCategories: function(){
        const self = this;
        const canvas = document.querySelector('#brxcDynamicDataFilters');
        let content = "";

        // Recent Searchs
        if(self.dynamicDataStates.recentSearch.length > 0){
            content += `<div id="brxcRecentSearch"><span>Recent Search: </span>${self.dynamicDataStates.recentSearch.slice(0, 10).map(el => `<a>${el}</a>`).join('<span>, </span>')}</div>`
        }
        // Filters
        content += `<div class="brxc-overlay__action-btn-wrapper"><div data-group="all" class="brxc-overlay__action-btn${self.dynamicDataStates.activeGroups.includes('all') ? ' active' : ''}">All</div>`;
        self.dynamicDataStates.categories.forEach(group => {
            content += `<div data-group="${group}" class="brxc-overlay__action-btn${self.dynamicDataStates.activeGroups.includes(group) ? ' active' : ''}">${group}</div>`;
        })
        content += '</div>';

        canvas.innerHTML = content;

        const recentSearchLinks = canvas.querySelectorAll('#brxcRecentSearch a');
        if(recentSearchLinks){
            recentSearchLinks.forEach(el => {
                el.addEventListener('click', () => {
                    self.dynamicDataStates.search = el.textContent;
                    document.querySelector('#brxcDynamicDataModalOverlay input[type="search"]').value = el.textContent;
                    self.dynamicDataMount();
                })
            })
        }

        // Listeners
        const btnWrapper = canvas.querySelector('.brxc-overlay__action-btn-wrapper');
        btnWrapper.addEventListener('mousedown', (event) => {
            const btn = event.target
            event.stopPropagation();
            event.preventDefault();
            if(btn.dataset.group === "all"){
                self.dynamicDataStates.activeGroups = ['all'];
            } else {
                if(self.dynamicDataStates.activeGroups.includes('all')) self.dynamicDataStates.activeGroups.splice(0, 1);
                if(self.dynamicDataStates.activeGroups.includes(btn.dataset.group)){
                    self.dynamicDataStates.activeGroups.splice(self.dynamicDataStates.activeGroups.indexOf(btn.dataset.group), 1);
                    if(self.dynamicDataStates.activeGroups.length === 0) self.dynamicDataStates.activeGroups = ['all'];
                } else {
                    self.dynamicDataStates.activeGroups.push(btn.dataset.group)
                }
            } 
            self.dynamicDataInit();
        })
      
    },
    dynamicDataMount: function(){
        const self = this;
        const overlay = document.querySelector('#brxcDynamicDataModalOverlay');
        const canvas = overlay.querySelector('#brxcDynamicDataCanvas');

        const activeGroups = self.dynamicDataStates.activeGroups; // Cache activeGroups
        const categories = self.dynamicDataStates.categories; // Cache categories
        const tags = bricksData.dynamicTags; // Cache dynamicTags
        const search = self.dynamicDataStates.search.toLowerCase(); // Cache search string

        let contentArr = []; // Use an array for better string concatenation performance
        contentArr.push('<ul id="brxcDynamicDataWrapper">');

        categories.forEach(category => {
            if (!activeGroups.includes("all") && !activeGroups.includes(category)) return;

            contentArr.push(`<div><span>${category}</span><ul>`);

            tags.forEach(tag => {
                if (!tag || tag.group !== category) return;

                // Cache lowercased values once
                const tagName = tag.name.toLowerCase();
                const tagLabel = tag.label.toLowerCase();
                const tagGroup = tag.group.toLowerCase();

                // Only check .includes() if search is not empty
                if (search !== "" && !tagName.includes(search) && !tagLabel.includes(search) && !tagGroup.includes(search)) return;

                const label = bricksData.builderDynamicDropdownNoLabel === "1" ? tag.name : tag.label;
                const balloon = bricksData.builderDynamicDropdownKey === "1" ? '' : `data-balloon="${tag.name}" data-balloon-pos="top"`;

                // Accumulate content in the array
                contentArr.push(`<li data-value="${tag.name}" ${balloon}><span>${label}</span><div class="copy-tag-icon" data-balloon="Copy Tag to Clipboard" data-balloon-pos="left" data-value="${tag.name}"><i class="fas fa-clipboard"></i></div></li>`);
            });

            contentArr.push('</ul></div>');
        });

        contentArr.push('</ul>');

        // Join the array into a single string and update the DOM once
        canvas.innerHTML = contentArr.join('');


        // On click
        const ul = canvas.querySelector('#brxcDynamicDataWrapper');

        ul.addEventListener('click', (event) => {
            // Copy tag
            const copyTag = event.target.closest('.copy-tag-icon');
            const li = event.target.closest('li');

            if(copyTag && ul.contains(copyTag)){
                event.stopPropagation();
                const tagName = li.dataset.value;
                return self.copytoClipboardSimple(tagName,`${tagName} successfully copied to clipboard`);
            }

            // li
            if (li && ul.contains(li)) {
                self.dynamicDataStates.input.value += li.dataset.value;
                const evt = new Event('input');
                self.dynamicDataStates.input.dispatchEvent(evt);

                if (event.shiftKey) {
                    self.vueGlobalProp.$_showMessage(`${li.dataset.value} inserted correctly!`);
                } else {
                    const searchInput = document.querySelector('#brxcDynamicDataModalOverlay input[type="search"]');
                    if (searchInput && searchInput.value !== "") {
                        self.dynamicDataStates.recentSearch = self.dynamicDataStates.recentSearch.filter(el => el !== searchInput.value);
                        self.dynamicDataStates.recentSearch.unshift(searchInput.value);
                    }
                    self.closeModal(event, event.target, '#brxcDynamicDataModalOverlay');
                }
            }
        });
    },
    focusPointStates: {
        type: null,
        mode: 'grid',
        imgFound: false,
    },
    addBgPositionIcon: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.activePanelTab !== "style" || self.vueState.activePanelGroup !== "_background" || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;

        setTimeout(() => {

            const wrapper = document.querySelector('[data-controlkey="_background"] label[for="position"] + div[data-control="select"]')
            if (!wrapper) return;
             
            const icon = wrapper.parentElement.querySelector('.brxc-position-icon');
            if (icon) return;
        
            wrapper.classList.add('position-icon-active');
            self.addIconToFields(
                'div',
                'brxc-position-icon',
                false,
                'Focus Point',
                'top-right',
                'ADMINBRXC.bgFocusInit("_background");ADMINBRXC.openModal(false, "#brxcBackgroundFocus")',
                false,
                "<i class='fas fa-crosshairs'></i>",
                wrapper,
                'after'
            );
            

        }, 300);
    },
    addBgMaskIcon: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.activePanelTab !== "content" || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;

        const elementObj = self.helpers.getFinalObject(true);
        if(elementObj.name !== "image") return;
        
        setTimeout(() => {

            const wrapper = document.querySelector('[data-controlkey="mask"] label[for="mask"] + div[data-control="select"]')
            if (!wrapper) return;
             
            const icon = wrapper.parentElement.querySelector('.brxc-mask-icon');
            if (icon) return;
        
            wrapper.classList.add('mask-icon-active');
            self.addIconToFields(
                'div',
                'brxc-mask-icon',
                false,
                'Mask Helper',
                'top-right',
                'ADMINBRXC.maskHelperInit();ADMINBRXC.openModal(false, "#brxcMaskHelperOverlay")',
                false,
                "<i class='fas fa-mask'></i>",
                wrapper,
                'after'
            );
        }, 300);
    },
    maskHelperInit: function(){
        const self = this;
        const canvas = document.querySelector('#brxcMaskHelperCanvas');
        const content = self.maskHelperMount();
        canvas.innerHTML = content
    },
    maskHelperMount: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        const settings = elementObj?.settings;
        const image = settings.hasOwnProperty('image') && settings.image.hasOwnProperty('url') && self.helpers.isValidUrl(settings.image.url) ? settings.image.url : self.globalSettings.placeholderImg;
        let position
        let size
        let repeat
        settings.hasOwnProperty('maskPosition') ? position = settings.maskPosition : position = "center center";
        settings.hasOwnProperty('maskSize') ? size = settings.maskSize : size = "contain";
        settings.hasOwnProperty('maskRepeat') ? repeat = settings.maskRepeat : repeat = "no-repeat";
        let content = '<ul>';

        const masks = self.vueGlobalProp.$_getElementConfig(elementObj.name).controls.mask.options;
        for (const key of Object.keys(masks)) {
            if(key !== "custom") content += `<li class="brxc-box-item">
                <img src="${image}" style="mask-image: url(${bricksData.assetsUrl}svg/masks/${key}.svg);mask-size:${size};mask-position:${position};mask-repeat:${repeat};">
                <div class="brxc-box-btn-wrapper">
                    <a class="" onclick="ADMINBRXC.maskHelperApply('${key}');ADMINBRXC.closeModal(event, this, '#brxcMaskHelperOverlay');">Apply</a>
                </div>
            </li>`;
        }
        content += '</ul>';
        return content;

    },
    maskHelperApply: function(key){
        const self = this;
        const settings = self.helpers.getFinalObject(true);
        settings.settings['mask'] = key;
        self.vueGlobalProp.$_forceRender(100);
        self.vueState.rerenderControls = Date.now();
    },
    addObjPositionIcon: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.activePanelTab !== "content" || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;
        
        const elementObj = self.helpers.getFinalObject(true);
        if(elementObj.name !== "image") return;

        setTimeout(() => {
            const wrapper = document.querySelector('[data-controlkey="_objectPosition"] label[for="_objectPosition"] + div[data-control="text"]')
            if (!wrapper) return;
             
            const icon = wrapper.parentElement.querySelector('.brxc-position-icon');
            if (icon) return;
        
            wrapper.classList.add('position-icon-active');
            self.addIconToFields(
                'div',
                'brxc-position-icon',
                false,
                'Focus Point',
                'top-right',
                'ADMINBRXC.bgFocusInit("image");ADMINBRXC.openModal(false, "#brxcBackgroundFocus")',
                false,
                "<i class='fas fa-crosshairs'></i>",
                wrapper,
                'after'
            );
        }, 300);
    },
    bgFocusInit: function(type = false){
        const self = this;
        if (type) self.focusPointStates.type = type;
        const canvas = document.querySelector('#brxcBgFocusCanvas');
        const targetBackground = self.helpers.createTargetWithPseudo(self.focusPointStates.type);
        let settings = self.helpers.getFinalObject()?.settings;
        settings = self.focusPointStates.type === "_background" ? settings : self.helpers.getFinalObject(true)?.settings
        
        let image;
        if(self.focusPointStates.type === "_background"){
            if(!settings.hasOwnProperty(targetBackground) || !settings[targetBackground].hasOwnProperty('image') || !settings[targetBackground].image.hasOwnProperty('url') || !self.helpers.isValidUrl(settings[targetBackground].image.url)){
                self.focusPointStates.imgFound = false;
                image = self.globalSettings.placeholderImg; 
            } else {
                self.focusPointStates.imgFound = true;
                image = settings[targetBackground].image.url;
            }
        } else if(self.focusPointStates.type === "image"){
            if(!settings.hasOwnProperty('image') || !settings.image.hasOwnProperty('url') || !self.helpers.isValidUrl(settings.image.url)) {
                self.focusPointStates.imgFound = false;
                image = self.globalSettings.placeholderImg;
            } else {
                self.focusPointStates.imgFound = true;
                image = settings.image.url;
            }
        }

        if(self.focusPointStates.mode === "grid"){
            self.bgFocusMountGrid(image);
        } else {
            self.bgFocusMountCustom(image);
        }
    },
    bgFocusMountGrid: function(image){
        const self = this;
        const canvas = document.querySelector('#brxcBgFocusCanvas');
        // Structure
        let content = '';
        content += `<div id="brxcFocusContainer">
                        <div class="brxc-focus-col">`;
         if(self.focusPointStates.imgFound !== true) content += `<div data-control="info" style="margin-bottom: 10px;"><u>Image not found!</u> A placeholder will be used instead.</div>`;
                    content += `<div id="brxcFocusWrapper">
                                <img src="${image}" />
                                <div id="brxcFocusGrid">
                                    <div class="brxc-focus-item" data-pos-x="left" data-pos-y="top"></div>
                                    <div class="brxc-focus-item" data-pos-x="center" data-pos-y="top"></div>
                                    <div class="brxc-focus-item" data-pos-x="right" data-pos-y="top"></div>
                                    <div class="brxc-focus-item" data-pos-x="left" data-pos-y="center"></div>
                                    <div class="brxc-focus-item active" data-pos-x="center" data-pos-y="center"></div>
                                    <div class="brxc-focus-item" data-pos-x="right" data-pos-y="center"></div>
                                    <div class="brxc-focus-item" data-pos-x="left" data-pos-y="bottom"></div>
                                    <div class="brxc-focus-item" data-pos-x="center" data-pos-y="bottom"></div>
                                    <div class="brxc-focus-item" data-pos-x="right" data-pos-y="bottom"></div>
                                </div>
                            </div>
                        </div>
                        <div class="brxc-focus-col">
                            <div id="brxcFocusPreview">
                                <div class="brxc-focuc-preview-item"><span>AR: <b>4</b></span><img src="${image}" class="ar-4" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>3</b></span><img src="${image}" class="ar-3" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>2</b></span><img src="${image}" class="ar-2" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>16/9</b></span><img src="${image}" class="ar-16-9" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>3/2</b></span><img src="${image}" class="ar-3-2" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>4/3</b></span><img src="${image}" class="ar-4-3" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>1</b></span><img src="${image}" class="ar-1" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>3/4</b></span><img src="${image}" class="ar-3-4" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>2/3</b></span><img src="${image}" class="ar-2-3" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>9/16</b></span><img src="${image}" class="ar-9-16" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>1/2</b></span><img src="${image}" class="ar-1-2" /></div>
                            </div>
                        </div>
                    </div>`
        canvas.innerHTML = content;

        const container = canvas.querySelector('#brxcFocusContainer');
        const items = canvas.querySelectorAll('.brxc-focus-item');
        items.forEach(item => {
            item.addEventListener('click', () => {
                items.forEach(el => el.classList.remove('active'))
                item.classList.add('active');
                container.style.setProperty('--left', item.dataset.posX);
                container.style.setProperty('--top', item.dataset.posY);
            })
        })
    },
    bgFocusMountCustom: function(image){
        const self = this;
        const canvas = document.querySelector('#brxcBgFocusCanvas');
        // Structure
        let content = '';
        content += `<div id="brxcFocusContainer">
                        <div class="brxc-focus-col">`;
        if(self.focusPointStates.imgFound !== true) content += `<div data-control="info" style="margin-bottom: 10px;"><u>Image not found!</u> A placeholder will be used instead.</div>`;
                    content += `<div id="brxcFocusWrapper">
                                <img src="${image}" />
                                <div id="brxcFocusPoint"></div>
                            </div>
                        </div>
                        <div class="brxc-focus-col">
                            <div id="brxcFocusPreview">
                                <div class="brxc-focuc-preview-item"><span>AR: <b>4</b></span><img src="${image}" class="ar-4" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>3</b></span><img src="${image}" class="ar-3" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>2</b></span><img src="${image}" class="ar-2" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>16/9</b></span><img src="${image}" class="ar-16-9" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>3/2</b></span><img src="${image}" class="ar-3-2" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>4/3</b></span><img src="${image}" class="ar-4-3" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>1</b></span><img src="${image}" class="ar-1" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>3/4</b></span><img src="${image}" class="ar-3-4" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>2/3</b></span><img src="${image}" class="ar-2-3" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>9/16</b></span><img src="${image}" class="ar-9-16" /></div>
                                <div class="brxc-focuc-preview-item"><span>AR: <b>1/2</b></span><img src="${image}" class="ar-1-2" /></div>
                            </div>
                        </div>
                    </div>`
        canvas.innerHTML = content;

        // Cache the CSS properties and elements
        const focusContainer = canvas.querySelector('#brxcFocusContainer');
        const focusWrapper = canvas.querySelector('#brxcFocusWrapper');
        const focusPoint = canvas.querySelector('#brxcFocusPoint');
        let pos1 = 0, pos2 = 0;

        function dragElement(elmnt) {
            // Otherwise, move the DIV from anywhere inside the DIV:
            elmnt.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // Get the mouse cursor position at startup:
                pos1 = e.clientX;
                pos2 = e.clientY;
                document.onmouseup = closeDragElement;
                // Call a function whenever the cursor moves:
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                // Calculate the cursor movement since the last event:
                const deltaX = e.clientX - pos1;
                const deltaY = e.clientY - pos2;
                pos1 = e.clientX;
                pos2 = e.clientY;

                // Get the wrapper's dimensions
                const wrapperWidth = focusWrapper.offsetWidth;
                const wrapperHeight = focusWrapper.offsetHeight;

                // Calculate the new cursor position as percentages relative to wrapper
                const offsetX = deltaX / wrapperWidth * 100;
                const offsetY = deltaY / wrapperHeight * 100;

                // Get the current position as percentages
                const currentLeft = parseFloat(getComputedStyle(focusContainer).getPropertyValue('--left'));
                const currentTop = parseFloat(getComputedStyle(focusContainer).getPropertyValue('--top'));

                // Calculate the new position by adding the offset
                let newLeft = currentLeft + offsetX;
                let newTop = currentTop + offsetY;

                // Ensure the position stays within 0% to 100%
                newLeft = Math.min(Math.max(newLeft, 0), 100);
                newTop = Math.min(Math.max(newTop, 0), 100);

                // Update the CSS variables
                focusContainer.style.setProperty('--left', newLeft + '%');
                focusContainer.style.setProperty('--top', newTop + '%');
            }

            function closeDragElement() {
                // Stop moving when mouse button is released:
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // Call the dragElement function passing the focusPoint element
        dragElement(focusPoint);
    },
    applyBgFocus: function(){
        const self = this;
        const focusPoint = document.querySelector('#brxcFocusContainer');
        const currentLeft = parseFloat(getComputedStyle(focusPoint).getPropertyValue('--left'));
        const currentTop = parseFloat(getComputedStyle(focusPoint).getPropertyValue('--top'));
        let settings = self.helpers.getFinalObject()?.settings;

        // mode custom
        if(self.focusPointStates.mode === "custom"){
            if(self.focusPointStates.type === "_background"){
                const targetBackground = self.helpers.createTargetWithPseudo('_background');
                if(!settings.hasOwnProperty(targetBackground)) settings[targetBackground] = {};
                settings[targetBackground].position = 'custom';
                settings[targetBackground].positionX = `${currentLeft.toFixed(2)}%`;
                settings[targetBackground].positionY = `${currentTop.toFixed(2)}%`;
            } else if(self.focusPointStates.type === "image"){
                const targetObjPosition = self.helpers.createTargetWithPseudo('_objectPosition');
                settings[targetObjPosition] = `${currentLeft.toFixed(2)}% ${currentTop.toFixed(2)}%`
            }
        
        // mode grid
        } else if(self.focusPointStates.mode === "grid"){
            const activeEl = document.querySelector('.brxc-focus-item.active');
            if(!activeEl) return self.vueGlobalProp.$_showMessage('Abort - Select a grid item first');

            const posX = activeEl.dataset.posX;
            const posY = activeEl.dataset.posY;

            if(self.focusPointStates.type === "_background"){
                const targetBackground = self.helpers.createTargetWithPseudo('_background');
                if(!settings.hasOwnProperty(targetBackground)) settings[targetBackground] = {};
                settings[targetBackground].position = 'custom';
                settings[targetBackground].positionX = posX;
                settings[targetBackground].positionY = posY;
            } else if(self.focusPointStates.type === "image"){
                const targetObjPosition = self.helpers.createTargetWithPseudo('_objectPosition');
                settings[targetObjPosition] = `${posX} ${posY}`
            }
        }

        self.vueState.rerenderControls = Date.now();
    },
    addGridUIIcon: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;

        setTimeout(() => {
            const wrapper = document.querySelector('[data-controlkey="_display"]')
            if (!wrapper) return;

            const elementObj = self.helpers.getFinalObject();

            if(!self.helpers.elementHasGrid()){
                wrapper.classList.remove('grid-icon-active');
                const icon = wrapper.querySelector('.brxc-gridui-icon');
                if(icon) icon.remove(); 
                return;
            }
             
            const icon = wrapper.querySelector('.brxc-gridui-icon');
            const target = self.helpers.createTargetWithPseudo('gridBuilderSettings');
            const settings = elementObj.settings;
            if (icon) {
                settings.hasOwnProperty(target) ? icon.classList.add('active') : icon.classList.remove('active');
                return;
            }

            const className = settings.hasOwnProperty(target) ? 'brxc-gridui-icon active' : 'brxc-gridui-icon';
        
            wrapper.classList.add('grid-icon-active');
            self.addIconToFields(
                'div',
                className,
                false,
                'Grid Builder',
                'top-right',
                'ADMINBRXC.gridBuilderInit();ADMINBRXC.openModal(false, "#brxcGridUIOverlay")',
                false,
                "<i class='ion-ios-grid'></i>",
                wrapper.querySelector("[data-control='select']"),
                'after'
            );
        }, 150);
    },
    gridUIStates: {
        activeChild: null,
        grid: null,
        elements: null,
        gridReset: null,
        elementsReset: null,
        els: [],
        draggingEl: null,
        draggingElSize: null,
        globalCols: 3,
        globalRows: 3,
        globalGap: '20px',
    },
        // States
    
    gridBuilderBentoGrid: function(){
        const self = this;
        const elements = self.gridUIStates.elements;
        self.gridUIStates.grid.autoFlow = true;
        elements.forEach(el => {
            el.xSpan = 1;
            el.xSpanValue = 1;
            el.ySpan = 1;
            el.ySpanValue = 1;
        });

        const cols = self.gridUIStates.grid.col.length;
        const rows = self.gridUIStates.grid.row.length;
        
        function getFreeSlots(cols, rows){
            let usedSlots = 0;
            elements.forEach(el => {
                usedSlots += el.xSpanValue * el.ySpanValue;
            })
            return (cols * rows) - usedSlots;
        }
        function removeSlot(){
            let span;
            span = Math.floor(Math.random() * 2) === 1 ?  "xSpanValue" : "ySpanValue";
            const filteredEls = elements.filter(el => el && el[span] > 1);
            if(!filteredEls) return;
            let ind = Math.floor(Math.random() * filteredEls.length);
            const obj = filteredEls[ind];
            obj[span]--;
        }
        function addNewSlot(){
            let span;
            span = Math.floor(Math.random() * 2) === 1 ?  "x" : "y";
            const index = Math.floor(Math.random() * (elements.length - 1));
            elements[index][`${span}SpanValue`]++;
        }
        function populateSlots(){
            if(getFreeSlots(cols, rows) === 0) return;
            if(getFreeSlots(cols, rows) < 0) {
                removeSlot();
                populateSlots();
                return;
            }
            addNewSlot();
            populateSlots();
        }
        populateSlots()

         // Reload Grid
         self.gridBuilderSaveSettings();
         self.gridBuilderInit();
    },

    gridBuilderSetHeight: function(){
        const height = parseInt(document.defaultView.getComputedStyle(document.querySelector('.gridUI__grid-maxi-container')).height, 10)
        document.querySelector('.gridUI__main-container').style.setProperty("--max-height", `${height}px`);
    },
    gridBuilderSetNotification: function(){
        const self = this;
        const isCSS = self.gridUIStates.isClass || self.gridUIStates.hasQuery || self.gridUIStates.hasComponent;
        const wrapper = document.querySelector('#gridUI-notification');
        const mainContainer = document.querySelector('.gridUI__main-container');
        let text = '';
        if(self.gridUIStates.children === "[]"){
            mainContainer.classList.add('empty');
            text = `<div class="danger" data-control="info"><u>No Children detected!</u> Make sure to add children elements to your parent container.</div>`;
            wrapper.innerHTML = text;
            return;
        }
        mainContainer.classList.remove('empty');
        if(!isCSS) return wrapper.innerHTML = '';
        if(self.gridUIStates.hasQuery) text = `<div data-control="info"><u>Query Loop detected!</u> The Grid settings will be saved as Custom CSS.</div>`;
        if(self.gridUIStates.isClass) text = `<div data-control="info"><u>Class detected!</u> The Grid settings will be saved as Custom CSS.</div>`;
        if(self.gridUIStates.hasComponent) text = `<div data-control="info"><u>Component detected as child!</u> The Grid settings will be saved as Custom CSS.</div>`;
        wrapper.innerHTML = text;
    },
    gridBuilderSetBreakpoints: function(){
        const self = this;
        const wrapper = document.querySelector('#gridUI-bp-wrapper');
        let css = '';
        self.vueState.breakpoints.forEach(bp =>{
            let svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M27.744,2.5h-25.488c-0.968,0 -1.756,0.788 -1.756,1.755v17.489c0,0.968 0.788,1.755 1.756,1.755h12.244v3h-5.5c-0.276,0 -0.5,0.224 -0.5,0.5c0,0.276 0.224,0.5 0.5,0.5h12c0.276,0 0.5,-0.224 0.5,-0.5c0,-0.276 -0.224,-0.5 -0.5,-0.5h-5.5v-3h12.244c0.968,0 1.756,-0.788 1.756,-1.755v-17.489c0,-0.967 -0.788,-1.755 -1.756,-1.755Zm-1.244,18h-23v-15h23v15Z" fill="currentColor"></path></svg></span>';
            if( bp.icon === "laptop") {
                svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M80.14,400c-17.7503,0 -32.14,-14.3897 -32.14,-32.14v-239.72c0,-17.7503 14.3897,-32.14 32.14,-32.14h351.72c17.7503,0 32.14,14.3897 32.14,32.14v239.72c0,17.7503 -14.3897,32.14 -32.14,32.14Z" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path><path fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-width="32" d="M16,416h480"></path></svg></span>';
            }
            if( bp.icon === "tablet-landscape") {
                svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g transform="matrix(1,0,0,1,0,512)"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M128,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h256c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" transform="matrix(6.12323e-17,-1,1,6.12323e-17,0,0)"></path></g></svg></span>';
            }
            if( bp.icon === "tablet-portrait") {
                svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M128,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h256c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path></svg></span>';
            }
            if( bp.icon === "phone-landscape") {
                svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g transform="matrix(1,0,0,1,0,512)"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M176,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h160c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z" transform="matrix(6.12323e-17,-1,1,6.12323e-17,0,0)"></path></g><path d="M16,336v-24l9.23706e-14,1.20797e-06c-6.67141e-07,-4.41828 3.58172,-8 8,-8v0h-6.99382e-07c8.83656,3.86258e-07 16,-7.16344 16,-16v-64v0c0,-8.83656 -7.16344,-16 -16,-16v0h-3.49691e-07c-4.41828,-1.93129e-07 -8,-3.58172 -8,-8c0,0 0,-2.84217e-14 0,-2.84217e-14v-24" stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"></path></svg></span>';
            }
            if( bp.icon === "phone-portrait") {
                svg = '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><g stroke-linecap="round" stroke-width="32" stroke="currentColor" fill="none" stroke-linejoin="round"><path d="M176,496c-26.5094,0 -48,-21.4906 -48,-48v-384c0,-26.5094 21.4906,-48 48,-48h160c26.5094,0 48,21.4906 48,48v384c0,26.5094 -21.4906,48 -48,48Z"></path><path d="M176,16h24l-3.49691e-07,7.10543e-15c4.41828,-1.93129e-07 8,3.58172 8,8v0l1.7053e-13,2.41593e-06c1.33428e-06,8.83656 7.16345,16 16,16h64l-6.99382e-07,-1.42109e-14c8.83656,3.86258e-07 16,-7.16344 16,-16v0l1.13687e-13,1.20797e-06c-6.67141e-07,-4.41828 3.58172,-8 8,-8h24"></path></g></svg></span>';
            }
            let selector = `gridBuilderSettings`;
            if(bp.key !== 'desktop'){
                selector += `:${bp.key}`;
            }

            const settings = self.gridUIStates.isClass ? self.vueState.globalClasses.find(el => el && el.id === self.vueState.activeClass.id)?.settings : self.helpers.getFinalObject(true).settings;
            let hasStyle = settings.hasOwnProperty(selector) ? true : false;

            //css += `<li class="brxc-group-icon${self.vueState.breakpointActive === bp.key ? ' active' : ''}${self.vueGlobalProp.$_getGlobalClass(classId).settings.hasOwnProperty(selector) && self.vueGlobalProp.$_getGlobalClass(classId).settings[selector] !== '' ? ' has-styles' : ''}" data-balloon="${bp.label}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.vueState.breakpointActive = '${bp.key}';ADMINBRXC.gridBuilderInit();">${svg}</li>`;
            css += `<li class="brxc-group-icon${self.vueState.breakpointActive === bp.key ? ' active' : ''}${hasStyle ? ' has-styles' : ''}" data-balloon="${bp.label}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.vueState.breakpointActive = '${bp.key}';setTimeout(() => ADMINBRXC.gridBuilderInit(), 5);">${svg}</li>`;
        })
        wrapper.innerHTML = css;
    },
    gridBuilderRemoveSetting: function(){
        const self = this;
        const parent = self.helpers.getFinalObject();
        const target = self.helpers.createTargetWithPseudo('gridBuilderSettings');
        delete parent.settings[target];
        self.vueState.rerenderControls = Date.now()
        self.gridBuilderInit();
    },

    gridBuilderResizableWidth: function(){
        const wrapper = document.querySelector('.gridUI__main-container');
        const draggable = document.querySelector('.gridUI__grid-width.handle-right')
    

        let startX, startWidth;

        // Width
        const initDragWidth = (e) => {
            startX = e.clientX;
            startWidth = parseInt(document.defaultView.getComputedStyle(wrapper).width, 10);
            document.documentElement.addEventListener('mousemove', doDragWidth, false);
            document.documentElement.addEventListener('mouseup', stopDragWidth, false);
        }

        const doDragWidth = (e) => {
            wrapper.style.maxWidth = (startWidth + e.clientX - startX) + 'px';
        }

        const stopDragWidth = (e) => {
            document.documentElement.removeEventListener('mousemove', doDragWidth, false);    
            document.documentElement.removeEventListener('mouseup', stopDragWidth, false);
        }

        draggable.addEventListener('mousedown', initDragWidth, false);
    },

    gridBuilderResizableHeight: function(){
        const wrapper = document.querySelector('.gridUI__main-container');
        const draggable = document.querySelector('.gridUI__grid-width.handle-bottom')
    

        let startY, startHeight;

        // Width
        const initDragHeight = (e) => {
            startY = e.clientY;
            startHeight = parseInt(document.defaultView.getComputedStyle(wrapper).height, 10);
            document.documentElement.addEventListener('mousemove', doDragHeight, false);
            document.documentElement.addEventListener('mouseup', stopDragHeight, false);
        }

        const doDragHeight = (e) => {
            wrapper.style.setProperty('--max-height',`${startHeight + e.clientY - startY}px`);
        }

        const stopDragHeight = (e) => {
            document.documentElement.removeEventListener('mousemove', doDragHeight, false);    
            document.documentElement.removeEventListener('mouseup', stopDragHeight, false);
        }

        draggable.addEventListener('mousedown', initDragHeight, false);
    },

    gridBuilderSetGridElements: function(){
        const self = this;
        const container = document.querySelector('.gridUI__grid-container');
        container.innerHTML = '';
        let i = 0;
        for (const key of Object.keys(self.gridUIStates.elements)) {
            const element = document.createElement('div');
            element.classList.add('gridUI__grid-element');
            element.setAttribute('data-id', self.gridUIStates.elements[key].id);
            element.style.setProperty('--hue', self.gridUIStates.elements[key].color);
            element.setAttribute('draggable', 'true');
            element.setAttribute('onclick', `ADMINBRXC.gridBuilderSetChild('${self.gridUIStates.elements[key].id}');`)
            element.setAttribute('ondragstart', 'this.preventDefault;event.stopPropagation();ADMINBRXC.gridBuilderDragStartElement(this)');
            element.setAttribute('ondrag', 'this.preventDefault;event.stopPropagation();ADMINBRXC.gridBuilderDragElement(this)');
            element.setAttribute('ondragend', 'ADMINBRXC.gridBuilderDragEnd(this)');
            if(self.gridUIStates.activeChild !== null && self.gridUIStates.activeChild !== self.gridUIStates.elements[key].id) element.classList.add('inactive');
            if(self.gridUIStates.activeChild !== null && self.gridUIStates.activeChild === self.gridUIStates.elements[key].id) element.classList.add('active');
            let content = '';
            content += `${self.gridUIStates.elements[key].label}<div class="gridUI__grid-handle-container${(self.gridUIStates.elements[key].hasOwnProperty('yEnd') && self.gridUIStates.elements[key].yEnd > (self.gridUIStates.grid.col.length + 1)) || (self.gridUIStates.elements[key].hasOwnProperty('xEnd') && self.gridUIStates.elements[key].xEnd > (self.gridUIStates.grid.row.length + 1)) ? ' error' : ''}">`
            content += `<div class="action-top">`;
            if(self.gridUIStates.activeChild !== null && self.gridUIStates.activeChild === self.gridUIStates.elements[key].id) content +=`<div class="gridUI__grid-handle clear" data-balloon="Clear View" data-balloon-pos="bottom" onClick="event.stopPropagation();ADMINBRXC.gridBuilderRemoveActiveChild();"><span class="bricks-svg-wrapper"><i class="fas fa-xmark"></i></span></div>`;
            if(self.gridUIStates.elements[key].hasOwnProperty('xStart') 
                || self.gridUIStates.elements[key].hasOwnProperty('xEnd') 
                || self.gridUIStates.elements[key].hasOwnProperty('xStart') 
                || self.gridUIStates.elements[key].hasOwnProperty('xEnd') 
                || self.gridUIStates.elements[key].hasOwnProperty('yStart') 
                || self.gridUIStates.elements[key].hasOwnProperty('yEnd') 
                || (self.gridUIStates.elements[key].hasOwnProperty('xSpan') && self.gridUIStates.elements[key].xSpan === 1 && self.gridUIStates.elements[key].hasOwnProperty('xSpanValue'))
                || (self.gridUIStates.elements[key].hasOwnProperty('ySpan') && self.gridUIStates.elements[key].ySpan === 1 && self.gridUIStates.elements[key].hasOwnProperty('ySpanValue'))
              ) {
                content += `<div class="gridUI__grid-handle delete" data-balloon="Remove Styles" data-balloon-pos="bottom" onClick="event.stopPropagation();ADMINBRXC.gridBuilderDeleteElementSettings(this.parentElement.parentElement.parentElement.dataset.id)"><span class="bricks-svg-wrapper"><i class="fas fa-undo"></i></span></div>`;
            }
            content +=`<div class="gridUI__grid-handle dom">${i + 1}</div>`;
            content +=`</div>`
            content +=`<div class="gridUI__grid-handle resize handle-down-right" data-x-dir="ltr" data-y-dir="ttb"><span class="bricks-svg-wrapper"><i class="fas fa-chevron-up"></i></span></div>`;
            content +=`<div class="gridUI__grid-handle resize handle-down-left" data-x-dir="rtl" data-y-dir="ttb"><span class="bricks-svg-wrapper"><i class="fas fa-chevron-up"></i></span></div>`;
            content +=`<div class="gridUI__grid-handle resize handle-up-right" data-x-dir="ltr" data-y-dir="btt"><span class="bricks-svg-wrapper"><i class="fas fa-chevron-up"></i></span></div>`;
            content +=`<div class="gridUI__grid-handle resize handle-up-left" data-x-dir="rtl" data-y-dir="btt"><span class="bricks-svg-wrapper"><i class="fas fa-chevron-up"></i></span></div>`;
            content +=`</div>`;
            element.innerHTML = content
            container.appendChild(element);
            i++;
        }
    },
    gridBuilderSetChild: function(id){
        const self = this;
        self.gridUIStates.activeChild = id;
        self.gridBuilderSetChildInfo(id);
        self.gridBuilderInitPreview();
    },
    gridBuilderAddCell: function(){
        const self = this;
        self.gridUIStates.elements.push({
            id: `${self.gridUIStates.elements.length + 1}`,
            label: `nth-child(${self.gridUIStates.elements.length + 1})`,
            color: Math.floor(Math.random() * 360),
        });
        self.gridBuilderSaveSettings();
        self.gridBuilderSetGridElements();
    },
    gridBuilderRemoveCell: function(){
        const self = this;
        self.gridUIStates.elements.pop();
        self.gridUIStates.activeChild = null;
        self.gridBuilderSaveSettings();
        self.gridBuilderSetGridElements();
        self.gridBuilderSetChildInfo(false);
    },
    gridBuilderSetParentInfo: function(){
        const self = this;
        const isCSS = self.gridUIStates.isClass || self.gridUIStates.hasQuery || self.gridUIStates.hasComponent;
        const wrapper = document.querySelector('#gridUI__parent-settings');
        let content = `<span class="gridUI__title">Parent Settings</span>
                    <div class="gridUI__input-inline-container">
                        <div class="gridUI__input-wrapper">
                            <label for="cols">Columns:</label>
                            <input id="cols" class="gridUI__grid-inputs event" type="number" value="${self.gridUIStates.grid.col.length}" min="0" max="12" autocomplete="off">
                        </div>
                        <div class="gridUI__input-wrapper">
                            <label for="rows">Rows:</label>
                            <input id="rows" class="gridUI__grid-inputs event" type="number" value="${self.gridUIStates.grid.row.length}" min="0" max="12" autocomplete="off">
                        </div>
                    </div>
                    <div class="gridUI__input-wrapper">
                        <label for="cols">Gap:</label>
                        <input id="gap" class="gridUI__grid-inputs" type="text" value="${self.gridUIStates.grid.gap}" autocomplete="off">
                    </div>
                    <div class="gridUI__input-wrapper auto-flow">
                        <label for="auto-flow" class="has-tooltip"><span>Fill empty cells</span><div data-balloon="If this option is checked, the grid-auto-flow will be set to DENSE and fill the empty cells inside the grid." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                        ${self.gridUIStates.grid.autoFlow === true ? '<i class="fas fa-toggle-on"></i>' : '<i class="fas fa-toggle-off"></i>'}
                    </div>
                    <div class="gridUI__input-wrapper minmax">
                        <label for="minmax" class="has-tooltip"><span>Use minmax()</span><div data-balloon="If this option is checked, all the cols/rows values will be wrapped inside a minmax() function." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                        ${self.gridUIStates.grid.minmax === true ? '<i class="fas fa-toggle-on"></i>' : '<i class="fas fa-toggle-off"></i>'}
                    </div>`;
        if(isCSS){
            content += `<div class="gridUI__input-wrapper repeat">
                            <label for="repeat" class="has-tooltip"><span>Repeat Grid</span><div data-balloon="If this option is checked, the childen CSS declarations will include a repetitive pattern (an+b)." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            ${self.gridUIStates.grid.repeat === true ? '<i class="fas fa-toggle-on"></i>' : '<i class="fas fa-toggle-off"></i>'}
                        </div>
                        <div class="gridUI__input-wrapper replace-css">
                            <label for="minmax" class="has-tooltip"><span>Replace CSS automatically</span><div data-balloon="If this option is checked, the script will remove any CSS declarations generated previously by the Grid Builder before adding the new ones." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            ${self.gridUIStates.grid.replaceCSS === true ? '<i class="fas fa-toggle-on"></i>' : '<i class="fas fa-toggle-off"></i>'}
                        </div>
                        <div class="gridUI__input-inline-container add-cells">
                            <a class="brxc-overlay__action-btn secondary" onclick="ADMINBRXC.gridBuilderRemoveCell();"><span>Remove Cell</span></a>
                            <a class="brxc-overlay__action-btn secondary" onclick="ADMINBRXC.gridBuilderAddCell();"><span>Add Cell</span></a>
                        </div>`;
        }
        wrapper.innerHTML = content;

        // Cols / rows
        const inputs = document.querySelectorAll('.gridUI__grid-inputs.event');
        inputs.forEach(input => {
            input.addEventListener('change', (e) => {
                if(e.target.value !== "" && typeof parseInt(e.target.value) !== "number") {
                    input.parentElement.classList.add('error');
                    return;
                }
                input.parentElement.classList.remove('error');
                self.gridBuilderSaveSettings();
                self.gridBuilderListenInputs();
                self.gridBuilderInitPreview();
                self.gridBuilderInitChild();
            })
            input.addEventListener('input', (e) => {
                if(e.target.value !== "" && typeof parseInt(e.target.value) !== "number") {
                    input.parentElement.classList.add('error');
                    return;
                }
                input.parentElement.classList.remove('error');
                self.gridBuilderSaveSettings();
                self.gridBuilderListenInputs();
                self.gridBuilderInitPreview();
                self.gridBuilderInitChild();
            })
        })

        // Gap
        const gapControl = document.querySelector('.gridUI__grid-inputs#gap');
        gapControl.addEventListener('input', (e) => {
            if(e.target.value !== "" && !CSS.supports("gap", e.target.value)) {
                gapControl.parentElement.classList.add('error');
                return;
            }
            gapControl.parentElement.classList.remove('error');
            self.gridBuilderSaveSettings();
            self.gridBuilderListenInputs();
            self.gridBuilderInitPreview();
            self.gridBuilderInitChild();
        })
        gapControl.addEventListener('focus', () =>{
            self.autocomplete(gapControl, self.cssVariables, "style", true);
        })

        // auto-flow
        const autoflowInput = document.querySelector('.gridUI__input-wrapper.auto-flow i[class*="fa-toggle"]');
        autoflowInput.addEventListener('click', () => {
            if(autoflowInput.classList.contains('fa-toggle-off')){
                self.gridUIStates.grid.autoFlow = true;
            } else {
                self.gridUIStates.grid.autoFlow = false;
            }
            self.gridBuilderSetGridCSS();
            self.gridBuilderSaveSettings();
            self.gridBuilderSetParentInfo();
        })

        // Use minmax()
        const minmaxInput = document.querySelector('.gridUI__input-wrapper.minmax i[class*="fa-toggle"]');
        minmaxInput.addEventListener('click', () => {
            if(minmaxInput.classList.contains('fa-toggle-off')){
                self.gridUIStates.grid.minmax = true;
            } else {
                self.gridUIStates.grid.minmax = false;
            }
            self.gridBuilderSaveSettings();
            self.gridBuilderSetParentInfo();
        })
        // Use repeat
        const repeatInput = document.querySelector('.gridUI__input-wrapper.repeat i[class*="fa-toggle"]');
        if(repeatInput){
            repeatInput.addEventListener('click', () => {
                if(repeatInput.classList.contains('fa-toggle-off')){
                    self.gridUIStates.grid.repeat = true;
                } else {
                    self.gridUIStates.grid.repeat = false;
                }
                self.gridBuilderSaveSettings();
                self.gridBuilderSetParentInfo();
            })
        }

        // replace CSS
        const replaceCSSInput = document.querySelector('.gridUI__input-wrapper.replace-css i[class*="fa-toggle"]');
        if(replaceCSSInput){
            replaceCSSInput.addEventListener('click', () => {
                if(replaceCSSInput.classList.contains('fa-toggle-off')){
                    self.gridUIStates.grid.replaceCSS = true;
                } else {
                    self.gridUIStates.grid.replaceCSS = false;
                }
                self.gridBuilderSaveSettings();
                self.gridBuilderSetParentInfo();
            })
        }
    },
    gridBuilderSetChildInfo: function(id){
        const self = this;
        const wrapper = document.querySelector('#gridUI__child-settings');
        const isCSS = self.gridUIStates.isClass || self.gridUIStates.hasQuery || self.gridUIStates.hasComponent;
        if(id === false){
            wrapper.innerHTML = '';
            return;
        }
        const gridObj = Object.values(self.gridUIStates.elements).find(el => el && el.id === id);
        if(!gridObj) return;

        const events = ['change', 'input']
        let posXstart, posXend, posYstart, posYend, xSpan, xSpanValue, ySpan, ySpanValue, zIndex, color;
        gridObj.hasOwnProperty('xStart') ? posXstart = gridObj.xStart : posXstart = '';
        gridObj.hasOwnProperty('xEnd') ? posXend = gridObj.xEnd : posXend = '';
        gridObj.hasOwnProperty('yStart') ? posYstart = gridObj.yStart : posYstart = '';
        gridObj.hasOwnProperty('yEnd') ? posYend = gridObj.yEnd : posYend = '';
        gridObj.hasOwnProperty('xSpan') ? xSpan = gridObj.xSpan : false;
        gridObj.hasOwnProperty('xSpanValue') ? xSpanValue = gridObj.xSpanValue : xSpanValue = '';
        gridObj.hasOwnProperty('ySpan') ? ySpan = gridObj.ySpan : false;
        gridObj.hasOwnProperty('ySpanValue') ? ySpanValue = gridObj.ySpanValue : ySpanValue = '';
        gridObj.hasOwnProperty('zIndex') ? zIndex = gridObj.zIndex : zIndex = '';
        gridObj.hasOwnProperty('color') ? color = gridObj.color : color = '';
        let content = `<span class="gridUI__title">Child Settings <div class="gridUI__id-selector">${isCSS ? `nth-child(${id})` : `#${id}`}<div class="icon-wrapper"data-balloon="Clear" data-balloon-pos="top" onclick="ADMINBRXC.gridBuilderRemoveActiveChild();"><i class="fas fa-close"></i></div></div></span>`;
        content += `<div class="gridUI__input-inline-container">
                        <div class="gridUI__input-wrapper">
                            <label for="label">Label:</label>
                            <input id="label" class="gridUI__grid-inputs label" type="text" value="${gridObj.label}" data-type="label"${isCSS ? ' readonly' : ''} autocomplete="off">
                        </div>
                    </div>`;
        content += `<div class="gridUI__input-inline-container">`
        if(ySpan !== 1){
            content += `<div class="gridUI__input-wrapper">
                            <label for="grid-col-start">Column-Start:</label>
                            <input id="grid-col-start" class="gridUI__grid-inputs pos" type="number" min="1" max="12" value="${posYstart}" data-type="yStart" autocomplete="off">
                        </div>
                        <div class="gridUI__input-wrapper${posYend > (self.gridUIStates.grid.col.length + 1) ? ' error' : ''}">
                            <label for="grid-col-end">Column-End:</label>
                            <input id="grid-col-end" class="gridUI__grid-inputs pos" type="number" min="1" max="13" value="${posYend}" data-type="yEnd" autocomplete="off">
                        </div>`;
        } else {
            content += `<div class="gridUI__input-wrapper">
                            <label for="grid-col-span">Column-Span:</label>
                            <input id="grid-col-span" class="gridUI__grid-inputs pos" type="number" min="1" max="12" value="${ySpanValue}" data-type="ySpanValue" autocomplete="off">
                        </div>`
        }
            content += `<div class="gridUI__span-toggle"><div${ySpan === 1 ? ' class="active"' : ''} data-type="ySpan" data-balloon="${ySpan ? 'Disable' : 'Enable'} span" data-balloon-pos="top-right"><i class="fas fa-table-cells-large"></i></div></div>
                    </div>`;
        content += `<div class="gridUI__input-inline-container">`;
        if(xSpan !== 1){
            content += `<div class="gridUI__input-wrapper">
                            <label for="grid-row-start">Row-Start:</label>
                            <input id="grid-row-start" class="gridUI__grid-inputs pos" type="number" min="1" max="12" value="${posXstart}" data-type="xStart" autocomplete="off">
                        </div>
                        <div class="gridUI__input-wrapper${posXend > (self.gridUIStates.grid.row.length + 1) ? ' error' : ''}">
                            <label for="grid-row-end">Row-End:</label>
                            <input id="grid-row-end" class="gridUI__grid-inputs pos" type="number" min="1" max="13" value="${posXend}" data-type="xEnd" autocomplete="off">
                        </div>`
        } else {
            content += `<div class="gridUI__input-wrapper">
                            <label for="grid-row-span">Row-Span:</label>
                            <input id="grid-row-span" class="gridUI__grid-inputs pos" type="number" min="1" max="12" value="${xSpanValue}" data-type="xSpanValue" autocomplete="off">
                        </div>`
        }
                        
            content += `<div class="gridUI__span-toggle"><div${xSpan === 1 ? ' class="active"' : ''} data-type="xSpan" data-balloon="${xSpan ? 'Disable' : 'Enable'} span" data-balloon-pos="top-right"><i class="fas fa-table-cells-large"></i></div></div>
                    </div>`;
        content += `<div class="gridUI__input-inline-container">
                        <div class="gridUI__input-wrapper">
                            <label for="zIndex">z-index:</label>
                            <input id="zIndex" class="gridUI__grid-inputs z-index" type="number" min="-1" max="99999" value="${zIndex}" data-type="zIndex" autocomplete="off">
                        </div>
                        <div class="gridUI__input-wrapper">
                            <label for="color">Hue Color:</label>
                            <input id="color" class="gridUI__grid-inputs color" type="number" min="0" max="360" value="${color}" data-type="color" autocomplete="off">
                        </div>
                    </div>`;
        content += `<div class="gridUI__input-inline-container bottom m-top-16"><a class="brxc-overlay__action-btn secondary" onclick="ADMINBRXC.gridBuilderDeleteElementSettings(ADMINBRXC.gridUIStates.activeChild)"><span>Reset Styles</span></a>`;
        if(!isCSS) content += `<a class="brxc-overlay__action-btn secondary" onclick="ADMINBRXC.openElement('${id}');ADMINBRXC.closeModal(event, event.target, '#brxcGridUIOverlay')"><span>View Element</span></a>`;
        content += `</div>`;
        wrapper.innerHTML = content;
        const inputs = wrapper.querySelectorAll('.gridUI__grid-inputs.pos');
        if(!inputs || inputs.length < 1) return;
        inputs.forEach(input => {
            events.forEach(event => {
                input.addEventListener(event, (e) => {
                    const type = input.dataset.type.startsWith('x') ? 'row' : 'col';
                    if(typeof parseInt(e.target.value) !== "number" || e.target.value > (self.gridUIStates.grid[type].length + 1)) {
                        input.parentElement.classList.add('error');
                        return;
                    }
                    input.parentElement.classList.remove('error');
                    self.gridBuilderChangeGrid(id, input.dataset.type, parseInt(e.target.value))
                })
            })
        })

        // span toggle
        const spanToggles = document.querySelectorAll('.gridUI__span-toggle div');
        spanToggles.forEach(toggle => {
            toggle.addEventListener('click', () => {
                let value;
                toggle.classList.contains('active') ? value = 0 : value = 1;
                self.gridBuilderChangeGrid(id, toggle.dataset.type, value, true)
            })
        })

        // label
        const labelInput = document.querySelector('.gridUI__grid-inputs.label');
        if(!labelInput) return;
        labelInput.addEventListener('input', (e) => {
            if(e.target.value === "") {
                labelInput.parentElement.classList.add('error');
                return;
            }
            labelInput.parentElement.classList.remove('error');
            const gridObj = Object.values(self.gridUIStates.elements).find(el => el && el.id === id);
            if(!gridObj) return;
            gridObj.label = e.target.value;
            self.gridBuilderInitPreview();
            self.gridBuilderSaveSettings();
        })
    

        // zIndex
        const zIndexInput = document.querySelector('.gridUI__grid-inputs.z-index');
        if(!zIndexInput) return;
        events.forEach(event => {
            zIndexInput.addEventListener(event, (e) => {
                if(typeof parseInt(e.target.value) !== "number") {
                    zIndexInput.parentElement.classList.add('error');
                    return;
                }
                zIndexInput.parentElement.classList.remove('error');
                const gridObj = Object.values(self.gridUIStates.elements).find(el => el && el.id === id);
                if(!gridObj) return;
                gridObj.zIndex = parseInt(e.target.value);
                self.gridBuilderSaveSettings();
            })
        })

        // Color
        const colorInput = document.querySelector('.gridUI__grid-inputs.color');
        if(!colorInput) return;
        events.forEach(event => {
            colorInput.addEventListener(event, (e) => {
                if(typeof parseInt(e.target.value) !== "number") {
                    colorInput.parentElement.classList.add('error');
                    return;
                }
                colorInput.parentElement.classList.remove('error');
                const gridObj = Object.values(self.gridUIStates.elements).find(el => el && el.id === id);
                if(!gridObj) return;
                gridObj.color = parseInt(e.target.value);
                self.gridBuilderInitPreview();
                self.gridBuilderSaveSettings();
            })
        })
    },
    gridBuilderChangeGrid: function(id, type, value, reloadChild = false){
        const self = this;
        if(typeof value !== "number") return;
        const gridObj = Object.values(self.gridUIStates.elements).find(el => el && el.id === id);
        if(!gridObj) return;
        gridObj[type] = value;

         // Add Cols
         if(type === 'yEnd' && value > (self.gridUIStates.grid.col.length + 1)){
            const newCols = value - self.gridUIStates.grid.col.length + 1;
            for(let i = 0; i < newCols; i++){
                self.gridUIStates.grid.col.push('1fr');
            }
        }

        // Add Rows
        if(type === 'xEnd' && value > (self.gridUIStates.grid.row.length + 1)){
            const newRows = value - self.gridUIStates.grid.row.length + 1;
            for(let i = 0; i < newRows; i++){
                self.gridUIStates.grid.row.push('1fr');
            }
        }

        self.gridBuilderSaveSettings();
        self.gridBuilderInitPreview();
        self.gridBuilderInitParent();
        if (reloadChild) self.gridBuilderInitChild();

    },
    gridBuilderRemoveActiveChild: function(){
        const self = this;
        self.gridUIStates.activeChild = null;
        self.gridBuilderSetChildInfo(false);
        self.gridBuilderInitPreview();
    },
    gridBuilderDeleteElementSettings: function(id){
        const self = this;
        const obj = Object.values(self.gridUIStates.elements).find(el => el && el.id === id);
        delete obj.xStart;
        delete obj.xEnd;
        delete obj.yStart;
        delete obj.yEnd;
        delete obj.xSpan;
        delete obj.xSpanValue;
        delete obj.ySpan;
        delete obj.ySpanValue;
        self.gridBuilderSaveSettings();
        self.gridBuilderInitPreview();
        self.gridBuilderInitParent();
        self.gridBuilderInitChild();
    },
    gridBuilderDragStartElement: function(el){
        const self = this;
        self.gridUIStates.draggingEl = el;
        //el.classList.add('moving');
        //intersect
        self.gridUIStates.els = [];
        const resizedRect = el.getBoundingClientRect();
        const guides = document.querySelectorAll('.gridUI__grid-guide');
        guides.forEach((guide) => {
            const guideRect = guide.getBoundingClientRect();

            // Check for intersection
            if (
                resizedRect.right > guideRect.left &&
                resizedRect.left < guideRect.right &&
                resizedRect.bottom > guideRect.top &&
                resizedRect.top < guideRect.bottom
            ) {
                // Intersection detected, you can handle it here
                if(!self.gridUIStates.els.includes(guide)) self.gridUIStates.els.push(guide);
            } else {
                self.gridUIStates.els = self.gridUIStates.els.filter(item => item !== guide);
            }
        });

        const sizeX = self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'xEnd', 'max') - self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'xStart', 'min');
        const sizeY = self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'yEnd', 'max') - self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'yStart', 'min');
        self.gridUIStates.draggingElSize = [sizeX, sizeY];
    },

    gridBuilderDragElement: function(el){
        //el.stopPropagation();
        const container = document.querySelector('.gridUI__grid-container-guide');
        container.style.zIndex = 2;
        const activeEl = document.querySelector('.gridUI__grid-element.active');
        if(!activeEl) return;
        activeEl.classList.add('inactive');
        activeEl.classList.remove('active');
        
    },

    gridBuilderDragEnd: function(){
        const self = this;
        const container = document.querySelector('.gridUI__grid-container-guide');
        container.style.zIndex = 0;
        self.gridBuilderSaveSettings();
    },

    gridBuilderDropElement: function(e){
        const self = this;
        const xEnd = parseInt(e.dataset.xEnd);
        const yEnd = parseInt(e.dataset.yEnd);
        const xStartTemp = xEnd - parseInt(self.gridUIStates.draggingElSize[0]);
        const yStartTemp = yEnd - parseInt(self.gridUIStates.draggingElSize[1]);
        const xStart = (xStartTemp > 0) ? xStartTemp : 1;
        const yStart = (yStartTemp > 0) ? yStartTemp : 1;
        const obj = Object.values(self.gridUIStates.elements).find(el => el && el.id === self.gridUIStates.draggingEl.dataset.id);
        if(obj.hasOwnProperty('xSpan')) delete obj.xSpan;
        if(obj.hasOwnProperty('xSpanValue')) delete obj.xSpanValue;
        if(obj.hasOwnProperty('ySpan')) delete obj.ySpan;
        if(obj.hasOwnProperty('ySpanValue')) delete obj.ySpanValue;
        obj.xStart = xStart;
        obj.xEnd = xEnd;
        obj.yStart = yStart;
        obj.yEnd = yEnd;

        // Add Cols
        if(yEnd > (self.gridUIStates.grid.col.length + 1)){
            const newCols = yEnd - self.gridUIStates.grid.col.length + 1;
            for(let i = 0; i < newCols; i++){
                self.gridUIStates.grid.col.push('1fr');
            }
        }

        // Add Rows
        if(xEnd > (self.gridUIStates.grid.row.length + 1)){
            const newRows = xEnd - self.gridUIStates.grid.row.length + 1;
            for(let i = 0; i < newRows; i++){
                self.gridUIStates.grid.row.push('1fr');
            }
        }
        self.gridBuilderSaveSettings();
        self.gridBuilderInitPreview();
        self.gridBuilderInitParent();
        self.gridBuilderInitChild();
    },

    gridBuilderBuildCSS: function(){
        const self = this;
        const styleSheet = document.querySelector('#gridUI__grid-elements');
        content = '';
        for(const key of Object.keys(self.gridUIStates.elements)){
            let hasStyle = false;
            let xStyles = false;
            let yStyles = false;

            // x
            if(self.gridUIStates.elements[key].hasOwnProperty('xSpan') && self.gridUIStates.elements[key].xSpan === 1 && self.gridUIStates.elements[key].hasOwnProperty('xSpanValue')){
                hasStyle = true;
                xStyles = `grid-row: span ${self.gridUIStates.elements[key].xSpanValue};`
            } else if(self.gridUIStates.elements[key].hasOwnProperty('xStart') && self.gridUIStates.elements[key].hasOwnProperty('xEnd')){
                hasStyle = true;
                xStyles = `grid-row: ${self.gridUIStates.elements[key].xStart} / ${self.gridUIStates.elements[key].xEnd};`
            }

            // y
            if(self.gridUIStates.elements[key].hasOwnProperty('ySpan') && self.gridUIStates.elements[key].ySpan === 1 && self.gridUIStates.elements[key].hasOwnProperty('ySpanValue')){
                hasStyle = true;
                yStyles = `grid-column: span ${self.gridUIStates.elements[key].ySpanValue};`
            } else if(self.gridUIStates.elements[key].hasOwnProperty('yStart') && self.gridUIStates.elements[key].hasOwnProperty('yEnd')){
                hasStyle = true;
                yStyles = `grid-column: ${self.gridUIStates.elements[key].yStart} / ${self.gridUIStates.elements[key].yEnd};`
            }

            // Styles
            if(hasStyle){
                content += `.gridUI__grid-element[data-id="${self.gridUIStates.elements[key].id}"]{`;
                if(xStyles) content += xStyles;
                if(yStyles) content += yStyles;
                content += '}';
            }

        }
        styleSheet.innerHTML = content;
    },

    gridBuilderSetGridGuides: function(){
        const self = this;
        const container = document.querySelector('.gridUI__grid-container-guide');
        const max = Array.from(self.gridUIStates.grid.col).length * Array.from(self.gridUIStates.grid.row).length;

        // Clear existing content
        container.innerHTML = '';

        // Create and append elements with valid dimensions
        for (let i = 0; i < max; i++) {
            const guide = document.createElement('div');
            guide.classList.add('gridUI__grid-guide');
            guide.setAttribute('data-id', i);
            guide.setAttribute('draggable', 'true');
            guide.setAttribute('ondragenter' , "this.classList.add('active')" );
            guide.setAttribute('ondragleave', "this.classList.remove('active')" );
            guide.setAttribute('ondragover', "event.preventDefault()" )
            guide.setAttribute('ondrop', 'ADMINBRXC.gridBuilderDropElement(this)');
            container.appendChild(guide);
        }

    },

    gridBuilderCalculateGridPosition: function() {
        const gridContainer = document.querySelector('.gridUI__grid-container');
        const gridGuides = document.querySelectorAll('.gridUI__grid-guide');
        const colCount = parseInt(window.getComputedStyle(gridContainer).gridTemplateColumns.split(' ').length);

        let row = 0;
        let col = 0;

        gridGuides.forEach(function(guide) {
            guide.setAttribute('data-x-start', row + 1);
            guide.setAttribute('data-x-end', row + 2);
            guide.setAttribute('data-y-start', col + 1);
            guide.setAttribute('data-y-end', col + 2);

            col++;

            if (col >= colCount) {
            col = 0;
            row++;
            }
        });
    },

    gridBuilderSetHandles: function(){
        const self = this;
        const handles = document.querySelectorAll('.gridUI__grid-handle-container');
        handles.forEach(handle => {
            self.gridBuilderMakeResizableDiv(handle);
        })
    },

    gridBuilderFindExtremeValue: function(elements, attribute, type) {
        if (elements.length === 0) {
            return undefined; // Return undefined if there are no elements
        }

        // Use the reduce function to find the extreme value
        const initialValue = parseInt(elements[0].dataset[attribute], 10);
        const extremeValue = Array.from(elements).reduce((extreme, element) => {
            const attributeValue = parseInt(element.dataset[attribute], 10); // Assuming the attribute is stored in the 'data-' attribute

            if (!isNaN(attributeValue)) {
            return type === 'min' ? Math.min(extreme, attributeValue) : Math.max(extreme, attributeValue);
            } else {
            return extreme;
            }
        }, initialValue);

        return extremeValue;
    },

    gridBuilderCalculateNewPosition: function(id, els){
        const self = this;
        const xStart = self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'xStart', 'min')
        const xEnd = self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'xEnd', 'max')
        const yStart = self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'yStart', 'min')
        const yEnd = self.gridBuilderFindExtremeValue(self.gridUIStates.els, 'yEnd', 'max');
        const obj = Object.values(self.gridUIStates.elements).find(el => el && el.id === id);
        
        delete obj.xSpan;
        delete obj.xSpanValue;
        delete obj.ySpan;
        delete obj.ySpanValue;
        
        obj.xStart = xStart;
        obj.xEnd = xEnd;
        obj.yStart = yStart;
        obj.yEnd = yEnd;

    },

    gridBuilderMakeResizableDiv: function(div) {
        const self = this;
        const handles = div.querySelectorAll('.gridUI__grid-handle.resize');
        let isResizing = false;
        let startX, startY;

        handles.forEach(handle => {
            const xDirection = handle.dataset.xDir;
            const yDirection = handle.dataset.yDir;

            handle.addEventListener("mousedown", (e) => {
                e.preventDefault();
                e.stopPropagation();
                handle.parentElement.style.zIndex = 2;
                handle.parentElement.parentElement.classList.add('moving');
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                document.addEventListener("mousemove", handleMouseMove);
                document.addEventListener("mouseup", handleMouseUp);
                const activeEl = document.querySelector('.gridUI__grid-element.active');
                if(!activeEl) return;
                activeEl.classList.add('inactive');
                activeEl.classList.remove('active');
            });
        
            function handleMouseUp(){
                isResizing = false;
                document.removeEventListener("mousemove", handleMouseMove);
                document.removeEventListener("mouseup", handleMouseUp);
                self.gridBuilderCalculateNewPosition(handle.parentElement.parentElement.dataset.id, self.gridUIStates.els);
                self.gridBuilderSaveSettings();
                self.gridBuilderInitPreview();
                self.gridBuilderInitParent();
                self.gridBuilderInitChild();
            }
            function handleMouseMove(e) {
                if (isResizing) {
                    e.stopPropagation();
                    self.gridUIStates.els = [];
                    const deltaX = xDirection === "ltr" ? e.clientX - startX : -e.clientX + startX;
                    const deltaY = yDirection === "ttb" ? e.clientY - startY : -e.clientY + startY ;

                    // Calculate the new width and height based on the initial position
                    const newWidth = div.getBoundingClientRect().width + deltaX;
                    const newHeight = div.getBoundingClientRect().height + deltaY;

                    // Ensure resizing within the boundaries of the container
                    div.style.width = `${newWidth}px`;
                    div.style.height = `${newHeight}px`;
                    div.style.left = xDirection === "ltr" ? '0' : `auto`;
                    div.style.top = yDirection === "ttb" ? '0' : `auto`;

                    // Update the start position for the next movement
                    startX = e.clientX;
                    startY = e.clientY;

                    //intersect
                    const resizedRect = div.getBoundingClientRect();
                    const guides = document.querySelectorAll('.gridUI__grid-guide');
                    guides.forEach((guide) => {
                        const guideRect = guide.getBoundingClientRect();

                        // Check for intersection
                        if (
                            resizedRect.right >= guideRect.left &&
                            resizedRect.left <= guideRect.right &&
                            resizedRect.bottom >= guideRect.top &&
                            resizedRect.top <= guideRect.bottom
                        ) {
                            // Intersection detected, you can handle it here
                            guide.classList.add('active');
                            if(!self.gridUIStates.els.includes(guide)) self.gridUIStates.els.push(guide);
                        } else {
                            guide.classList.remove('active');
                            self.gridUIStates.els = self.gridUIStates.els.filter(item => item !== guide);
                        }
                    });
                }
            }
        })
    },

    gridBuilderSetHeaders: function(){
        const self = this;
        const headerTop = document.querySelector('.gridUI__grid-header.top');
        const headerLeft = document.querySelector('.gridUI__grid-header.left');
        let content = '';

        let i = 0;
        for(const value of Array.from(self.gridUIStates.grid.col)){
            content += `<div class="input-wrapper" data-balloon="Invalid CSS value" data-balloon-pos="top"><input type="text" value="${value}" data-type="col" data-index="${i}"></div>`;
            i++;
        }
        headerTop.innerHTML = content;

        content = '';
        i = 0;
        for(const value of Array.from(self.gridUIStates.grid.row)){
            content += `<div class="input-wrapper" data-balloon="Invalid CSS value" data-balloon-pos="top"><input type="text" value="${value}" data-type="row" data-index="${i}"></div>`
            i++;
        }
        headerLeft.innerHTML = content;
        const headerInputs = document.querySelectorAll('.gridUI__grid-header input');
        headerInputs.forEach(input => {
            input.addEventListener('input', (e) => {
                if(!CSS.supports("grid-template-columns", input.value)) {
                    input.parentElement.classList.add('error');
                    return;
                }
                input.parentElement.classList.remove('error');
                const type = input.dataset.type;
                const index = input.dataset.index;
                self.gridUIStates.grid[type][index] = input.value; 
                self.gridBuilderSetGridCSS();
                self.gridBuilderSaveSettings();
            })
        })
    },

    gridBuilderInitPreview: function(){
        const self = this;
        self.gridBuilderSetGridCSS();
        self.gridBuilderSetGridElements();
        self.gridBuilderSetGridGuides();
        self.gridBuilderSetHeaders();
        self.gridBuilderCalculateGridPosition();
        self.gridBuilderBuildCSS();
        self.gridBuilderSetHandles();
    },
    gridBuilderInitParent: function(){
        const self = this;
        self.gridBuilderSetParentInfo();
    },
    gridBuilderInitChild: function(){
        const self = this;
        if(self.gridUIStates.activeChild === null) return self.gridBuilderSetChildInfo(false);
        self.gridBuilderSetChildInfo(self.gridUIStates.activeChild);
    },

    gridBuilderCalculateGridCols: function(checkRows = true, rows, cols){
        const self = this;
        const container = document.querySelector('.gridUI__grid-container');
        const tempRows = window.getComputedStyle(container).getPropertyValue("grid-template-rows").split(' ').length;
        if(checkRows && parseInt(globalRows) < parseInt(tempRows)) {
            self.gridUIStates.globalRows = parseInt(tempRows);
            document.querySelector('#rows').value = self.gridUIStates.globalRows;
        }
        const main = document.querySelector('.gridUI__main-container');

        // main.style.setProperty('--col', globalCols);
        // main.style.setProperty('--row', globalRows);
        // main.style.setProperty('--gap', globalGap);

    },
    gridBuilderLoadDefaultGrid: function(){
        const self = this;
        self.gridUIStates.grid = {}
            self.gridUIStates.grid.col = []
            self.gridUIStates.grid.row = []
            // Cols
            const defaultCols = {
                '991': 3,
                '767': 2,
                '478': 1,
            };
            const orderedKeys = ['991', '767', '478'];

            const currentVw = parseInt(self.vueState.previewWidth);
            let finalCol = false;
            for(const key of orderedKeys){
                if(currentVw <= parseInt(key)) finalCol = defaultCols[key];
            }
            if(finalCol === false) finalCol = 4;
            for(let i = 0; i < finalCol; i++){
                self.gridUIStates.grid.col[i] = '1fr';
            }

            // Rows
            let finalRows;
            const numberItems = Object.keys(JSON.parse(self.gridUIStates.children)).length;
            numberItems === 0 ? finalRows = 1 : finalRows = Math.ceil(numberItems / finalCol);
            for(let i = 0; i < finalRows; i++){
                self.gridUIStates.grid.row[i] = '1fr';
            }

            // Gap
            self.gridUIStates.grid.gap = '20px';
    },
    gridBuilderLoadGrid: function(){
        const self = this;

        const parent = self.helpers.getFinalObject();
        const target = self.helpers.createTargetWithPseudo('gridBuilderSettings');
        const higherBp = self.gridUIStates.isClass ? self.helpers.checkHigherBreakpoint('gridBuilderSettings', 'class') : self.helpers.checkHigherBreakpoint('gridBuilderSettings', 'element');
        if(parent.settings.hasOwnProperty(target)){
            self.gridUIStates.grid = JSON.parse(JSON.stringify(parent.settings[target].grid));
        } else if(higherBp){
            self.gridUIStates.grid = JSON.parse(JSON.stringify(parent.settings[higherBp].grid));
        } else {
            self.gridBuilderLoadDefaultGrid();
        }
        
    },

    // gridBuilderSetGridCSS: function(){
    //     const self = this;
    //     const main = document.querySelector('.gridUI__main-container');
    //     main.style.setProperty('--globalCol', Array.from(self.gridUIStates.grid.col).map(value => value).join(' '));
    //     main.style.setProperty('--globalGap', self.gridUIStates.grid.gap);
    //     let autoFlow;
    //     self.gridUIStates.grid.autoFlow === true ? autoFlow = 'dense' : autoFlow = 'initial';
    //     main.style.setProperty('--globalAutoFlow', autoFlow);
       
    //     const container = main.querySelector('.gridUI__grid-container');
    //     setTimeout(() => {

    //         const realRows = window.getComputedStyle(container).gridTemplateRows;
    //         const numRealRows = realRows.split(' ').length;
    //         const calculatedRows = Array.from(self.gridUIStates.grid.row).map(value => value).join(' ')
    //         const numCalculatedRows = calculatedRows.split(' ').length;

    //         if(numRealRows > numCalculatedRows){
    //             main.style.setProperty('--globalRow', 'auto');
    //             setTimeout(() => {
    //                 for(let i = 0; i < numRealRows - numCalculatedRows; i++){
    //                     self.gridUIStates.grid.row.push('1fr')
    //                 }
    //                 self.gridUIStates.globalRows = numRealRows;
    //                 self.gridBuilderInitParent();
    //                 self.gridBuilderInitPreview();
    //             },5)

    //         } else {
    //             main.style.setProperty('--globalRow', calculatedRows);
    //         }
    //     }, 5)
    // },
    gridBuilderSetGridCSS: function(){
        const self = this;
        const main = document.querySelector('.gridUI__main-container');
        main.style.setProperty('--globalCol', Array.from(self.gridUIStates.grid.col).map(value => value).join(' '));
        main.style.setProperty('--globalRow', Array.from(self.gridUIStates.grid.row).map(value => value).join(' '));
        main.style.setProperty('--globalGap', self.gridUIStates.grid.gap);
        const autoFlow = self.gridUIStates.grid.autoFlow === true ? 'dense' : 'initial';
        main.style.setProperty('--globalAutoFlow', autoFlow);
    },
    gridBuilderLoadElements: function(initialize = false){
        const self = this;
        const isCSS = self.gridUIStates.isClass || self.gridUIStates.hasQuery || self.gridUIStates.hasComponent;

        let tempEls = [];
        const activeEl = self.helpers.getFinalObject();
        const children = JSON.parse(self.gridUIStates.children);
        const target = self.helpers.createTargetWithPseudo('gridBuilderSettings');
        const higherBp = self.gridUIStates.isClass === true ? self.helpers.checkHigherBreakpoint('gridBuilderSettings', 'class') : self.helpers.checkHigherBreakpoint('gridBuilderSettings', 'element');
        let gridSettings = false;
        if(activeEl.settings.hasOwnProperty(target)) {
            gridSettings = activeEl.settings[target];
        } else if(higherBp){
            gridSettings = activeEl.settings[higherBp];
        } 

        // Element
        if(!isCSS){
            for(let i = 0; i<children.length; i++){
                const obj = self.helpers.getElementObject(children[i]);
                tempEls[i] = {};
                tempEls[i].id = children[i];
                const label = obj.hasOwnProperty('label') ? obj.label : bricksData.elements[obj.name].label;
                tempEls[i].label = label;
                if(gridSettings && !initialize){
                    const gridObj = Object.values(gridSettings.elements).find(el => el && el.id === children[i])
                    if(gridObj){
                        // Position
                        if(gridObj.hasOwnProperty('xStart')) tempEls[i].xStart = gridObj.xStart;
                        if(gridObj.hasOwnProperty('xEnd')) tempEls[i].xEnd = gridObj.xEnd;
                        if(gridObj.hasOwnProperty('xSpan')) tempEls[i].xSpan = gridObj.xSpan;
                        if(gridObj.hasOwnProperty('xSpanValue')) tempEls[i].xSpanValue = gridObj.xSpanValue;
                        if(gridObj.hasOwnProperty('yStart')) tempEls[i].yStart = gridObj.yStart; 
                        if(gridObj.hasOwnProperty('yEnd')) tempEls[i].yEnd = gridObj.yEnd;
                        if(gridObj.hasOwnProperty('ySpan')) tempEls[i].ySpan = gridObj.ySpan;
                        if(gridObj.hasOwnProperty('ySpanValue')) tempEls[i].ySpanValue = gridObj.ySpanValue;


                        // zIndex
                        if(gridObj.hasOwnProperty('zIndex')) tempEls[i].zIndex = gridObj.zIndex;

                        // Color
                        if(gridObj.hasOwnProperty('color')) tempEls[i].color = gridObj.color; 
                    }
                }
            } 

        // Class
        } else {
            let childrenLength = Object.keys(children).length;
            // Existing settings
            if(gridSettings){
                tempEls = JSON.parse(JSON.stringify(gridSettings.elements));
                // if(gridSettings.elements.length > childrenLength){
                //     const minus = gridSettings.elements.length - childrenLength;
                //     for(let i = 0; i<minus; i++){
                //         tempEls.pop();
                //     }
                // }
                if (tempEls.length > childrenLength) childrenLength = tempEls.length;
                for(let i = 0; i<childrenLength; i++){
                    if(!tempEls[i]) tempEls[i] = {};
                    tempEls[i].id = `${i + 1}`;
                    tempEls[i].label = `nth-child(${i + 1})`;
                }
            
            // Generate new settings
            } else {
                for(let i = 0; i<childrenLength; i++){
                    tempEls[i] = {};
                    tempEls[i].id = `${i + 1}`;
                    tempEls[i].label = `nth-child(${i + 1})`;
                }
            }
        }

        self.gridUIStates.elements = tempEls;
        
        for(const key of Object.keys(self.gridUIStates.elements)){
            const color = Math.floor(Math.random() * 360)
            if(!self.gridUIStates.elements[key].hasOwnProperty('color')) self.gridUIStates.elements[key].color = color;
        }
    },

    gridBuilderAddColumn: function(){
        const self = this;
        self.gridUIStates.grid.col[Array.from(self.gridUIStates.grid.col).length] = '1fr';
        self.gridUIStates.grid.colWidth = Array.from(self.gridUIStates.grid.col).length;
        self.gridBuilderSaveSettings();
    },

    gridBuilderRemoveColumn: function(){
        const self = this;
        self.gridUIStates.grid.col.pop();
        self.gridUIStates.grid.colWidth = Array.from(self.gridUIStates.grid.col).length;
        self.gridBuilderSaveSettings();
    },

    gridBuilderAddRow: function(){
        const self = this;
        self.gridUIStates.grid.row[Array.from(self.gridUIStates.grid.row).length] = '1fr';
        self.gridUIStates.grid.rowWidth = Array.from(self.gridUIStates.grid.row).length;
        self.gridBuilderSaveSettings();
    },

    gridBuilderRemoveRow: function(){
        const self = this;
        self.gridUIStates.grid.row.pop();
        self.gridUIStates.grid.rowWidth = Array.from(self.gridUIStates.grid.row).length;
        self.gridBuilderSaveSettings();
    },

    gridBuilderListenInputs: function(){
        const self = this;
        let inputs = document.querySelectorAll('.gridUI__grid-inputs');

        self.gridUIStates.globalCols = inputs[0].value === "" ? 0 : parseInt(inputs[0].value);
        self.gridUIStates.globalRows = inputs[1].value === "" ? 0 : parseInt(inputs[1].value);
        self.gridUIStates.grid.gap = inputs[2].value;

        self.gridUIStates.grid.row = [];
        self.gridUIStates.grid.col = [];

        const headerTop = document.querySelectorAll('.gridUI__grid-header.top input');
        const headerLeft = document.querySelectorAll('.gridUI__grid-header.left input');

        for(let i = 0; i < headerTop.length; i++){
            self.gridUIStates.grid.col[i] = headerTop[i].value;
        }
        for(let i = 0; i < headerLeft.length; i++){
            self.gridUIStates.grid.row[i] = headerLeft[i].value;
        }

        // Col
        if(self.gridUIStates.grid.col.length < self.gridUIStates.globalCols) {
            const max = self.gridUIStates.globalCols - self.gridUIStates.grid.col.length;
            for(let i = 0; i<max; i++){
                self.gridBuilderAddColumn()
            }
        } else if(self.gridUIStates.grid.col.length > self.gridUIStates.globalCols){
            const max = self.gridUIStates.grid.col.length - self.gridUIStates.globalCols;
            for(let i = 0; i<max; i++){
                self.gridBuilderRemoveColumn();
            }
        }

        // Row
        if(self.gridUIStates.grid.row.length < self.gridUIStates.globalRows) {
            const max = self.gridUIStates.globalRows - self.gridUIStates.grid.row.length;
            for(let i = 0; i<max; i++){
                self.gridBuilderAddRow()
            }
        } else if(self.gridUIStates.grid.row.length > self.gridUIStates.globalRows){
            const max = self.gridUIStates.grid.row.length - self.gridUIStates.globalRows;
            for(let i = 0; i<max; i++){
                self.gridBuilderRemoveRow()
            }
        }

        self.gridBuilderSaveSettings();
    },
    gridBuilderIsQueryLoop: function(){
        const self = this;
        const children = self.helpers.getFinalObject(true)?.children;
        let hasQuery = false;
        if(children && children.length > 0) {
            hasQuery = children.some(el => self.helpers.getElementObject(el, true)?.settings?.hasOwnProperty('hasLoop') && self.helpers.getElementObject(el, true).settings.hasLoop === true); 
        }
        self.gridUIStates.hasQuery = hasQuery ? true : false;
    },
    gridBuilderhasComponent: function(){
        const self = this;
        const children = self.helpers.getFinalObject(true)?.children;
        let hasComponent = false;
        if(children && children.length > 0) {
            hasComponent = children.some(el => self.helpers.getElementObject(el, true)?.hasOwnProperty('cid')); 
        }
        self.gridUIStates.hasComponent = hasComponent ? true : false;
    },
    gridBuilderSetChildren: function(){
        const self = this;
        const isCSS = self.gridUIStates.isClass || self.gridUIStates.hasQuery || self.gridUIStates.hasComponent;
        const elementObj = self.helpers.getFinalObject(true); 
        self.gridUIStates.children = isCSS ? JSON.stringify(FRAMEBRXC.vueGlobalProp.$_getElementNode(elementObj).children) : JSON.stringify(elementObj.children);
    },
  
    gridBuilderIsClass: function(){
        const self = this;
        self.gridUIStates.isClass = self.helpers.isClassActive() ? true : false;
    },

    gridBuilderInit: function(){
        const self = this;
        self.gridUIStates.activeChild = null;
        self.gridBuilderSetHeight();
        self.gridBuilderIsQueryLoop();
        self.gridBuilderhasComponent();
        self.gridBuilderIsClass();
        self.gridBuilderSetBreakpoints();
        self.gridBuilderSetChildren();
        self.gridBuilderSetNotification();
        self.gridBuilderLoadGrid();
        self.gridBuilderSetGridCSS();
        self.gridBuilderLoadElements();
        self.gridBuilderResizableWidth()
        self.gridBuilderResizableHeight()
        self.gridBuilderInitPreview();
        self.gridBuilderInitParent();
        self.gridBuilderInitChild();
    },
    gridBuilderSaveSettings: function(){
        const self = this;
        const parent = self.helpers.getFinalObject();
        const target = self.helpers.createTargetWithPseudo('gridBuilderSettings');

        parent.settings[target] = {};
        parent.settings[target].grid = self.gridUIStates.grid;
        parent.settings[target].elements = self.gridUIStates.elements;
        if(self.gridUIStates.isClass === true) ADMINBRXC.helpers.saveChanges('globalClasses');
        self.vueState.rerenderControls = Date.now();
    },
    gridBuilderRemovePreviousCSS: function(css){
        const pattern = /\/\*\* GRID BUILDER[\s\S]*?End of Grid Builder CSS \*\*\//g;
        return css.replaceAll(pattern, '');
    },
    gridBuilderApply: function(){
        const self = this;
        const isCSS = self.gridUIStates.isClass || self.gridUIStates.hasQuery || self.gridUIStates.hasComponent;
        const parent = self.helpers.getFinalObject();
        

        // parent
        const targetGap = self.helpers.createTargetWithPseudo('_gridGap');
        parent.settings[targetGap] = self.gridUIStates.grid.gap;


        // ID
        if(!isCSS){

            // parent
            const targetCol = self.helpers.createTargetWithPseudo('_gridTemplateColumns');
            const targetRow = self.helpers.createTargetWithPseudo('_gridTemplateRows');
            const targetAutoFlow = self.helpers.createTargetWithPseudo('_gridAutoFlow');
            parent.settings[targetCol] = Array.from(self.gridUIStates.grid.col).map(value => self.gridUIStates.grid.hasOwnProperty('minmax') &&  self.gridUIStates.grid.minmax === true ? `minmax(0,${value})` : value).join(' ');
            parent.settings[targetRow] = Array.from(self.gridUIStates.grid.row).map(value => self.gridUIStates.grid.hasOwnProperty('minmax') &&  self.gridUIStates.grid.minmax === true ? `minmax(0,${value})` : value).join(' ');
            parent.settings[targetAutoFlow] = self.gridUIStates.grid.autoFlow === true ? 'dense' : '';

            //children
            const children = JSON.parse(self.gridUIStates.children);
            if(!Array.isArray(children) || children.length < 1) return;
            children.forEach(child => {
                const gridElement = Object.values(self.gridUIStates.elements).find(el => el && el.id === child);
                if(!gridElement) return;
                const obj = self.helpers.getElementObject(child);
                if(!obj.hasOwnProperty('settings')) obj.settings = {};

                // x
                const targetRowSpan = self.helpers.createTargetWithPseudo('_gridItemRowSpan');
                if(gridElement.hasOwnProperty('xSpan') && gridElement.xSpan === 1 && gridElement.hasOwnProperty('xSpanValue')) {
                    obj.settings[targetRowSpan] = `span ${gridElement.xSpanValue}`;
                } else {
                    gridElement.hasOwnProperty('xStart') && gridElement.hasOwnProperty('xEnd') ? obj.settings[targetRowSpan] = `${gridElement.xStart} / ${gridElement.xEnd}` : obj.settings[targetRowSpan] = 'unset';
                }

                // 
                const targetColSpan = self.helpers.createTargetWithPseudo('_gridItemColumnSpan');
                if(gridElement.hasOwnProperty('ySpan') && gridElement.ySpan === 1 && gridElement.hasOwnProperty('ySpanValue')) {
                    obj.settings[targetColSpan] = `span ${gridElement.ySpanValue}`;
                } else {
                    gridElement.hasOwnProperty('yStart') && gridElement.hasOwnProperty('yEnd') ? obj.settings[targetColSpan] = `${gridElement.yStart} / ${gridElement.yEnd}` : obj.settings[targetColSpan] = 'unset';
                }
                const targetZIndex =  self.helpers.createTargetWithPseudo('_zIndex');
                if (gridElement.hasOwnProperty('zIndex')) obj.settings[targetZIndex] = gridElement.zIndex;
                if (gridElement.label !== obj.label) obj.label = gridElement.label
            })

        // Class
        }  else {
            const elements = self.gridUIStates.elements;
            const selector = self.gridUIStates.isClass ? `.${parent.name}` : `#${self.vueGlobalProp.$_getElementId()}`;
            let cssChild = '';
            let cssParent = '';
            let hasParentStyle = false;

            // Parent CSS
            if(self.gridUIStates.grid.col && self.gridUIStates.grid.col.length > 0){
                hasParentStyle = true;
                cssParent += `grid-template-columns: ${Array.from(self.gridUIStates.grid.col).map(value => self.gridUIStates.grid.hasOwnProperty('minmax') &&  self.gridUIStates.grid.minmax === true ? `minmax(0,${value})` : value).join(' ')};`;
            }
            if(self.gridUIStates.grid.row && self.gridUIStates.grid.row.length > 0){
                hasParentStyle = true;
                cssParent += `grid-template-rows: ${Array.from(self.gridUIStates.grid.row).map(value => self.gridUIStates.grid.hasOwnProperty('minmax') &&  self.gridUIStates.grid.minmax === true ? `minmax(0,${value})` : value).join(' ')};`;
            }

            if(self.gridUIStates.grid.autoFlow === true){
                hasParentStyle = true;
                cssParent += `grid-auto-flow: dense;`;
            } else {
                hasParentStyle = true;
                cssParent += `grid-auto-flow: unset;`;
            }

            // Children CSS
            for(const key of Object.keys(elements)){
                const element = elements[key];
                let hasStyle = false;
                let xCSS = '';
                let yCSS = '';
                let zIndex = '';

                // x
                if(element.hasOwnProperty('xSpan') && element.xSpan === 1 && element.hasOwnProperty('xSpanValue')) {
                    hasStyle = true;
                    xCSS = `grid-row: span ${element.xSpanValue};`;
                } else if(element.hasOwnProperty('xStart') && element.hasOwnProperty('xEnd')){
                    hasStyle = true;
                    xCSS = `grid-row: ${element.xStart} / ${element.xEnd};`
                }

                // y
                if(element.hasOwnProperty('ySpan') && element.ySpan === 1 && element.hasOwnProperty('ySpanValue')) {
                    hasStyle = true;
                    yCSS = `grid-column: span ${element.ySpanValue};`;
                } else if(element.hasOwnProperty('yStart') && element.hasOwnProperty('yEnd')){
                    hasStyle = true;
                    yCSS = `grid-column: ${element.yStart} / ${element.yEnd};`
                }

                // z-index
                if(element.hasOwnProperty('zIndex')){
                    hasStyle = true;
                    zIndex = `z-index: ${element.zIndex};`
                }
                if(hasStyle){
                    const label = self.gridUIStates.grid.repeat === true ? `nth-child(${self.gridUIStates.elements.length}n+${element.id})` : `nth-child(${element.id})`
                    cssChild += `${selector} > *:where(:${label}){${xCSS}${yCSS}${zIndex}}\n\n`;
                }
            }
            if(!hasParentStyle && cssChild === '') return self.vueGlobalProp.$_showMessage(`Abort: no styles to apply on ${activebp.label}`);;

            let css = `/** GRID BUILDER (autogenerated on ${new Date(Date.now()).toLocaleDateString()}) **/\n\n`;
            
            if(hasParentStyle){
                css += `${selector}{${cssParent}}\n\n${selector}>*{grid-row:unset;grid-column:unset;}\n\n`;
            }
            if(cssChild !== ''){
                css += cssChild;
            }

            css += `/** End of Grid Builder CSS **/`;


            const target = self.helpers.createTarget('_cssCustom');
            parent.settings.hasOwnProperty(target) && self.gridUIStates.grid.replaceCSS === true ? parent.settings[target] = self.gridBuilderRemovePreviousCSS(parent.settings[target]) : '';
            css = css_beautify(css, { indent_size: 2 });
            if(!parent.settings.hasOwnProperty(target) || parent.settings[target] === ''){
                parent.settings[target] = css;
            } else {
                parent.settings[target] = `${self.helpers.removeTrailingNewlines(parent.settings[target])}\n\n${css}`;
            }
        }

        const activebp = self.vueState.breakpoints.find(el => el && el.key === self.vueState.breakpointActive);
        self.vueGlobalProp.$_showMessage(`Grid correctly applied on ${activebp.label}`);
    },
    // Box Shadow Generator
    setBoxShadowGenerator: function(){
        const self = this;
        setTimeout(()=> {
            const controls = document.querySelectorAll('[type="box-shadow"]');
            if(!controls || controls.length < 1) return;

            const settings = self.helpers.getFinalObject();
            
            controls.forEach(control => {
                // Copy
                const icon = control.querySelector('.brxc-box-shadow-generator');
                if (icon) icon.remove();
                const controlkey = control.getAttribute('controlkey');
                const target = self.helpers.createTargetWithPseudo(`${controlkey.replaceAll('_', '')}Generator`);
                const cls = settings.hasOwnProperty(target) ?  'brxc-box-shadow-generator bricks-control-preview active': 'brxc-box-shadow-generator bricks-control-preview';

                self.addIconToFields(
                    'div',
                    cls,
                    false,
                    'Box-Shadow Generator',
                    'top-right',
                    `ADMINBRXC.bsInit("${controlkey}");ADMINBRXC.openModal(false,"#brxcBoxShadowUIOverlay");`,
                    false,
                    '<span class="bricks-svg-wrapper"><i class="fas fa-layer-group"></i></span>',
                    control,
                    'child'
                );
                
            })
        }, 100);
    },
    bsSettings: undefined,
    bsTemp: {
        width: 400,
        height: 400,
        borderRadius: 10,
        layerAmount: 5,
        verticalDistance: 32,
        horizontalDistance: 0,
        blur: 24,
        spread: 0,
        shadowRgb: [3, 7, 18],
        //shadowStyle: "soft",
        boxColor: '#ffffff',
        boxBgColor: '#fafafa',
        opacity: 0.08,
        inset: '0',
    },
    bsStates: {
        selector: false,
        activeLayer: null,
        activeWindow: 'generator',
    },
    // Default
    bsRenderBoxShadows: function(obj) {
        const self = this;
        const boxShadows = [];

        const getX = (i) => {
            const startX = 0;
            const endX = obj.horizontalDistance;
            return startX + self.helpers.easeInQuad((i + 1) / obj.layerAmount) * (endX - startX);
        };

        const getY = (i) => {
            const startY = 0;
            const endY = obj.verticalDistance;
            return startY + self.helpers.easeInQuad((i + 1) / obj.layerAmount) * (endY - startY);
        };

        const getBlur = (i) => {
            const startBlur = 0;
            const endBlur = obj.blur;
            return (
            startBlur +
            self.helpers.easeInQuad((i + 1) / obj.layerAmount) * (endBlur - startBlur)
            );
        };

        // let getAlpha = (i) => obj.opacity;
        // if (obj.shadowStyle === "sharp") {
        //     getAlpha = (i) => {
        //     const increment = obj.opacity / obj.layerAmount;
        //     return obj.opacity - i * increment;
        //     };
        // } else if (obj.shadowStyle === "soft") {
        //     getAlpha = (i) => {
        //     const increment = obj.opacity / obj.layerAmount;
        //     return (i + 1) * increment;
        //     };
        // }

        const getAlpha = (i) => {
            const increment = obj.opacity / obj.layerAmount;
            return (i + 1) * increment;
        };


        for (let i = 0; i < obj.layerAmount; i++) {
            const x = getX(i).toFixed(0);
            const y = getY(i).toFixed(0);
            const blur = getBlur(i).toFixed(0);
            const spread = obj.spread;
            const rgb = obj.shadowRgb;
            const alpha = getAlpha(i).toFixed(2);
            const inset = obj.inset;

            boxShadows.push({ x, y, blur, spread, rgb, alpha, inset });
        }

        return boxShadows;
    },

    bsRenderCssShadows: function() {
        const self = this;
        const box = document.querySelector('#boxShadowUI__box');
        const boxShadows = typeof self.bsSettings === "undefined" ? self.bsRenderBoxShadows(self.bsTemp) : self.bsSettings.layers;
        const cssShadows = boxShadows.map(
            ({ x, y, blur, spread, rgb, alpha, inset }) =>
            `${inset === '1' ? 'inset ' : ''}${x}px ${y}px ${blur}px ${spread}px rgba(${Array.isArray(rgb) ? rgb.join(',') : rgb}, ${alpha})`
        );
        box.style.boxShadow = cssShadows.join(",\n  ");

    },
    bsRenderCssBox: function() {
        const self = this;
        const main = document.querySelector('#boxShadowUI__main');
        const box = main.querySelector('#boxShadowUI__box');
        const obj = typeof self.bsSettings === "undefined" ? self.bsTemp : self.bsSettings;

        box.style.width = `${obj.width}px`;
        box.style.height = `${obj.height}px`;
        box.style.borderRadius = `${obj.borderRadius}px`;
        box.style.backgroundColor = obj.boxColor;
        main.style.backgroundColor = obj.boxBgColor;
    },
    bsSetBoxInputs: function(){
        const self = this;
        const obj = typeof self.bsSettings === "undefined" ? self.bsTemp : self.bsSettings;
        const box = document.querySelector('#boxShadowUI__global #boxSettings');
        const arr = [
            {
                id: 'brxcBsWidth',
                title: 'Width',
                min: '0',
                max: '500',
                step: '1',
                property: 'width',
                value: obj.width,

            },
            {
                id: 'brxcBsHeight',
                title: 'Height',
                min: '0',
                max: '500',
                step: '1',
                property: 'height',
                value: obj.height,

            },
            {
                id: 'brxcBsWidthBorderRadius',
                title: 'Border-Radius',
                min: '0',
                max: '500',
                step: '1',
                property: 'borderRadius',
                value: obj.borderRadius,

            },
        ];
        let content = '';
        content += `<div class="brxc__title">Box</div>`;
        arr.forEach(el => {
            content += `
            <div class="brxc__field">
                <label for="${el.id}" class="brxc__label">${el.title}</label>
                <div class="brxc__range">
                    <input id="${el.id}" type="range" min="${el.min}" max="${el.max}" step="${el.step}" value="${el.value}" class="brxc-input__range" 
                        onchange="
                            ADMINBRXC.bsChangeBoxInput('${el.property}', parseInt(this.value));
                            document.querySelector('#${el.id}Value').value = this.value;
                            ADMINBRXC.bsRenderCssBox();
                        " 
                        oninput="
                            ADMINBRXC.bsChangeBoxInput('${el.property}', parseInt(this.value));
                            document.querySelector('#${el.id}Value').value = this.value;
                            ADMINBRXC.bsRenderCssBox();
                        "
                    />
                    <input id="${el.id}Value" type="number" min="${el.min}" max="${el.max}" step="${el.step}" value="${el.value}"
                        onchange="
                            ADMINBRXC.bsChangeBoxInput('${el.property}', parseInt(this.value));
                            document.querySelector('#${el.id}').value = this.value;
                            ADMINBRXC.bsRenderCssBox();
                        " 
                        oninput="
                            ADMINBRXC.bsChangeBoxInput('${el.property}', parseInt(this.value));
                            document.querySelector('#${el.id}').value = this.value;
                            ADMINBRXC.bsRenderCssBox();
                        "
                    />
                </div>
            </div>`;
        })
        content += `
        <div class="brxc__field">
            <label for="boxColor" class="brxc__label">Box Color</label>
            <div class="brxc__simple-color">
                <div id="boxColor" class="brxc-input__simple-color" data-initial="${obj.boxColor}" data-property="boxColor" style="background-color:${obj.boxColor}"></div>
                <input id="$boxColorValue" type="text" value="${obj.boxColor}"
                    oninput="
                        ADMINBRXC.bsChangeBoxInput('boxColor', this.value);
                        document.querySelector('#boxColor').style.backgroundColor = this.value;
                        ADMINBRXC.bsRenderCssBox();
                    "
                />
            </div>
        </div>
        <div class="brxc__field">
            <label for="boxBgColor" class="brxc__label">Background Color</label>
            <div class="brxc__simple-color">
                <div id="boxBgColor" class="brxc-input__simple-color" data-initial="${obj.boxBgColor}" data-property="boxBgColor" style="background-color:${obj.boxBgColor}"></div>
                <input id="$boxBgColorValue" type="text" value="${obj.boxBgColor}"
                    oninput="
                        ADMINBRXC.bsChangeBoxInput('boxBgColor', this.value);
                        document.querySelector('#boxBgColor').style.backgroundColor = this.value;
                        ADMINBRXC.bsRenderCssBox();
                    "
                />
            </div>
        </div>`;
        box.innerHTML = content;
        const simpleColors = document.querySelectorAll('.brxc-input__simple-color');
        simpleColors.forEach(el => {
            // Color Picker
            let picker = new ColorPicker(el, el.dataset.initialColor);
    
            el.addEventListener('colorChange', (event) => {
                const property = el.dataset.property;
                const obj = typeof self.bsSettings === "undefined" ? self.bsTemp : self.bsSettings;
                const color = event.detail.color.rgb;
                el.nextElementSibling.value = color.replace('rgba', 'rgb');
                obj[property] = color;
                self.bsRenderCssBox();
            })
        })
    },
    bsChangeBoxInput: function(prop, value){
        const self = this;
        const obj = typeof self.bsSettings === "undefined" ? self.bsTemp : self.bsSettings;
        obj[prop] = value;
        self.bsRenderCssBox();
    },
    bsSetTempInputs: function(){
        const self = this;
        const box = document.querySelector('#boxShadowUI__global #boxShadowSettings');
        const child = document.querySelector('#boxShadowUI__global #boxShadowUI__child');
        child.innerHTML = '';
        let content = '';
        const arr = [
            {
                id: 'brxcBsLayers',
                title: 'Number of Layers',
                min: '1',
                max: '10',
                step: '1',
                value: '5',
                property: 'layerAmount',

            },
            {
                id: 'brxcBsVerticalDistance',
                title: 'Vertical Distance',
                min: '-500',
                max: '500',
                step: '1',
                value: '32',
                property: 'verticalDistance',

            },
            {
                id: 'brxcBsHorizontalDistance',
                title: 'Horizontal Distance',
                min: '-500',
                max: '500',
                step: '1',
                value: '0',
                property: 'horizontalDistance',

            },
            {
                id: 'brxcBsOpacity',
                title: 'Opacity',
                min: '0.01',
                max: '1',
                step: '0.01',
                value: '0.08',
                property: 'opacity',

            },
            {
                id: 'brxcBsBlur',
                title: 'Blur',
                min: '0',
                max: '100',
                step: '1',
                value: '24',
                property: 'blur',

            },
            {
                id: 'brxcBsSpread',
                title: 'Spread',
                min: '-100',
                max: '100',
                step: '1',
                value: '0',
                property: 'spread',

            },
        ];
        content += `<div class="brxc__title">Box-shadow</div>`;
        arr.forEach(el => {
            content += `
            <div class="brxc__field">
                <label for="${el.id}" class="brxc__label">${el.title}</label>
                <div class="brxc__range">
                    <input id="${el.id}" type="range" min="${el.min}" max="${el.max}" step="${el.step}" value="${el.value}" class="brxc-input__range"
                        onchange="
                            ADMINBRXC.bsTemp['${el.property}'] = this.value;
                            document.querySelector('#${el.id}Value').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        " 
                        oninput="
                            ADMINBRXC.bsTemp['${el.property}'] = this.value;
                            document.querySelector('#${el.id}Value').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        "
                    />
                    <input id="${el.id}Value" type="number" min="${el.min}" max="${el.max}" step="${el.step}" value="${el.value}"
                        onchange="
                            ADMINBRXC.bsTemp['${el.property}'] = this.value;
                            document.querySelector('#${el.id}').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        " 
                        oninput="
                            ADMINBRXC.bsTemp['${el.property}'] = this.value;
                            document.querySelector('#${el.id}').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        "
                    />
                </div>
            </div>`;
        })
        content += `<div class="brxc__field">
            <label for="shadowRgb" class="brxc__label">Shadow Color</label>
            <div class="brxc__simple-color">
                <div id="shadowRgb" class="brxc-input__simple-color" data-initial="rgb(3,7,18)" data-property="shadowRgb" style="background-color:rgb(3,7,18)"></div>
                <input id="$shadowRgbValue" type="text" value="rgb(3,7,18)"
                    oninput="
                        ADMINBRXC.bsTemp['shadowRgb'] = ADMINBRXC.helpers.rgbStringToArray(this.value);
                        document.querySelector('#shadowRgb').style.backgroundColor = this.value;
                        ADMINBRXC.bsRenderCssBox();
                    "
                />
            </div>
        </div>
        <div class="brxc__field">
            <label for="shadowInset" class="brxc__label">Inset</label>
            <div id="shadowInset" class="brxc__toggle-icon" onClick="ADMINBRXC.bsTemp.inset = '${self.bsTemp.inset === '1' ? '0' : '1'}';ADMINBRXC.bsSetTempInputs();ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;"><i class="fas fa-toggle-${self.bsTemp.inset === '1' ? 'on' : 'off'}"></i></div>
        </div>`;
        content += `<a class="brxc-overlay__action-btn primary m-top-24" style="width:100%;justify-content:center;" onClick="ADMINBRXC.bsGenerateLayers();">Generate Layers</button>`;
        box.innerHTML = content;
        const simpleColors = document.querySelectorAll('.brxc-input__simple-color');
        simpleColors.forEach(el => {
            // Color Picker
            let picker = new ColorPicker(el, el.dataset.initialColor);
    
            el.addEventListener('colorChange', (event) => {
                const property = el.dataset.property;
                const color = event.detail.color.rgb;
                el.nextElementSibling.value = color.replace('rgba', 'rgb');
                self.bsTemp[property] = self.helpers.rgbStringToArray(color);
                self.bsRenderCssShadows();
                self.bsSaveSettings();

            })
        })
    },
    bsSetInputs: function(){
        const self = this;
        const box = document.querySelector('#boxShadowUI__global #boxShadowSettings');
        let content = '<div class="brxc__title">Layers</div><div class="brxc-layer-btn-wrapper">';
        self.bsSettings.layers.forEach((layer,index) => {
            content += `<div class="brxc-layer-btn${index === self.bsStates.activeLayer ? ' active': ''}" data-order="${index}" onClick="ADMINBRXC.bsSetActiveLayer(this.dataset.order)"><div class="icon"><i class="fas fa-layer-group"></i></div></<span>Layer ${index + 1}</span></div>`
        })
        content += `<div class="brxc-layer-btn" onClick="ADMINBRXC.bsAddNewLayer();"><div class="icon"><i class="fas fa-plus"></i></div></<span>Add</span></div>`;
        content += '</div>'
        box.innerHTML = content;
    },
    bsSetActiveLayer: function(order){
        const self = this;
        self.bsStates.activeLayer = parseInt(order);
        self.bsSetBoxInputs();
        self.bsSetInputs();
        self.bsLoadLayer();
    },
    bsLoadLayer: function(){
        const self = this;
        const box = document.querySelector('#boxShadowUI__child');
        const layer = self.bsSettings.layers[self.bsStates.activeLayer];
        const layerColor = `rgb(${Array.isArray(layer.rgb) ? layer.rgb.join(',') : layer.rgb})`;
        const arr = [
            {
                id: 'brxcBsVerticalDistanceChild',
                title: 'Vertical Distance',
                min: '-500',
                max: '500',
                step: '1',
                property: 'y',

            },
            {
                id: 'brxcBsHorizontalDistanceChild',
                title: 'Horizontal Distance',
                min: '-500',
                max: '500',
                step: '1',
                property: 'x',

            },
            {
                id: 'brxcBsOpacityChild',
                title: 'Opacity',
                min: '0.01',
                max: '1',
                step: '0.01',
                property: 'alpha',

            },
            {
                id: 'brxcBsBlurChild',
                title: 'Blur',
                min: '0',
                max: '100',
                step: '1',
                property: 'blur',

            },
            {
                id: 'brxcBsSpreadChild',
                title: 'Spread',
                min: '-100',
                max: '100',
                step: '1',
                property: 'spread',

            },
        ];
        let content = `
        <div class="brxc__title-wrapper">
            <div class="brxc__title">Layer ${self.bsStates.activeLayer + 1}</div>
            <div class="trash-icon" data-balloon="Delete Layer" data-balloon-pos="right" onclick="ADMINBRXC.setDeleteVariable(this,'ADMINBRXC.bsDeleteLayer()');">
                <span class="bricks-svg-wrapper">
                    <i class="ti-trash"></i>
                </span>
            </div>
        </div>`;
        arr.forEach(el => {
            content += `
            <div class="brxc__field">
                <label for="${el.id}" class="brxc__label">${el.title}</label>
                <div class="brxc__range">
                    <input id="${el.id}" type="range" min="${el.min}" max="${el.max}" step="${el.step}" value="${layer[el.property]}" class="brxc-input__range" 
                        onchange="
                            ADMINBRXC.bsSettings.layers[${self.bsStates.activeLayer}]['${el.property}'] = this.value;
                            document.querySelector('#${el.id}Value').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        " 
                        oninput="
                            ADMINBRXC.bsSettings.layers[${self.bsStates.activeLayer}]['${el.property}'] = this.value;
                            document.querySelector('#${el.id}Value').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        "
                    />
                    <input id="${el.id}Value" type="number" min="${el.min}" max="${el.max}" step="${el.step}" value="${layer[el.property]}"
                        onchange="
                            ADMINBRXC.bsSettings.layers[${self.bsStates.activeLayer}]['${el.property}'] = this.value;
                            document.querySelector('#${el.id}').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        " 
                        oninput="
                            ADMINBRXC.bsSettings.layers[${self.bsStates.activeLayer}]['${el.property}'] = this.value;
                            document.querySelector('#${el.id}').value = this.value;
                            ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;
                        "
                    />
                </div>
            </div>`;
        })
        content += `<div class="brxc__field">
            <label for="shadowRgbChild" class="brxc__label">Shadow Color</label>
            <div class="brxc__simple-color">
                <div id="shadowRgbChild" class="brxc-input__simple-color" data-initial="${layerColor}" data-property="rgb" style="background-color:${layerColor}"></div>
                <input id="$shadowRgbChildValue" type="text" value="${layerColor}"
                    oninput="
                        ADMINBRXC.bsSettings.layers[ADMINBRXC.bsStates.activeLayer][this.previousElementSibling.dataset.property] = ADMINBRXC.helpers.rgbStringToArray(this.value);
                        document.querySelector('#shadowRgbChild').style.backgroundColor = this.value;
                        ADMINBRXC.bsRenderCssShadows();
                    "
                />
            </div>
        </div>
        <div class="brxc__field">
            <label for="shadowInsetChild" class="brxc__label">Inset</label>
            <div id="shadowInsetChild" class="brxc__toggle-icon" onClick="ADMINBRXC.bsSettings.layers[${self.bsStates.activeLayer}].inset = '${layer.inset === '1' ? '0' : '1'}';ADMINBRXC.bsLoadLayer();ADMINBRXC.bsRenderCssShadows();ADMINBRXC.bsSaveSettings();;"><i class="fas fa-toggle-${layer.inset === '1' ? 'on' : 'off'}"></i></div>
        </div>`;
        box.innerHTML = content;
        const simpleColors = document.querySelectorAll('.brxc-input__simple-color');
        simpleColors.forEach(el => {
            // Color Picker
            let picker = new ColorPicker(el, el.dataset.initialColor);
    
            el.addEventListener('colorChange', (event) => {
                const property = el.dataset.property;
                const color = event.detail.color.rgb;
                el.nextElementSibling.value = color.replace('rgba', 'rgb');
                self.bsSettings.layers[self.bsStates.activeLayer][property] = self.helpers.rgbStringToArray(color);
                self.bsRenderCssShadows();
                self.bsSaveSettings();

            })
        })

    },
    bsLoadDefault: function(){
        const self = this;
        self.bsRenderCssBox();
        self.bsRenderCssShadows();
        self.bsSetBoxInputs();
        self.bsSetTempInputs();
    },
    bsGenerateLayers: function(presetsArr = false){
        const self = this;
        const layers = self.bsRenderBoxShadows(self.bsTemp);
        self.bsSettings = {
            boxColor: self.bsTemp.boxColor,
            boxBgColor: self.bsTemp.boxBgColor,
            width: self.bsTemp.width,
            height: self.bsTemp.height,
            borderRadius: self.bsTemp.borderRadius,
            layers: layers,
        };
        if(Array.isArray(presetsArr)) self.bsSettings.layers = presetsArr;
        self.bsSaveSettings();
        self.bsStates.activeLayer = 0;
        self.bsSetActiveLayer(0);

        self.bsInit();
    },
    //
    bsLoad: function(){
        const self = this;
        self.bsRenderCssBox();
        self.bsRenderCssShadows();
        self.bsSetBoxInputs();
        self.bsSetInputs();
    },
    bsSaveSettings: function(){
        const self = this;
        const target = self.helpers.createTargetWithPseudo(`${self.bsStates.selector.replaceAll('_','')}Generator`);
        const settings = self.helpers.getFinalObject()?.settings;
        settings[target] = self.bsSettings;
    },
    bsRemoveSettings: function(){
        const self = this;
        const target = self.helpers.createTargetWithPseudo(`${self.bsStates.selector.replaceAll('_','')}Generator`);
        const settings = self.helpers.getFinalObject()?.settings;
        delete settings[target];
        self.vueState.rerenderControls = Date.now();
        self.vueGlobalProp.$_showMessage('Box-shadow settings correctly removed!');

    },
    bsApplyPresets(targetNode){
        const self = this;
        const boxShadow = targetNode.dataset.value;
        const target = self.helpers.createTargetWithPseudo(self.bsStates.selector);
        const settings = self.helpers.getFinalObject()?.settings;
        settings[target] = {color:{raw: boxShadow}};

        self.vueState.rerenderControls = Date.now();
        self.vueGlobalProp.$_showMessage('Box-shadow correctly applied!');

    },
    bsApply: function(){
        const self = this;
        if(typeof self.bsSettings === "undefined") return self.vueGlobalProp.$_showMessage('Abort: create the layers first.');
        const target = self.helpers.createTargetWithPseudo(self.bsStates.selector);
        const settings = self.helpers.getFinalObject()?.settings;

        const cssShadows = self.bsSettings.layers.map(
            ({ x, y, blur, spread, rgb, alpha, inset }) =>
            `${inset === '1' ? 'inset ' : ''}${x}px ${y}px ${blur}px ${spread}px rgba(${Array.isArray(rgb) ? rgb.join(',') : rgb}, ${alpha})`
        );
        const styles = cssShadows.join(",\n  ");
        settings[target] = {color:{raw: styles}};

        self.vueState.rerenderControls = Date.now();
        self.vueGlobalProp.$_showMessage('Box-shadow correctly applied!');
    },
    bsLoadBoxValues: function(){
         const self = this;
         const elementObj = self.helpers.getFinalObject(true);
         const node = FRAMEBRXC.vueGlobalProp.$_getElementNode(elementObj);
         function getStyle(el, prop){
            return window.getComputedStyle(el).getPropertyValue(prop);
         }

         function getInheritedBackgroundColor(el) {
            var defaultStyle = getDefaultBackground()
            var backgroundColor = window.getComputedStyle(el).backgroundColor
            if (backgroundColor != defaultStyle) return backgroundColor
            if (!el.parentElement) return defaultStyle
            return getInheritedBackgroundColor(el.parentElement)
        }
        function getDefaultBackground() {
            var div = document.createElement("div")
            document.head.appendChild(div)
            var bg = window.getComputedStyle(div).backgroundColor
            document.head.removeChild(div)
            return bg
        }
        const width = node.getBoundingClientRect().width > 0 ? node.getBoundingClientRect().width : 400;
        const height = node.getBoundingClientRect().height > 0 ? node.getBoundingClientRect().height : 400;
        const ratio = width > height ? height / width : width / height;
        if(width > height){
            self.bsTemp.width = 400;
            self.bsTemp.height = Math.floor(self.bsTemp.width * ratio)
        } else {
            self.bsTemp.height = 400;
            self.bsTemp.width = Math.floor(self.bsTemp.height * ratio);
        }
        self.bsTemp.borderRadius = parseInt(getStyle(node, 'border-radius').replace('px',''));
        self.bsTemp.boxColor = getStyle(node, 'background-color');
        self.bsTemp.boxBgColor = getInheritedBackgroundColor(node.parentElement);
    },
    bsAddNewLayer: function(){
        const self = this;
        const length = self.bsSettings.layers.length;
        self.bsSettings.layers.push(JSON.parse(JSON.stringify(self.bsSettings.layers[length - 1])));
        self.bsStates.activeLayer = length;
        self.bsRenderCssShadows();
        self.bsSaveSettings();
        self.bsLoadLayer();
        self.bsSetInputs();
    },
    bsSetDeleteLayer: function(){
        const self = this;
        self.bsSettings.layers.splice(self.bsStates.activeLayer, 1);
        self.bsStates.activeLayer = self.bsSettings.layers.length - 1;
        self.bsRenderCssShadows();
        self.bsSaveSettings();
        self.bsLoadLayer();
        self.bsSetInputs();
    },
    bsDeleteLayer: function(){
        const self = this;
        self.bsSettings.layers.splice(self.bsStates.activeLayer, 1);
        self.bsStates.activeLayer = self.bsSettings.layers.length - 1;
        self.bsRenderCssShadows();
        self.bsSaveSettings();
        self.bsLoadLayer();
        self.bsSetInputs();
    },
    bsImportLayersFromPresets: function(target){
        const self = this;
        self.bsGenerateLayers(JSON.parse(target.dataset.obj));
        document.querySelector('#box-shadow-ui-generator').click();
    },
    bsInit: function(selector = false){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        if(selector) self.bsStates.selector = selector
        // Get the target Key
        const target = self.helpers.createTargetWithPseudo(`${self.bsStates.selector.replaceAll('_', '')}Generator`);
        const settings = self.helpers.getFinalObject()?.settings;

        // Conditional Load
        if(typeof settings[target] === "undefined"){
            self.bsSettings = undefined;
            self.bsLoadBoxValues();
            self.bsLoadDefault();
        } else {
            self.bsStates.activeLayer = 0;
            self.bsSettings = settings[target];
            self.bsLoad();
        }
    },
    stateInteractions: null,
    stateConditions: null,
    copyInteractions: function(key){
        const self = this;
        let settings;
        const finalObj = self.helpers.getFinalObject()?.settings;
        const elementObj = self.helpers.getFinalObject(true)?.settings;
        if(self.helpers.isClassActive() && key === "_interactions") {
            settings = finalObj[key]
        } else {
            settings = elementObj[key];
        } 
        if(key === "_interactions"){
            self.stateInteractions = JSON.stringify(settings);
        } else {
            self.stateConditions = JSON.stringify(settings);
        }
        const message = key === "_interactions" ? "Interactions" : "Conditions";
        self.vueGlobalProp.$_showMessage(`${message} successfully copied!`);
        self.vueState.rerenderControls = Date.now();
    },
    pasteInteractions: function(key){
        const self = this;
        const arr = key === "_interactions" ? JSON.parse(self.stateInteractions) : JSON.parse(self.stateConditions);
        const elementObj = key === "_interactions" ? self.helpers.getFinalObject() : self.helpers.getFinalObject(true);

        if(!elementObj.settings.hasOwnProperty(key)) elementObj.settings[key] = [];
        arr.forEach(obj => {
            if(key === "_conditions"){
                obj.forEach(newObj => {
                    newObj.id = self.vueGlobalProp.$_generateId();
                })
            } else if(key === "_interactions"){
                obj.id = self.vueGlobalProp.$_generateId();
            }
            elementObj.settings[key].push(obj);
        })
        

        const message = key === "_interactions" ? "Interactions" : "Conditions";
        self.vueState.rerenderControls = Date.now();
        self.vueGlobalProp.$_showMessage(`${message} successfully pasted!`);
    },
    setCopyConditions: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.showConditions !== true ) return;
        
        let copyIcon = document.querySelector('.brxc-copy-conditions');
        if (copyIcon) copyIcon.remove();
        let pasteIcon = document.querySelector('.brxc-paste-conditions');
        if (pasteIcon) pasteIcon.remove();

        const actions = document.querySelector('#bricks-panel div[data-control="conditions"] .title-wrapper .actions');
        if(!actions) return;

        const settings = self.helpers.getFinalObject(true)?.settings;
    

        // Copy
        copyIcon = actions.querySelector('.brxc-copy-conditions');
        if (!copyIcon && settings && settings.hasOwnProperty('_conditions')) {
            self.addIconToFields(
                'div',
                'brxc-copy-conditions',
                false,
                'Copy Conditions',
                'top-right',
                'ADMINBRXC.copyInteractions("_conditions");',
                false,
                '<span class="bricks-svg-wrapper"><i class="fas fa-clipboard"></i></span>',
                actions,
                'child'
            );
        }

        // Paste
        pasteIcon = actions.querySelector('.brxc-paste-conditions');
        if (!pasteIcon && self.stateConditions !== null) {
            self.addIconToFields(
                'div',
                'brxc-paste-conditions',
                false,
                'Import Conditions',
                'top-right',
                'ADMINBRXC.pasteInteractions("_conditions");',
                false,
                '<span class="bricks-svg-wrapper"><i class="fas fa-file-import"></i></span>',
                actions,
                'child'
            );
        }
    },
    setCopyInteractions: function(){
        const self = this;
        
        if(!self.helpers.isElementActive() || self.vueState.showInteractions !== true ) return;
        
        let copyIcon = document.querySelector('.brxc-copy-interactions');
        if (copyIcon) copyIcon.remove();
        let pasteIcon = document.querySelector('.brxc-paste-interactions');
        if (pasteIcon) pasteIcon.remove();

        
        const actions = document.querySelector('#bricks-panel div[data-control="interactions"] .title-wrapper .actions');
        if(!actions) return;

        const settings = self.helpers.getFinalObject()?.settings;

        // Copy
        copyIcon = actions.querySelector('.brxc-copy-interactions');
        if (!copyIcon && settings && settings.hasOwnProperty('_interactions')) {
            self.addIconToFields(
                'div',
                'brxc-copy-interactions',
                false,
                'Copy Interactions',
                'top-right',
                'ADMINBRXC.copyInteractions("_interactions");',
                false,
                '<span class="bricks-svg-wrapper"><i class="fas fa-clipboard"></i></span>',
                actions,
                'child'
            );
        }

        // Paste
        pasteIcon = actions.querySelector('.brxc-paste-interactions');
        if (!pasteIcon && self.stateInteractions !== null) {
            self.addIconToFields(
                'div',
                'brxc-paste-interactions',
                false,
                'Import Interactions',
                'top-right',
                'ADMINBRXC.pasteInteractions("_interactions");',
                false,
                '<span class="bricks-svg-wrapper"><i class="fas fa-file-import"></i></span>',
                actions,
                'child'
            );
        }
    },
    basicTextStates:{
        tag: 'span',
        class: "false",
        classTxt: "",
        style: "false",
        styleTxt: "",
        url: "false",
        urlTxt: "",
    },
    setbasicTextOptions: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.activePanelTab !== "content" || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;

        const elementObj = self.helpers.getFinalObject(true);
        if(!['text-basic','heading'].includes(elementObj.name)) return
        
        setTimeout(() => {
            const textarea = document.querySelector('#bricks-panel .controls [data-control=textarea]');
            if(!textarea) return;

            if(textarea.parentElement.querySelector('#brxc-text-basic-options')) return;
            const wrapper  = document.createElement("DIV");
            wrapper.id = "brxc-text-basic-options";
            textarea.parentElement.insertBefore(wrapper, textarea);
            self.basicTextOptions(wrapper);

        }, 50)
    },
    basicTextOptions: function(wrapper){
        const self = this;
        let content = "";
        const options = ['span','strong','a','em','mark','abbr','p','custom'];
        content += `
        <select value name="html-tag-wrapper" id="brxc-html-tag-wrapper" onchange="ADMINBRXC.basicTextStates.tag = this.value;ADMINBRXC.basicTextOptions(this.parentElement)">`
        options.forEach(option => {
            content += `<option value="${option}"${self.basicTextStates.tag === option ? ' selected' : ''}>${option}</option>`;
        })
        content += `</select>`;
        if(self.basicTextStates.tag === "custom"){
            content += `<input type="text" onblur="ADMINBRXC.basicTextStates.tag = this.value">`
        }
        // Url
        if(self.basicTextStates.tag === "a"){
            content += `<div class="${self.basicTextStates.url === "true" ? 'active' : ''}" data-balloon="${self.basicTextStates.url === "true" ? 'Remove' : 'Add'} URL tag" data-balloon-pos="top" onclick='ADMINBRXC.basicTextStates.url = "${self.basicTextStates.url === "true" ? "false" : "true"}";ADMINBRXC.basicTextOptions(this.parentElement)'>
                <span class="bricks-svg-wrapper">
                    <i class="fas fa-link"></i>
                </span>
            </div>`
        }

        content += `<div class="${self.basicTextStates.class === "true" ? 'active' : ''}" data-balloon="${self.basicTextStates.class === "true" ? 'Remove' : 'Add'} Class tag" data-balloon-pos="top" onclick='ADMINBRXC.basicTextStates.class = "${self.basicTextStates.class === "true" ? "false" : "true"}";ADMINBRXC.basicTextOptions(this.parentElement)'>
            <span class="bricks-svg-wrapper">
                <i class="fab fa-css3-alt"></i>
            </span>
        </div>
        <div class="${self.basicTextStates.style === "true" ? 'active' : ''}" data-balloon="${self.basicTextStates.style === "true" ? 'Remove' : 'Add'} Style tag" data-balloon-pos="top" onclick='ADMINBRXC.basicTextStates.style = "${self.basicTextStates.style === "true" ? "false" : "true"}";ADMINBRXC.basicTextOptions(this.parentElement)'>
            <span class="bricks-svg-wrapper">
                <i class="fas fa-broom"></i>
            </span>
        </div>
        <a class="" onclick="ADMINBRXC.unwrapSelectedContent(this.parentElement.parentElement.querySelector('textarea'))">Unwrap</a>
        <a class="" onclick="ADMINBRXC.wrapSelectedContent(this.parentElement.parentElement.querySelector('textarea'))">Wrap</a>
        `;
        if(Object.values(self.basicTextStates).some(value => value === "true")){
            content += `<div id="brxc-text-basic-options-extra">`
            if(self.basicTextStates.tag === "a" && self.basicTextStates.url === "true"){
                content += `<div class="brxc-field-wrapper">
                    <div class="icon-wrapper">
                        <span class="bricks-svg-wrapper">
                            <i class="fas fa-link"></i>
                        </span>
                    </div>
                    <input type="text" oninput="ADMINBRXC.basicTextStates.urlTxt = this.value" value="${self.basicTextStates.urlTxt}">
                </div>`
            }
            if(self.basicTextStates.class === "true"){
                content += `<div class="brxc-field-wrapper">
                    <div class="icon-wrapper">
                        <span class="bricks-svg-wrapper">
                            <i class="fab fa-css3-alt"></i>
                        </span>
                    </div>
                    <input type="text" id="brxcBasicTextClass" oninput="ADMINBRXC.basicTextStates.classTxt = this.value" value="${self.basicTextStates.classTxt}">
                </div>`
            }
            if(self.basicTextStates.style === "true"){
                content += `<div class="brxc-field-wrapper">
                    <div class="icon-wrapper">
                        <span class="bricks-svg-wrapper">
                            <i class="fas fa-broom"></i>
                        </span>
                    </div>
                    <input type="text" oninput="ADMINBRXC.basicTextStates.styleTxt = this.value" value="${self.basicTextStates.styleTxt}">
                </div>`
            }


            content += `</div>`;
        }
        wrapper.innerHTML = content;
        const classInput = wrapper.querySelector('#brxcBasicTextClass');
        if(!classInput) return;

        classInput.addEventListener('input', () => {
            self.autocomplete(classInput, self.vueState.globalClasses.map(el => el.name), false);
        })


    },
    wrapSelectedContent: function(textarea){
        const self = this;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selectedText = textarea.value.substring(start, end).trim();
        if(selectedText === '') return self.vueGlobalProp.$_showMessage('Abort: select the content to wrap first.')

        const beforeText = textarea.value.substring(0, start);
        const afterText = textarea.value.substring(end);
        const newText = `${beforeText}<${self.basicTextStates.tag}${self.basicTextStates.tag === "abbr" ? ` title=""` : ''}${self.basicTextStates.tag === "a" && self.basicTextStates.url === "true" ? ` href="${self.basicTextStates.urlTxt}" target="_blank"` : ''}${self.basicTextStates.class === "true" ? ` class="${self.basicTextStates.classTxt}"` : ''}${self.basicTextStates.style === "true" ? ` style="${self.basicTextStates.styleTxt}"` : ''}>${selectedText}</${self.basicTextStates.tag}>${afterText}`
        textarea.value = newText;
        const evt = new Event('input');
        textarea.dispatchEvent(evt);
    },
    unwrapSelectedContent: function(textarea){
        const self = this;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selectedText = textarea.value.substring(start, end).trim();
        if(selectedText === '') return self.vueGlobalProp.$_showMessage('Abort: select the content to wrap first.')

        const beforeText = textarea.value.substring(0, start);
        const afterText = textarea.value.substring(end);
        const newText = `${beforeText}${selectedText.replaceAll(/<[^>]*>/g, '')}${afterText}`
        textarea.value = newText;
        const evt = new Event('input');
        textarea.dispatchEvent(evt);
    },
    queryManagerStates: {
        active: null,
        activeCategory: 'All',
        search: '',
    },
    queryListState: {
        show: false,
        search: '',
    },
    setQueryList: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        function openPopup() {
            window.addEventListener('click', windowClickListener);
            x.document.addEventListener('click', windowClickListener);
        }
        
        function closePopup() {
            self.queryListState.show = false;
            window.removeEventListener('click', windowClickListener);
            x.document.removeEventListener('click', windowClickListener);
            self.setQueryList();

        }
        
        function windowClickListener(event) {
            const popup = document.querySelector('.brxc-global-query-loops');
            if (popup && !popup.contains(event.target)) {
                closePopup();
            }
        }

        setTimeout(()=> {
            const control = document.querySelector('[data-controlkey="query"] [controlkey="query"]');
            if(!control) return;

            const icon = control.querySelector('.brxc-global-query-loops');
            if (icon) icon.remove();

            const elementObj = self.helpers.getFinalObject(true);

            function isActive(){
                if(elementObj.settings.hasOwnProperty('query') 
                    && elementObj.settings.query.hasOwnProperty('objectType')
                    && typeof Array.from(self.globalSettings.generalCats.queryManager).find(el => el && el.id === elementObj.settings.query.objectType) !== "undefined") return true;
                return false;
            }

            let content = self.queryListContent();
            const classes = isActive() ? 'brxc-global-query-loops active' : 'brxc-global-query-loops';

            self.addIconToFields(
                'div',
                classes,
                false,
                'Global Query Loops',
                'top-right',
                '',
                false,
                content,
                control,
                'child'
            );

            openPopup();
                

        }, 5);
    },
    queryListContent: function(){
        const self = this;
        let content = '<div class="icon" onclick="ADMINBRXC.queryListState.show = true;ADMINBRXC.setQueryList();"><span class="bricks-svg-wrapper"><i class="fas fa-globe"></i></span></div>';
            if(self.queryListState.show === true){
                content += `<div class="bricks-control-popup bottom">
                                <div class="input-wrapper">
                                    <input type="text" autocomplete="off" spellcheck="false" placeholder="Search for a query loop ..." oninput="ADMINBRXC.queryListState.search = this.value;ADMINBRXC.updateQueryListLi();">
                                 </div>
                                 <div class="css-classes">
                                    <h6 class="title"><span>Global Query Loops</span></h6>
                                    <ul id="brxcQueryListLiCanvas">`;
                content += self.queryListLi();
                content +=         `</ul>
                                </div>
                            </div>`;
            }
        return content;
    },
    queryListLi: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        let content = '';
        function isActive(id){
            if(elementObj.settings.hasOwnProperty('query') 
                && elementObj.settings.query.hasOwnProperty('objectType')
                && elementObj.settings.query.objectType === id) return true;
            return false;
        }
        self.globalSettings.generalCats.queryManager.forEach(el => {
            content += `<li data-id="${el.id}" ${isActive(el.id) ? 'class="active" ': ''}onclick="ADMINBRXC.selectQueryList(this.dataset.id)"><span class="name">${el.title}</span></li>`
        })

        return content;
    },
    updateQueryListLi: function(){
        const self = this;
        const items = document.querySelectorAll('#brxcQueryListLiCanvas li');
        items.forEach(el => {
            self.queryListState.search === "" || el.textContent.includes(self.queryListState.search) ? el.removeAttribute('style') : el.style.display = "none";
        })
    },
    selectQueryList: function(id){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        self.queryListState.show = false;
        elementObj.settings['query'] = {objectType: id};
        self.vueState.rerenderControls = Date.now();
    },
    setGenerateGlobalQuery: function(){
        const self = this;
        const popup = document.querySelector('[data-controlkey="query"] [controlkey="query"] .bricks-control-popup');
        if(!popup || !self.helpers.isElementActive()) return;

        const elementObj = self.helpers.getFinalObject(true)
        if(!elementObj.settings.hasOwnProperty('query')) return removeBtn();

        function removeBtn(){
            const btn = popup.querySelector('.brxc-generate-global-query');
            if (btn) btn.remove();
        }

        setTimeout(()=> {
            removeBtn()

            if(elementObj.settings.query.hasOwnProperty('objectType')
                && !( elementObj.settings.query.objectType === "post"
                    || elementObj.settings.query.objectType === "term"
                    || elementObj.settings.query.objectType === "user")
            ) return;

            content = `<div class="control control-separator">
                            <div class="control-inner">
                                <label for="infinite_scroll_separator" data-balloon-break="">
                                    <span>Global Query Loop</span>
                                </label>
                                <div data-control="separator" type="separator"></div>
                            </div>
                        </div>
                        <a class="brxc-overlay__action-btn primary" style="width:100%;text-align:center;justify-content:center;margin-top:16px;" onclick="ADMINBRXC.generateGlobalQuery();">Generate Global Query Loop</a>`

            self.addIconToFields(
                'div',
                'brxc-generate-global-query',
                false,
                '',
                '',
                '',
                false,
                content,
                popup,
                'child'
            );
                

        }, 5);
    },
    generateGlobalQuery: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        const id = self.vueGlobalProp.$_generateId();
        self.getQueryVar(elementObj.settings, elementObj.id)
        .then(args => {
            // Check if args is populated before pushing the object
            if (args && args.trim() !== '') {
                const title = 'New Query Loop'
                self.globalSettings.generalCats.queryManager.push({
                    id: id,
                    title: title,
                    description: '',
                    category: '',
                    args: self.helpers.convertToPhpArrowFunction(args),
                });
                self.queryManagerStates.active = id;
                bricksData.controlOptions.queryTypes[id] = title;
                elementObj.settings['query'] = {objectType: id};
                self.vueState.rerenderControls = Date.now();
                self.queryManagerInit()
                self.openModal(false, "#brxcQueryManagerOverlay");
            } else {
                // Handle the case where args is not populated
                console.log('Args is not populated. Object not pushed.');
            }

        })
        .catch(error => {
            console.error('Error fetching args:', error);

            // Handle the error if needed
        });
    },
    queryManagerInit: function(){
        const self = this;
        if(self.queryManagerStates.active === null){
            if(self.globalSettings.generalCats.queryManager[0]) self.queryManagerStates.active = self.globalSettings.generalCats.queryManager[0].id;
        }
        self.queryManagerCat();
        self.queryManagerList();
        self.queryManagerPanel();
    },
    queryManagerCat: function(){
        const self = this;
        const listWrapper = document.querySelector('#brxcQueryCatListCanvas');
        if(!listWrapper || !Array.isArray(self.globalSettings.generalCats.queryManagerCats)) return;
        let cats = '<ul>';
        let categoryFound;
        let count;

        function isActive (cat) {
            if(self.helpers.getQueryCategoryIdByName(cat) === self.queryManagerStates.activeCategory) return true;
            return false;
        }

        // All
        count = self.globalSettings.generalCats.queryManager.length;
        cats += `<li class="${self.queryManagerStates.activeCategory === "All" ? 'active' : ''}"${self.queryManagerStates.activeCategory === "All" ? ' data-active="true"' : ''} data-id="All" data-balloon="All" data-balloon-pos="right" onClick="ADMINBRXC.queryManagerFilterCat(event)"><input type="text" value="All" readonly/><span class="count">${count}</span></li>`
        
        // Uncategorized
        count = Array.from(self.globalSettings.generalCats.queryManager).filter(el => el && (!el.category || el.category === "")).length;
        cats += `<li class="${self.queryManagerStates.activeCategory === "Uncategorized" ? 'active' : ''}"${self.queryManagerStates.activeCategory === "Uncategorized" ? ' data-active="true"' : ''} data-id="Uncategorized" data-balloon="Uncategorized" data-balloon-pos="right" onClick="ADMINBRXC.queryManagerFilterCat(event)"><input type="text" value="Uncategorized" readonly/><span class="count">${count}</span></li>`

        // Categories
        const sortedCats = Array.from(self.globalSettings.generalCats.queryManagerCats).filter(el => el && el.name).map(el => el && el.name).sort((a, b) => a.localeCompare(b, undefined, {sensitivity: 'base'}));
        sortedCats.forEach(cat => {
            categoryFound = self.helpers.getQueryCategoryObjByName(cat)
            count = Array.from(self.globalSettings.generalCats.queryManager).filter(el => el && el.hasOwnProperty('category') && categoryFound && categoryFound.id === el.category).length;
            cats += `<li class="${isActive(cat) ? 'active' : ''}"${isActive(cat) ? ' data-active="true"' : ''} data-id="${categoryFound.id}" data-balloon="${cat}" data-balloon-pos="right" ondragenter="this.classList.add('dragged')" ondragleave="this.classList.remove('dragged')" ondrop="event.preventDefault();ADMINBRXC.onDropCatList(this);" ondragover="event.preventDefault();" onClick="ADMINBRXC.queryManagerFilterCat(event)"><input type="text" data-initial="${cat}" value="${cat}"${categoryFound.id !== self.queryManagerStates.activeCategory ? ' readonly' : ''}/>${categoryFound.id === self.queryManagerStates.activeCategory ? `<div class="deleteCat" onClick="event.stopPropagation();ADMINBRXC.deleteQueryCategory('${self.queryManagerStates.activeCategory}')" data-balloon="Delete category" data-balloon-pos="top-right"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>` : `<span class="count">${count}</span>`}</li>`
            
        })

        cats += '</ul><input type="text" id="addNewQueryCat" placeholder="+ New category" onkeyup="ADMINBRXC.addNewQueryCategory(event);" />';
        
        listWrapper.innerHTML = cats;

        // rename cat
        const input = listWrapper.querySelector('li.active input');
        if(input){
            input.addEventListener('keyup', (event) => {
                if(event.key !== "Enter") return;
                if(event.target.value === event.target.dataset.initial) return self.queryManagerCat();
                if(self.globalSettings.generalCats.queryManagerCats.includes(event.target.value)) return self.vueGlobalProp.$_showMessage(`ABORT: category "${event.target.value}" already exists`);
                const activeObj = self.helpers.getQueryCategoryObjById(self.queryManagerStates.activeCategory)
                activeObj.name = event.target.value;
                self.vueGlobalProp.$_showMessage(`Category correctly renamed to ${event.target.value}`)
                self.queryManagerCat();
                self.queryManagerPanel();
            })
        }
        
    },
    queryManagerFilterCat: function(event){
        const self = this;
        target = (event.target.dataset.id) ? event.target : event.target.parentElement;
        if(target.dataset.active === 'true') return;
        self.queryManagerStates.activeCategory = target.dataset.id;
        self.queryManagerCat();
        self.queryManagerList();
    },
    addNewQueryCategory: function(event){
        const self = this;

        if(event.key !== "Enter") return;

        const values = event.target.value.split(' ');
        if(values.length < 1) return;

        let hasChanges = false;
        let newId;

        values.forEach(name => {
            if(Array.from(self.globalSettings.generalCats.queryManagerCats).map(obj => obj && obj.name).includes(name)) {
                return self.vueGlobalProp.$_showMessage('ABORT: category already exists');
            } else {
                hasChanges = true;
                newId = self.vueGlobalProp.$_generateId();
                self.globalSettings.generalCats.queryManagerCats.push({
                    id: newId,
                    name: name,
                })

            }
        })
        if(hasChanges === true) {
            self.queryManagerStates.activeCategory = newId;
            self.queryManagerCat();
        };  
    },
    deleteQueryCategory: function(id){
        const self = this;
        const obj = self.helpers.getQueryCategoryObjById(id);
        if(!obj) return self.vueGlobalProp.$_showMessage('Abort: error finding the category');
        const catName = obj.name;
        const order = self.globalSettings.generalCats.queryManagerCats.indexOf(obj);
        self.globalSettings.generalCats.queryManagerCats.splice(order, 1);
        const loops = Array.from(self.globalSettings.generalCats.queryManager).filter(el => el && el.category === id);
        if(loops.length > 0){
            loops.forEach(el => {
                el.category = '';
            })
        }
        self.queryManagerStates.activeCategory = "All";
        self.vueGlobalProp.$_showMessage(`Category "${catName}" has been successfully deleted!`);
        self.queryManagerCat();
        self.queryManagerList();
        self.queryManagerPanel();

    },
    queryManagerList: function(){
        const self = this;
        const list = document.querySelector('#queryManagerUI__list');
        let arr = self.globalSettings.generalCats.queryManager;

        // Search
        if(self.queryManagerStates.search !== ''){
            arr = Array.from(arr).filter(el => el && el.title.includes(self.queryManagerStates.search))
        }

        // Uncategorized
        if(self.queryManagerStates.activeCategory === 'Uncategorized') {
            arr = Array.from(arr).filter(el => el && !el.category || el.category === '');
        // Category
        } else if(self.queryManagerStates.activeCategory !== 'All') {
            arr = Array.from(arr).filter(el => el && el.category === self.queryManagerStates.activeCategory);
        }

        // Content
        let content = '';
        arr.forEach(obj => {
            content += `<li class="${self.queryManagerStates.active === obj.id ? ' active' : ''}" data-id="${obj.id}" >
                            <span>${obj.title}</span>
                            <div class="actions">
                                <div class="duplicate" data-id="${obj.id}" data-balloon="Duplicate" data-balloon-pos="bottom-right" onclick="event.stopPropagation();ADMINBRXC.duplicateQueryLoop(this.dataset.id)"><i class="fas fas fa-clone"></i></div>
                                <div class="delete" data-id="${obj.id}" data-balloon="Delete" data-balloon-pos="bottom-right" onclick="event.stopPropagation();ADMINBRXC.setDeleteVariable(this, 'ADMINBRXC.deleteQueryLoop(this.dataset.id);')"><i class="ti-trash"></i></div>
                            </div> 
                        </li>`
        });
        //content += `<div class="brxc-class-manager__footer"><input type="text" id="addNewQueryLoop" placeholder="Add a new Query Loop" onkeyup="ADMINBRXC.addNewQueryLoop(event);"></div>`
        list.innerHTML = content;
        const li = list.querySelectorAll('li');
        if(li.length > 0){
            li.forEach(el => {
                el.addEventListener('click', () => {
                    self.queryManagerStates.active = el.dataset.id;
                    self.queryManagerInit();
                })
            })
        }
    },
    queryManagerPanel: function(){
        const self = this;
        const panel = document.querySelector('#queryManagerUI__panel');

        const activeObj = self.globalSettings.generalCats.queryManager.find(el => el.id ===self.queryManagerStates.active);
        if (!activeObj) return;
        let content = '';
        content += `<div class="brxc-query-manager__title-wrapper">
                        <div>
                            <label for="brxcQueryTitle" class="brxc-input__label has-tooltip"><span>Name</span><div data-balloon="To rename the current Query, just type the new name inside this input" data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            <input type="text" id="brxcQueryTitle" placeholder="" value="${activeObj.title}" />
                        </div>
                        <div>
                            <label for="brxcQueryCategory" class="brxc-input__label has-tooltip"><span>Category</span><div data-balloon="To assign the query to a category, just type the new category name inside the input and press ENTER" data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            <input type="text" id="brxcQueryCategory" placeholder="" value="${self.helpers.getQueryCategoryNameById(activeObj.category) ? self.helpers.getQueryCategoryNameById(activeObj.category) : ''}" />
                        </div>
                    </div>`;
        content += `<div>
                        <label class="brxc-input__label has-tooltip">
                            <span>Description</span>
                            <div data-balloon="Add here any text that will help you to quickly describe what this Query does" data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                        </label>
                        <textarea class="description">${activeObj.description}</textarea>
                    </div>`;
        content += `<div class="codemirror-wrapper">
                        <label class="brxc-input__label has-tooltip">
                            <span>Query vars</span>
                            <div data-balloon="Add here the query vars of the Query (in a correct Array). " data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                        </label>
                        <textarea class="codemirror">${activeObj.args}</textarea>
                    </div>`;
        panel.innerHTML = content;

        const title = panel.querySelector('#brxcQueryTitle');
        if (title){
            title.addEventListener('input', () => {
                activeObj.title = title.value;
                bricksData.controlOptions.queryTypes[activeObj.id] = title.value;
                self.queryManagerList();
            })
        }
        const category = panel.querySelector('#brxcQueryCategory');

        if (category){
            category.addEventListener('keydown', (e) => {
                self.autocomplete(category, self.globalSettings.generalCats.queryManagerCats.map(el => el && el.name), false);
                if(e.key !== "Enter") return;
                const maybeCat = Array.from(self.globalSettings.generalCats.queryManagerCats).find(el => el && el.name === category.value);
                if(maybeCat){
                    activeObj.category = maybeCat.id;
                    self.queryManagerStates.activeCategory = maybeCat.id;
                } else {
                    const newId = self.vueGlobalProp.$_generateId();
                    self.globalSettings.generalCats.queryManagerCats.push({
                        id: newId,
                        name: category.value,
                    })
                    activeObj.category = newId;
                    self.queryManagerStates.activeCategory = newId;
                    self.vueGlobalProp.$_showMessage(`New Category "${category.value}" has been created!`)
                }

                self.queryManagerCat();
                self.queryManagerList();
            })
        }
        const textarea = panel.querySelector('textarea.codemirror');
        if (textarea){
            const options = self.codeMirrorOptions(textarea);
            options.mode = "javascript";
            options.styleActiveLine = true;
            options.autoCloseBrackets = true;
            options.matchBrackets = true;
            options.selfContain = true;
            options.autofocus = true;
            options.search = { bottom: false };
            const MyCM = CodeMirror.fromTextArea(textarea, options);
            MyCM.on("change", function (cm) {
                activeObj.args = cm.getValue();
            });
        }
        const description = panel.querySelector('textarea.description');
        if (description){
            description.addEventListener('change', () => {
                activeObj.description = description.value;
            })
        }
    },
    resetQueryFilter: function(btn){
        const self = this;
        btn.previousElementSibling.previousElementSibling.value = '';
        self.queryManagerStates.search = '';
        self.queryManagerList();
    },
    addNewQueryLoop: function(event){
        const title = event.target.value;
        if(title === "" || event.key !== "Enter") return;
        const self = this;
        const id = self.vueGlobalProp.$_generateId()
        self.globalSettings.generalCats.queryManager.push({
            id: id,
            title: title,
            description: '',
            args: '',
            category: '',
        })
        bricksData.controlOptions.queryTypes[id] = title;
        self.queryManagerStates.active = id;
        event.target.value = '';
        self.queryManagerInit();
        self.vueGlobalProp.$_showMessage(`Query Loop "${title}" has been correctly created!`);
    },
    duplicateQueryLoop: function(id){
        const self = this;
        const activeObj = self.globalSettings.generalCats.queryManager.find(el => el.id === id);
        const newId = self.vueGlobalProp.$_generateId()
        self.globalSettings.generalCats.queryManager.push({
            ...activeObj, 
            id: newId, 
            title: `${activeObj.title} (Copy)`,
        })
        bricksData.controlOptions.queryTypes[newId] = `${activeObj.title} (Copy)`;
        self.queryManagerStates.active = id;
        self.queryManagerInit();
        self.vueGlobalProp.$_showMessage(`Query Loop "${`${activeObj.title} (Copy)`}" has been correctly duplicated!`);
    },
    deleteQueryLoop: function(id){
        const self = this;
        const activeObj = self.globalSettings.generalCats.queryManager.find(el => el.id === id);
        if(self.queryManagerStates.active === activeObj.id) self.queryManagerStates.active = null;
        self.globalSettings.generalCats.queryManager.splice(self.globalSettings.generalCats.queryManager.indexOf(activeObj), 1);
        delete bricksData.controlOptions.queryTypes[activeObj.id];
        self.queryManagerInit();
        self.vueGlobalProp.$_showMessage(`Query Loop "${`${activeObj.title}`}" has been correctly deleted!`);
    },
    getQueryVar: function (settings, element_id) {
        const self = this;
    
        // Return a Promise that resolves with the response data or rejects with an error
        return new Promise((resolve, reject) => {
            jQuery.ajax({
                url: openai_ajax_req.ajax_url,
                data: {
                    action: 'get_var_query_ajax_function',
                    nonce: openai_ajax_req.nonce,
                    settings: settings,
                    element_id: element_id,
                },
                method: "POST",
                success: function (response) {
                    // Resolve the Promise with the response data
                    resolve(JSON.stringify(response.data));
                },
                error: function (data) {
                    // Reject the Promise with an error
                    reject('Something went wrong.');
                }
            });
        });
    },
    saveQueryManager: function(){
        const self = this;
        const obj = self.globalSettings.generalCats.queryManager || [];
        const obj2 = self.globalSettings.generalCats.queryManagerCats || [];
        jQuery.ajax({
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'save_query_manager_ajax_function',
                nonce: openai_ajax_req.nonce,
                query_manager: obj,
                query_manager_cats: obj2,
            },
            method: "POST",
            success: function(data) {
                self.vueGlobalProp.$_showMessage('Query Loops settings saved successfully!')
            },
            error: function(data) {
                self.vueGlobalProp.$_showMessage('Something went wrong - Query options not saved.')
            }
        });
    },
    // Prompt
    promptManagerStates: {
        active: null,
        activeCategory: 'css',
        search: '',
        categories: ['css', 'content']
    },
    promptManagerInit: function(){
        const self = this;
        if(self.promptManagerStates.active === null){
            if(brxcPromptManager && brxcPromptManager.length >0) self.promptManagerStates.active = brxcPromptManager[0].id;
        }
        self.promptManagerCat();
        self.promptManagerList();
        self.promptManagerPanel();
    },
    promptManagerCat: function(){
        const self = this;
        const listWrapper = document.querySelector('#brxcPromptCatListCanvas');
        if(!listWrapper || !Array.isArray(self.promptManagerStates.categories)) return;
        let cats = '<ul>';
        let categoryFound;
        let count;

        function isActive (cat) {
            if(cat === self.promptManagerStates.activeCategory) return true;
            return false;
        }

        // Categories
        self.promptManagerStates.categories.forEach(cat => {
            count = Array.from(brxcPromptManager).filter(el => el && el.hasOwnProperty('category') && cat === el.category).length;
            cats += `<li class="${isActive(cat) ? 'active' : ''}"${isActive(cat) ? ' data-active="true"' : ''} data-id="${cat}" data-balloon="${cat}" data-balloon-pos="right" onClick="ADMINBRXC.promptManagerFilterCat(event)"><input type="text" data-initial="${cat}" value="${cat}" readonly/><span class="count">${count}</span></li>`
            
        })

        cats += '</ul>';
        
        listWrapper.innerHTML = cats;   
    },
    promptManagerFilterCat: function(event){
        const self = this;
        target = (event.target.dataset.id) ? event.target : event.target.parentElement;
        if(target.dataset.active === 'true') return;
        self.promptManagerStates.activeCategory = target.dataset.id;
        self.promptManagerCat();
        self.promptManagerList();
    },
    promptManagerList: function(){
        const self = this;
        const list = document.querySelector('#promptManagerUI__list');
        let arr = Array.from(brxcPromptManager).filter(el => el && el.category === self.promptManagerStates.activeCategory);

        // Search
        if(self.promptManagerStates.search !== ''){
            arr = Array.from(arr).filter(el => el && (el.label.toLowerCase().includes(self.promptManagerStates.search.toLowerCase()) || el.prompt.toLowerCase().includes(self.promptManagerStates.search.toLowerCase())))
        }
        
        // Content
        let content = '';
        arr.forEach(obj => {
            content += `<li class="${self.promptManagerStates.active === obj.id ? ' active' : ''}" data-id="${obj.id}" >
                            <span>${obj.label}</span>
                            <div class="actions">
                                <div class="duplicate" data-id="${obj.id}" data-balloon="Duplicate" data-balloon-pos="bottom-right" onclick="event.stopPropagation();ADMINBRXC.duplicatePrompt(this.dataset.id)"><i class="fas fas fa-clone"></i></div>
                                <div class="delete" data-id="${obj.id}" data-balloon="Delete" data-balloon-pos="bottom-right" onclick="event.stopPropagation();ADMINBRXC.setDeleteVariable(this, 'ADMINBRXC.deletePrompt(this.dataset.id);')"><i class="ti-trash"></i></div>
                            </div> 
                        </li>`
        });
        list.innerHTML = content;
        const li = list.querySelectorAll('li');
        if(li.length > 0){
            li.forEach(el => {
                el.addEventListener('click', () => {
                    self.promptManagerStates.active = el.dataset.id;
                    self.promptManagerInit();
                })
            })
        }
    },
    promptManagerPanel: function(){
        const self = this;
        const panel = document.querySelector('#promptManagerUI__panel');

        const activeObj = brxcPromptManager.find(el => el.id === self.promptManagerStates.active);
        if (!activeObj) return;

        let content = '';
        content += `<div class="brxc-prompt-manager__title-wrapper">
                        <div>
                            <label for="brxcPromptTitle" class="brxc-input__label has-tooltip"><span>Name</span><div data-balloon="To rename the current Prompt label, just type inside this input." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div></label>
                            <input type="text" id="brxcPromptTitle" placeholder="" value="${activeObj.label}" />
                        </div>
                    </div>`;
        content += `<div class="brxc-prompt-manager__prompt-wrapper">
                        <label class="brxc-input__label has-tooltip">
                            <span>AI Prompt</span>
                            <div data-balloon="Add here your AI prompt." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                        </label>
                        <textarea class="description">${activeObj.prompt}</textarea>
                    </div>`;
        panel.innerHTML = content;

        const title = panel.querySelector('#brxcPromptTitle');
        
        // Listeners
        if (title){
            title.addEventListener('input', () => {
                activeObj.label = title.value;
                self.promptManagerList();
            })
        }
        const description = panel.querySelector('textarea.description');
        if (description){
            description.addEventListener('change', () => {
                activeObj.prompt = description.value;
            })
        }
    },
    resetPromptFilter: function(btn){
        const self = this;
        btn.previousElementSibling.previousElementSibling.value = '';
        self.promptManagerStates.search = '';
        self.promptManagerList();
    },
    addNewPrompt: function(event){
        const label = event.target.value;
        if(label === "" || event.key !== "Enter") return;
        const self = this;
        const id = self.vueGlobalProp.$_generateId()
        brxcPromptManager.push({
            id: id,
            label: label,
            prompt: '',
            category: self.promptManagerStates.activeCategory,
        })
        self.promptManagerStates.active = id;
        event.target.value = '';
        self.promptManagerInit();
        self.vueGlobalProp.$_showMessage(`Prompt "${label}" has been correctly created!`);
    },
    duplicatePrompt: function(id){
        const self = this;
        const activeObj = brxcPromptManager.find(el => el.id === id);
        const newId = self.vueGlobalProp.$_generateId()
        brxcPromptManager.push({
            ...activeObj, 
            id: newId, 
            label: `${activeObj.label} (Copy)`,
        })
        self.promptManagerStates.active = id;
        self.promptManagerInit();
        self.vueGlobalProp.$_showMessage(`Prompt "${`${activeObj.label} (Copy)`}" has been correctly duplicated!`);
    },
    deletePrompt: function(id){
        const self = this;
        const activeObj = brxcPromptManager.find(el => el.id === id);
        if(self.promptManagerStates.active === id) {
            if(brxcPromptManager.length > 0){
                self.promptManagerStates.active = brxcPromptManager[0].id;
            } else {
                self.promptManagerStates.active = null;
            }
        }
        brxcPromptManager.splice(brxcPromptManager.indexOf(activeObj), 1);
        self.promptManagerInit();
        self.vueGlobalProp.$_showMessage(`Prompt "${`${activeObj.label}`}" has been correctly deleted!`);
    },
    savePromptManager: function(){
        const self = this;
        const obj = brxcPromptManager || [];
        jQuery.ajax({
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'save_prompt_manager_ajax_function',
                nonce: openai_ajax_req.nonce,
                prompt_manager: obj,
            },
            method: "POST",
            success: function(data) {
                self.vueGlobalProp.$_showMessage('Prompt settings saved successfully!')
            },
            error: function(data) {
                self.vueGlobalProp.$_showMessage('Something went wrong - Prompts not saved.')
            }
        });
    },
    advancedCSSStates: {
        view: 'stylesheet',
        active: 'at-page-css',
        search: '',
        showOptions: false,
        sidebar: false,
        addCategory: false,
        renameCategory: false,
        partials: '',
        partialVariables: [],
        editAI: false,
        communityRecipesLoaded: false,
    },
    advancedCSSInit: function(){
        const self = this;
        const wrapper = document.querySelector('#brxcCSSOverlay')
        wrapper.classList.contains('sidebar') ? self.advancedCSSStates.sidebar = true :self.advancedCSSStates.sidebar = false;
        self.disableSelectorPicker();
        self.compilePartials(self.advancedCSSStates);
        self.compilePartialsVariables(self.advancedCSSStates);
        self.advancedCSSCat();
        self.advancedCSSPanel();
    },
    compilePartials: function(state){
        state.partials = brxcAdvancedCSSDefault.filter(el => el && el.type === "scssp" && el.status == "1" && el.contentSass).map(el => el.contentSass).join('');
    },
    compilePartialsVariables: function(state){
        state.partialVariables = state.partials.match(/\$[a-zA-Z0-9_-]+/g);
    },
    advancedCSSCat: function(){
        const self = this;
        self.advancedCSSStates.sidebar ? self.advancedCSSCatSidebar() : self.advancedCSSCatFullsize(); 
    },

    getCommunityRecipes: async function(advancedCSS = false) {
        const self = this;
        const loader = document.querySelector('#advancedCSSUI__loader');
        if(advancedCSS) loader.classList.add('active');

        function removeLoader(){
            self.advancedCSSCatFullsizeRender();
            loader.classList.remove('active');
        }

        try {
            let allResults = [];
            let page = 1;
            let totalPages = 1;

            while (page <= totalPages) {
                const rawResponse = await fetch(`https://advancedthemer.com/wp-json/wp/v2/recipes?_fields=id,status,title,acf&per_page=100&page${page}`);
                const content = await rawResponse.json();
                if (content.error) {
                    console.log('content error');
                    self.advancedCSSStates.communityRecipesLoaded = true
                    if(advancedCSS) removeLoader();
                    break;
                } else {
                    const results = content
                        .filter(el => el.status === "publish")
                        .sort((a, b) => b.id - a.id)
                        .map(el => {
                            return {
                                category: "community recipes",
                                contentCss: el.acf.recipe_code,
                                default: true,
                                file: false,
                                id: `community_recipe_${el.title.rendered}`,
                                label: el.title.rendered,
                                message: `This recipe is provided by ${el.acf.recipe_author}. The Community Recipes can't be modified and are set as read-only`,
                                readOnly: true,
                                saveMethod: false,
                                status: 1,
                                toggleActive: false,
                                type: "recipe",
                                typeLabel: "recipe",
                            };
                        });
                    allResults = allResults.concat(results);

                    const totalPagesHeader = rawResponse.headers.get('X-WP-TotalPages');
                    totalPages = totalPagesHeader ? parseInt(totalPagesHeader) : totalPages;
                    page++;
                }
            }

            allResults.forEach(result => {
                const existing = brxcAdvancedCSSDefault.find(el => el.id === result.id);
                if(!existing) brxcAdvancedCSSDefault.unshift(result);
            })
            self.advancedCSSStates.communityRecipesLoaded = true
            if(advancedCSS) removeLoader();
                
            
        } catch (error) {
            console.log('Fetch error:', error);
            self.advancedCSSStates.communityRecipesLoaded = true
            if(advancedCSS) removeLoader();
        }
    },
    advancedCSSCatFullsize: function(){
        const self = this;
    
        self.globalSettings.classFeatures.advancedCSSCommunityRecipes && self.advancedCSSStates.communityRecipesLoaded === false & self.advancedCSSStates.view === "recipes" ? self.getCommunityRecipes(true) : self.advancedCSSCatFullsizeRender();    
    },

    advancedCSSCatFullsizeRender: function(){
        const self = this;
        const listWrapper = document.querySelector('#brxcAdvancedCSSCatListCanvas');
        if(!listWrapper) return;
        const categories = [...new Set(brxcAdvancedCSSDefault.map(el => el.category))];
        let cats = '';

        function isActive (objId) {
            if(objId === self.advancedCSSStates.active) return true;
            return false;
        }
        function isCatIncluded(el){
            const field = self.globalSettings.classFeatures.advancedCSSEnableSass && el.hasOwnProperty('contentSass') ? 'contentSass' : 'contentCss';
            if(el[field]?.toLowerCase().includes(self.advancedCSSStates.search.toLowerCase())) return true;
            return false;
        }


        function view(obj){
            if(self.advancedCSSStates.view === "recipes"){
                return obj.typeLabel === "recipe";
            } else {
                return obj.typeLabel !== "recipe";
            }
        }

        function renderCategory(category, defaultFlag = true) {
            let defaultCats = brxcAdvancedCSSDefault.filter(obj => !obj.removed && obj.category === category && view(obj));
        
            // Apply search filter if any
            if (self.advancedCSSStates.search !== '') {
                defaultCats = defaultCats.filter(el => isCatIncluded(el) || (el.label?.toLowerCase().includes(self.advancedCSSStates.search.toLowerCase())));
            }
        
            let output = `<div class="cat-separation${category === 'custom' ? ' custom' : ''}"><span class="title">${category === 'custom' ? `custom ${self.advancedCSSStates.view}` : category}</span><ul>`;
            
            defaultCats.forEach(obj => {
                const isActiveClass = isActive(obj.id) ? 'active' : '';
                const isActiveData = isActive(obj.id) ? ' data-active="true"' : '';
                const readOnlyAttr = !isActive(obj.id) ? ' readonly' : '';
        
                output += `<li class="${isActiveClass}"${isActiveData} data-id="${obj.id}" onClick="ADMINBRXC.advancedCSSFilterCat(event)">`;
                if(obj.hasChanged === true) output += `<div class="brxc-advanced-css--change-indicator"></div>`
                output += `<div class="brxc-advanced-css-type--label">${obj.typeLabel}</div>`;
                
                // Handle default or custom input rendering
                output += `<input type="text" data-initial="${obj.label}" value="${obj.label}"${obj.default !== defaultFlag ? readOnlyAttr : ' readonly'}/>`;
                
                // Render actions if necessary
                output += renderActions(obj);
        
                output += `</li>`;
            });
        
            output += `</ul></div>`;
            return output;
        }
        
        function renderActions(obj) {
            let actions = `<div class="brxc-actions">`;
        
            if (isActive(obj.id) && obj.category === "custom") {
                actions += `<div class="deleteCat" onClick="event.stopPropagation();ADMINBRXC.deleteAdvancedCSSCategory(event, '${self.advancedCSSStates.active}')" 
                              data-balloon="Delete File" data-balloon-pos="top-right">
                              <span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
            }
        
            if (obj.readOnly) {
                actions += `<div class="brxc-readonly--icon" data-balloon="Readonly" data-balloon-pos="top-right"><i class="fas fa-eye"></i></div>`;
            }
        
            if (obj.toggleActive) {
                actions += `<div class="brxc-toggle-palette">
                              <div class="" data-balloon="${obj.status === "1" ? 'Disable' : 'Enable'} Stylesheet" data-balloon-pos="top-right"
                              onclick="ADMINBRXC.toggleAdvancedCSSStatus(event, '${obj.id}')">
                              <i class="fas fa-toggle-${obj.status === "1" ? 'on' : 'off'}"></i></div></div>`;
            }
        
            actions += `</div>`;
            return actions;
        }
        
        // Main Render Function
        function renderCategories(categories) {
            let cats = '';
            categories.filter(el => el && el !== "custom").forEach(category => {
                cats += renderCategory(category);
            });
        
            // Custom Category Section
            cats += renderCategory("custom", false);
        
            return cats;
        }

        cats += renderCategories(categories);

        // Add new CSS file
        const placeholder = self.advancedCSSStates.view === "stylesheet" ? "stylesheet" : "recipe";
        const keyupFn = self.advancedCSSStates.view === "stylesheet" ? "ADMINBRXC.addNewAdvancedCSSCategory(event);" : "ADMINBRXC.addNewAdvancedCSSRecipe(event);"

        cats += `<input type="text" id="addNewAdvancedCSSCat" placeholder="+ New ${placeholder}" onkeyup="${keyupFn}" />`;
        
        listWrapper.innerHTML = cats;

        // rename cat
        const input = listWrapper.querySelector('li.active input');
        if(input){
            input.addEventListener('keyup', (event) => {
                if(event.key !== "Enter") return;
                const value = event.target.value.replaceAll(' ', '-').toLowerCase();
                if(value === event.target.dataset.initial) return self.advancedCSSCat();
                if(brxcAdvancedCSSDefault.map(el => el && el.label).includes(value)) return self.vueGlobalProp.$_showMessage(`ABORT: ${self.advancedCSSStates.view} "${value}" already exists`);
                const activeObj = brxcAdvancedCSSDefault.find(el => el && el.id === self.advancedCSSStates.active);
                if(!activeObj) return self.vueGlobalProp.$_showMessage(`ABORT: Error renaming the ${self.advancedCSSStates.view}.`);
                activeObj.label = value;
                self.vueGlobalProp.$_showMessage(`${self.advancedCSSStates.view} correctly renamed to ${value}`)
                self.advancedCSSCat();
            })
        }
        
    },
    advancedCSSCatSidebar: function(){
        const self = this;
        const listWrapper = document.querySelector('#brxcAdvancedCSSCatListCanvas');
        if(!listWrapper)  return;
        const activeObj = brxcAdvancedCSSDefault.find(el => el && el.id === self.advancedCSSStates.active);
        let content = '';
        content += `<div class="brxc-select">`;
        
        if(self.advancedCSSStates.renameCategory === false && self.advancedCSSStates.addCategory === false && self.advancedCSSStates.active){
            const uneditableCategories = brxcAdvancedCSSDefault.filter(el => el && el.category === "default").map(el => el && el.id);
            content += `<select name="brxc-cssVariablesOptions" id="cssVariablesOptions" class="brxc-cssVariablesOptions" value="${self.advancedCSSStates.active}" onChange="ADMINBRXC.advancedCSSStates.search = '';ADMINBRXC.advancedCSSStates.active = this.value;ADMINBRXC.advancedCSSInit();">`;
            brxcAdvancedCSSDefault.forEach(cat => {
                content += `<option value="${cat.id}"${cat.id === self.advancedCSSStates.active ? ' selected="selected"' : ''}>${cat.label}</option>`;
            })
            content += `</select>`;
            content += '<div class="brxc-icon-container">'
            content += !uneditableCategories.includes(self.advancedCSSStates.active) ? `<div class="brxc-icon" data-balloon="Rename CSS File" data-balloon-pos="bottom-right" onClick="ADMINBRXC.advancedCSSStates.renameCategory = true;ADMINBRXC.advancedCSSCat()"><span class="bricks-svg-wrapper"><i class="fas fa-pen"></i></span></div>` : '';
            content += `<div class="brxc-icon" data-balloon="Add New CSS File" data-balloon-pos="bottom-right" onClick="ADMINBRXC.advancedCSSStates.addCategory = true;ADMINBRXC.advancedCSSCat()"><span class="bricks-svg-wrapper"><i class="fas fa-plus"></i></span></div>`;
            content += !uneditableCategories.includes(self.advancedCSSStates.active) ? `<div class="brxc-icon" data-balloon="Delete CSS File" data-balloon-pos="bottom-right" onClick="ADMINBRXC.setDeleteVariable(this, 'ADMINBRXC.deleteVariableCategory()');"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>` : '';
            content += '</div>';
            content += activeObj.toggleActive && !uneditableCategories.includes(self.advancedCSSStates.active) ? `<div class="brxc-toggle-palette"><div class="" data-balloon="${activeObj.hasOwnProperty('status') && activeObj.status === "1" ? "Disable CSS File" : "Enable CSS File"}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.toggleAdvancedCSSStatus(event, '${activeObj.id}')"><i class="fas fa-toggle-${activeObj.hasOwnProperty('status') && activeObj.status === "1" ? 'on' : 'off'}"></i></div></div>` : '';
            
        } else if(self.advancedCSSStates.renameCategory === true){
            content += `<input type="text" id="brxcRenameCategory" data-initial="${activeObj.label}" value="${activeObj.label}" />`;
        } else if(self.advancedCSSStates.addCategory === true){
            content += `<input type="text" id="brxcAddCategory" placeholder="Type the filename here and hit ENTER." value="" />`;
        }
        content += `</div>`;
        if(activeObj.hasOwnProperty('message') && activeObj.message !== "") content += `<div class="brxc-panel-message" data-control="info">${activeObj.message}</div>`;

        if(listWrapper && content) listWrapper.innerHTML = content;

        // Add
        if (self.advancedCSSStates.addCategory === true || !self.advancedCSSStates.active) {
            self.advancedCSSStates.addCategory = false;
            const input = listWrapper.querySelector('#brxcAddCategory');
            if (!input) return;
            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();

            const onBlur = () => {
                input.removeEventListener("blur", onBlur);
                input.removeEventListener("keydown", onKeyDown);
                setTimeout(() => {
                    self.advancedCSSCat();
                }, 10);
            };

            const onKeyDown = (event) => {
                if (event.key === "Enter") {
                    self.addNewAdvancedCSSCategory(event);
                    input.removeEventListener("blur", onBlur);
                    input.removeEventListener("keydown", onKeyDown);
                };
            };

            input.addEventListener("blur", onBlur);
            input.addEventListener("keydown", onKeyDown);
        }

        // Rename
        if (self.advancedCSSStates.renameCategory === true) {
            self.advancedCSSStates.renameCategory = false;
            const input = listWrapper.querySelector('#brxcRenameCategory');
            if (!input) return;
            const end = input.value.length;
            input.setSelectionRange(end, end);
            input.focus();

            function renameName(event, activeObj) {

                const value = event.target.value.replaceAll(' ', '-').toLowerCase();
                if(value === event.target.dataset.initial) return self.advancedCSSCat();
                if(brxcAdvancedCSSDefault.map(el => el && el.label).includes(value)) return self.vueGlobalProp.$_showMessage(`ABORT: CSS File "${value}" already exists`);
                activeObj.label = value;
                self.vueGlobalProp.$_showMessage(`CSS file correctly renamed to ${value}`)
                self.advancedCSSCat();
            }

            const onBlur = () => {
                input.removeEventListener("blur", onBlur);
                input.removeEventListener("keydown", onKeyDown);
                setTimeout(() => {
                    self.advancedCSSCat();
                }, 10);
            };

            const onKeyDown = (event) => {
                if (event.key === "Enter") {
                    renameName(event, activeObj);
                    input.removeEventListener("blur", onBlur);
                    input.removeEventListener("keydown", onKeyDown);
                }
            };

            input.addEventListener("blur", onBlur);
            input.addEventListener("keydown", onKeyDown);
        }
    },

    toggleAdvancedCSSStatus: function(event, objId){
        const self = this;
        event.stopPropagation();
        const obj = brxcAdvancedCSSDefault.find(el => el && el.id === objId);
        if(!obj) return;

        obj.status == "1" ? obj.status = "0" : obj.status = "1";
        obj.hasChanged = true;
  
        self.advancedCSSRenderValue(obj, false)
        self.advancedCSSInit();
    },
    advancedCSSFilterCat: function(event){
        const self = this;
        target = (event.target.dataset.id) ? event.target : event.target.parentElement;
        if(target.dataset.active === 'true') return;
        self.advancedCSSStates.active = target.dataset.id;
        self.advancedCSSInit();
    },
    addNewAdvancedCSSCategory: function(event){
        const self = this;

        if(event.key !== "Enter") return;

        const values = event.target.value.split(',');
        if(values.length < 1) return;

        let hasChanges = false;
        let newId;

        values.forEach(name => {
            if(brxcAdvancedCSSDefault.map(obj => obj && obj.typeLabel !== "recipe" && obj.label).includes(name)) {
                return self.vueGlobalProp.$_showMessage('ABORT: File already exists');
            } else {
                hasChanges = true;
                newId = self.vueGlobalProp.$_generateId();
                const type = self.globalSettings.classFeatures.advancedCSSEnableSass ? 'scss' : 'css'; 
                brxcAdvancedCSSDefault.push({
                    "id": `css-${newId}`,
                    "file": false,
                    "label": name,
                    "type": type,
                    "typeLabel": type,
                    "category": "custom",
                    "scope": "global",
                    "message": '',
                    "note": "",
                    "read-only": false,
                    "contentCss": '',
                    "contentSass": '',
                    "saveMethod": "ajax",
                    "status": "1",
                    "priority": "10",
                    "toggleActive": true,
                    "enqueueFrontend": 1,
                    "enqueueBuilder": 0,
                    "enqueueGutenberg": 0,

                })
            }
        })
        if(hasChanges === true) {
            self.advancedCSSStates.active = `css-${newId}`;
            self.advancedCSSInit();
        };  
    },
    addNewAdvancedCSSRecipe: function(event){
        const self = this;

        if(event.key !== "Enter") return;

        const values = event.target.value.split(',');
        if(values.length < 1) return;

        let hasChanges = false;
        let newId;

        values.forEach(name => {
            if(brxcAdvancedCSSDefault.map(obj => obj && obj.typeLabel === "recipe" && obj.label).includes(name)) {
                return self.vueGlobalProp.$_showMessage('ABORT: Recipe already exists');
            } else {
                hasChanges = true;
                newId = self.vueGlobalProp.$_generateId();
                const type = self.globalSettings.classFeatures.advancedCSSEnableSass ? 'scss' : 'css'; 
                brxcAdvancedCSSDefault.push({
                    "id": `recipe-${newId}`,
                    "file": false,
                    "label": self.helpers.formatForClasses(name),
                    "type": "css",
                    "typeLabel": "recipe",
                    "category": "custom",
                    "message": "",
                    "readOnly": false,
                    "contentCss": "",
                    "status": "1",
                    "saveMethod": "ajax",
                    "toggleActive": true,

                })
            }
        })
        if(hasChanges === true) {
            self.advancedCSSStates.active = `recipe-${newId}`;
            self.advancedCSSInit();
        };  
    },
    deleteAdvancedCSSCategory: function(event,id){
        const self = this;
        event.stopPropagation();
        const target = event.target;
        const oldContent = target.innerHTML;
        const oldBalloon = target.dataset.balloon;
        const oldFunction = target.getAttribute('onclick');
        const newContent = '<span class="bricks-svg-wrapper"><i class="fas fa-check"></i></span>';
        const newBalloon = 'Confirm?';

        target.setAttribute("onClick", `event.stopPropagation(),ADMINBRXC.deleteAdvancedCSSCategoryFinal('${id}')`);
        target.setAttribute("data-balloon", newBalloon);
        target.innerHTML = newContent;
        setTimeout(() => {
            target.setAttribute("onClick", oldFunction);
            target.setAttribute("data-balloon", oldBalloon);
            target.innerHTML = oldContent;
        }, 2000)
    },
    deleteAdvancedCSSCategoryFinal: function(id){
        const self = this;
        const obj = brxcAdvancedCSSDefault.find(el => el && el.id === id);
        if(!obj) return self.vueGlobalProp.$_showMessage('Abort: error finding the CSS file');
        obj['removed'] = true;
        const catName = obj.label;

        // Remove <style>
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        let override = x.document.querySelector(`#at-${id}-css`);
        if(override) override.remove();
        
        // reinit
        self.advancedCSSStates.active = "at-page-css";
        self.vueGlobalProp.$_showMessage(`CSS file "${catName}" has been successfully deleted!`);
        self.advancedCSSInit();
    },
    toggleCompiledCSS: function (id){
        const self = this;
        const activeObj = brxcAdvancedCSSDefault.find(el => el.id === id);
        if(activeObj.hasOwnProperty('compiledCSS') && activeObj.compiledCSS){
            activeObj.compiledCSS = false;
            if(self.globalSettings.classFeatures.advancedCSSEnableSass) activeObj.readOnly = false;
        } else {
            activeObj.compiledCSS = true;
            activeObj.readOnly = true;
        }
        self.advancedCSSCat();
        self.advancedCSSPanel();
    },
    advancedCSSPanel: function(){
        const self = this;
        const header = document.querySelector('#advancedCSSUI__header');
        const panel = document.querySelector('#advancedCSSUI__panel');
        let content = '';

        const activeObj = brxcAdvancedCSSDefault.find(obj => obj.id === self.advancedCSSStates.active);
        if (!activeObj) return;

        // Header
        content += `
                    <div id="brxcAdvancedCSSToggleType">
                        <a class="brxc-overlay__action-btn ${self.advancedCSSStates.view === "stylesheet" ? "primary" : "secondary"}" onclick="ADMINBRXC.advancedCSSStates.view = 'stylesheet';ADMINBRXC.advancedCSSInit();"><span>Stylesheets</span></a>
                        <a class="brxc-overlay__action-btn ${self.advancedCSSStates.view === "recipes" ? "primary" : "secondary"}" onclick="ADMINBRXC.advancedCSSStates.view = 'recipes';ADMINBRXC.advancedCSSInit();"><span>Recipes</span></a>
                    </div>
                    <div class="brxc-panel-header">
                        <div class="brxc-panel-category">${activeObj.category}</div>
                        <div class="brxc-panel-separator">/</div>
                        <div class="brxc-panel-title">${activeObj.label}</div>`;
        if(activeObj.type === "scss") content += `<div class="brxc-advanced-css-type--compiled-css${activeObj.compiledCSS ? ' active' :''}" onclick="ADMINBRXC.toggleCompiledCSS('${activeObj.id}')">View compiled CSS</div>`;

        if(activeObj.category === "custom") content += `<div class="brxc-panel-options${self.advancedCSSStates.showOptions ? ' active' : ''}" data-balloon="${self.advancedCSSStates.showOptions ?  'Hide' : 'Show'} Advanced Settings" data-balloon-pos="right" onclick="ADMINBRXC.advancedCSSStates.showOptions = !ADMINBRXC.advancedCSSStates.showOptions;ADMINBRXC.advancedCSSPanel();"><i class="fas fa-gear"></i></div>`;
        content += `</div>`;
        if(activeObj.hasOwnProperty('message') && activeObj.message !== "" && !self.advancedCSSStates.showOptions){
            content += `<div class="brxc-panel-message" data-control="info">${activeObj.message}</div>`;
        }
        header.innerHTML = content;

        // Panel
        const textareaContent = activeObj.type !== "css" && activeObj.hasOwnProperty('contentSass') && activeObj.compiledCSS !== true ? activeObj.contentSass : activeObj.contentCss;
        content = '';
        let sass = false;
        if (self.globalSettings.classFeatures.advancedCSSEnableSass){
            self.destroySassInstances('advancedCss');
            sass = self.createSassInstance('advancedCss');
        }
        if(self.advancedCSSStates.showOptions && activeObj.category === "custom"){
            const objs = [
                {
                    label: "Enqueue on Frontend?",
                    balloon: "If this option is checked, the CSS file will be enqueued on the frontend (and inside the preview window of the builder)",
                    data: "click",
                    prop: "enqueueFrontend",
                    rerender: 1,
                },
                {
                    label: "Enqueue in the Builder?",
                    balloon: "If this option is checked, the CSS file will be enqueued in the builder itself but not inside the preview window.",
                    data: "click",
                    prop: "enqueueBuilder",
                    rerender: 1,
                },
                {
                    label: "Enqueue in Gutenberg?",
                    balloon: "If this option is checked, the CSS file will be enqueued inside the Block Editor of Gutenberg.",
                    data: "click",
                    prop: "enqueueGutenberg",
                    rerender: 0,
                },
            ];
            content += `<div class="brxc-advanced-options__wrapper">
                            <div>
                                <label for="brxcAdvancedCSsID" class="has-tooltip">
                                    <span>Internal ID</span>
                                    <div data-balloon="This ID is used to create the CSS file and enqueue it on your website." data-balloon-pos="right" data-balloon-length="large"><i class="fas fa-circle-question"></i></div>
                                </label>
                                <input type="text" id="brxcAdvancedCSsID" class="brxc-input-text" value="${activeObj.id}" readonly></input>
                            </div>
                            <div${self.globalSettings.classFeatures.advancedCSSEnableSass ? ` class="brxc-select"` : ''}>
                                <label for="brxcAdvancedCSSType" class="has-tooltip">
                                    <span>Type</span>
                                    <div data-balloon="Choose the type of file you want to work with." data-balloon-pos="right" data-balloon-length="large"><i class="fas fa-circle-question"></i></div>
                                </label>`;
            if(self.globalSettings.classFeatures.advancedCSSEnableSass){
                content += `<select id="brxcAdvancedCSSType">
                                <option value="css"${activeObj.type === 'css' ? ' selected' : ''} data-label="css">css</option>
                                <option value="scss"${activeObj.type === 'scss' ? ' selected' : ''} data-label="scss">scss</option>
                                <option value="scssp"${activeObj.type === 'scssp' ? ' selected' : ''} data-label="partial">partial</option>
                            </select>`
            } else {
                content += `<input type="text" id="brxcAdvancedCSSType" class="brxc-input-text" value="${activeObj.typeLabel}" readonly></input>`
            }
                content +=  `</div>
                             <div>
                                <label for="brxcAdvancedCSsPriority" class="has-tooltip">
                                    <span>Priority</span>
                                    <div data-balloon="Set the priority the CSS file should be enqueued. The lower the number is, the fastest it will be printed." data-balloon-pos="right" data-balloon-length="large"><i class="fas fa-circle-question"></i></div>
                                </label>
                                <input type="number" id="brxcAdvancedCSsPriority" data-prop="priority" data-default="10" class="brxc-input-text" min="1" max="9999" value="${activeObj.type !== 'scssp' ? `${activeObj.priority}"` : '" readonly'}></input>
                            </div>
                            <div style="flex-basis:100%;">
                                <label for="brxcAdvancedCSSMessage" class="has-tooltip">
                                    <span>Message</span>
                                    <div data-balloon="Add a custom message that will be visible on top when selecting this stylesheet." data-balloon-pos="right" data-balloon-length="large"><i class="fas fa-circle-question"></i></div>
                                </label>
                                <textarea id="brxcAdvancedCSSMessage" data-prop="message" data-default="">${activeObj.message}</textarea>
                            </div>`
            objs.forEach(obj => {
                if(obj.data === "click"){
                    content += `<div class="gridUI__input-wrapper">
                            <label class="has-tooltip">
                                <span>${obj.label}</span>
                                <div data-balloon="${obj.balloon}" data-balloon-pos="bottom" data-balloon-length="medium">
                                    <i class="fas fa-circle-question"></i>
                                </div>
                            </label>
                            <i class="fas fa-toggle-${activeObj[obj.prop] == 1 ? 'on' : 'off'}" data-click="${obj.prop}" data-rerender="${obj.rerender}"></i>
                        </div>`
                }
            })
        content += `</div>`;
        }
        content += `<div class="actions"></div><div class="codemirror-wrapper">
            <textarea class="codemirror">${textareaContent}</textarea>
            <div class="brxc-error-handling"></div>`

        // AI
        if(self.helpers.isAIActive()) {
            const isAIreadOnly = activeObj.readOnly || activeObj.id === "at-child-css";
            content += `<div id="brxcAdvancedCSSAIpromptContainer">
                            <div id="brxcAdvancedCSSAIpromptWrapper"${isAIreadOnly ? ' class="readonly"': ''}>
                                <div id="brxcAdvancedCSSAIEdit"${self.advancedCSSStates.editAI ? ' class="active"' : ''}" data-balloon="Edit existing code" data-balloon-pos="top-left"><i class="fas fa-edit"></i></div>
                                <textarea id="brxcAdvancedCSSAIprompt" placeholder="Message AI" onInput="ADMINBRXC.helpers.textAreaAutoGrow(this, '40px')"></textarea>
                                <div id="brxcAdvancedCSSAISendRequest"><i class="fas fa-arrow-up"></i></div>
                            </div>
                        </div>
                    </div>`;
        }
        panel.innerHTML = content;

        // Listeners
        const inputs = panel.querySelectorAll('input[data-prop],textarea[data-prop]');
        if(inputs.length > 0){
            ['input', 'change'].forEach(ev => {
                inputs.forEach(input => {
                    input.addEventListener(ev, () => {
                        const prop = input.dataset.prop;
                        input.value !== "" ? activeObj[prop] = input.value : activeObj[prop] = input.dataset.default;
                    })
                }) 
            })
        }

        const clicks = panel.querySelectorAll('[data-click]');
        if(clicks.length > 0){
            clicks.forEach(el => {
                el.addEventListener('click', () => {
                    const prop = el.dataset.click;
                    activeObj[prop] == 1 ?  activeObj[prop] = 0 : activeObj[prop] = 1;
                    const newCSS = activeObj.type !== "css" && activeObj.hasOwnProperty('contentSass') && activeObj.compiledCSS !== true ? activeObj.contentSass : activeObj.contentCss;
                    if(el.dataset.rerender === "1") self.advancedCSSRenderValue(activeObj, newCSS);
                    self.advancedCSSPanel();
                })
            }) 
        }

        const select = panel.querySelector('select#brxcAdvancedCSSType');
        if(select){
            select.addEventListener('change', () => {
                const selectedOption = select.selectedOptions[0];
                activeObj.type = select.value;
                activeObj.typeLabel = selectedOption.dataset.label
                self.advancedCSSInit();
            })
        }

        // Edit AI
        const editAI = panel.querySelector('#brxcAdvancedCSSAIEdit');
        if(editAI){
            editAI.addEventListener('click', () => {
                self.advancedCSSStates.editAI = !self.advancedCSSStates.editAI;
                self.advancedCSSPanel();
            })
        }

        // Codemirror
        const textarea = panel.querySelector('textarea.codemirror');
        if (textarea){
            const metaKey = (e) => self.vueState.isMac ? e.metaKey : e.ctrlKey;
            const options = self.codeMirrorOptions(textarea);
            options.mode = activeObj.type !== "css" ? "text/x-scss" : "css";
            options.styleActiveLine = true;
            options.autoCloseBrackets = true;
            options.matchBrackets = true;
            options.selfContain = true;
            options.search = { bottom: false };
            options.autofocus = false;
            if(activeObj.readOnly) {
                options.readOnly = true;
            } else {
                options.profile = "xhtml"
            }
            const MyCM = CodeMirror.fromTextArea(textarea, options);
            if(!activeObj.readOnly) emmetCodeMirror(MyCM);
            MyCM.getWrapperElement().setAttribute("data-type", "at");
            if(activeObj.id === "at-child-css") self.helpers.childThemeCommentReadOnly(MyCM);

            const debouncedRenderValue = self.debounce(function(activeObj, value) {
                self.advancedCSSRenderValue(activeObj, value);
            }, 500);
            // Input events
            if(!activeObj.readOnly){
                MyCM.on("keydown", function (cm, event) {
                    // Beautify
                    if(metaKey(event) && event.key === "b" ){
                        event.preventDefault();
                        event.stopPropagation();
                        return self.beautifyCSS(`#advancedCSSUI__panel`)
                    }

                    if(metaKey(event) && event.shiftKey && event.key === "7" ){
                        cm.toggleComment();
                    }

                    // Search
                    if(metaKey(event) && event.key === "f" ){
                        event.preventDefault();
                        event.stopPropagation();
                        return cm.execCommand('find');
                    }
    
                    if (event.key === 'Tab') {
                        self.helpers.replaceRWithRoot(MyCM, event)
                        
                    }

                    if (!cm.state.completionActive &&
                        ((event.key >= '0' && event.key <= '9') ||    // Digits 0-9
                            (event.key >= 'a' && event.key <= 'z') ||    // Letters a-z
                            event.key === '(' || event.key === '!' ||    // Opening parenthesis (
                            event.key === '-') &&                        // Dash
                        !event.metaKey && !event.altKey && event.key !== '{' && event.key !== '}' &&
                        !event.ctrlKey) {
                            CodeMirror.commands.autocomplete(cm, null, { completeSingle: false });
                    }
                });

                MyCM.on("change", function (cm, event) {
                    const value = cm.getValue();
                    let hasChanged = false;
                    if(!activeObj.hasOwnProperty('hasChanged')) hasChanged = true;
                    activeObj.hasChanged = true;
                    if(hasChanged) self.advancedCSSCat();
                    debouncedRenderValue(activeObj, value);
                });
            }

            // AI
            const aiRequest = panel.querySelector('#brxcAdvancedCSSAISendRequest');
            if(aiRequest){
                aiRequest.addEventListener('click', () => {
                    const prompt = panel.querySelector('#brxcAdvancedCSSAIprompt');
                    self.advancedCSSAI(MyCM, prompt.value);
                    prompt.value = "";
                })
            }
        }

        // set icons
        const action = panel.querySelector('.actions');
        if(!action) return;
        let options = '';
        if(activeObj.readOnly){
            options = {
                "wrapper": action,
                "selector": '#advancedCSSUI__panel',
                "comment": false,
                "fullscreen": true,
                "selector-picker": false,
                "contextualSuperpowercss": {
                    "extract-global-classes": true,
                    "extract-global-variables": true,
                }
            }
        } else if(activeObj.type === "scssp") {
            options = {
                "wrapper": action,
                "selector": '#advancedCSSUI__panel',
                "comment": true,
                "fullscreen": true,
                "selector-picker": true,
                "contextualSuperpowercss": {
                    "beautify-css": true,
                }
            }
        } else {
            options = {
                "wrapper": action,
                "selector": '#advancedCSSUI__panel',
                "comment": true,
                "fullscreen": true,
                "selector-picker": true,
                "contextualSuperpowercss": {
                    "component-selectors": true,
                    "beautify-css": true,
                    "variabilize-css": true,
                },
                "rootSelector": ':root',
            }
        }
        if(activeObj.type === "css"){
            options["contextualSuperpowercss"] = {
                "component-selectors": true,
                "beautify-css": true,
                "variabilize-css": true,
                "extract-global-classes": true,
                "extract-global-variables": true,
            };
        }

        self.superPowerCSSIcons(options);

    },
    advancedCSSAI: function(cm, promptRequest){
        const self = this;
        const activeStyle = brxcAdvancedCSSDefault.find(el => el.id === self.advancedCSSStates.active);
        const type = activeStyle.type === "css" ? "CSS" : "SCSS";
        let systemtContent = '';
        if(self.advancedCSSStates.editAI){
            systemtContent = `You are an expert ${type} developer. You will receive a ${type} string and a user prompt. Your task is to edit or improve the existing ${type} rules based on the prompt. Return only the raw ${type} code without any additional comments, explanations, or text. The output must be valid, executable ${type} code, with no formatting, comments, or non-${type} elements. Do not include any text that is not part of a valid ${type} declaration.`
        } else {
            systemtContent = `You are an expert ${type} developer. You will receive existing  and a user prompt. Your task is to generate new ${type} code based on the prompt and append it to the existing ${type} code. Do not repeat or modify the existing ${type} code. Output only the new rules without any additional comments, explanations, or text. Don't start with "scss". The response should contain only valid, executable ${type} declarations and nothing else.`
        }
        let cssString = cm.getValue();
        const requestBody = {
            model: self.globalSettings.defaultAIModel,
            stream: true,
            messages: [
                {
                    role: "system",
                    content: systemtContent,
                },
                {
                    role: "user",
                    content: `Existing ${type}:\n${cssString}\n\nUser Request: ${promptRequest}`
                }
            ]
        };

        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce
            },
            success: function(response) {
                const fetchDescription = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization' : 'Bearer ' + response,
                        },
                        body: JSON.stringify(requestBody)
                    });
 
                    if(!rawResponse.ok){
                        const statusText = rawResponse.status === 401 ? "Unauthorized. Double-check you correctly inserted the OpenAI API key inside the Theme Settings." : rawResponse.statusText;
                        self.insertErrorMessage('brxcCSSOverlay', false, '#brxcCSSOverlay', `${rawResponse.status}: ${statusText}`);
                        //target.classList.remove('disable');
                    } else {
                        // Create a reader to read the streamed response
                        const reader = rawResponse.body.getReader();
                        const decoder = new TextDecoder();
                        let newCssCode = '';
                
                        // Function to handle each chunk of data
                        const processChunk = async () => {
                            const { done, value } = await reader.read();
                            if (done) {
                                // All chunks have been read
                                return;
                            }
                
                            // Decode and parse the JSON chunk
                            const chunkText = decoder.decode(value);


                            // Split the chunk text into lines and process each one
                            const lines = chunkText.split('\n').filter(line => line.trim() !== '');
                            for (let line of lines) {
                                // Check if the line starts with "data: "
                                if (line.startsWith("data: ")) {
                                    const jsonLine = line.replace("data: ", "").trim();
                                    if (jsonLine !== "[DONE]") {
                                        try {
                                            // Parse the JSON and get the new CSS content
                                            const parsedData = JSON.parse(jsonLine);
                                            if (parsedData.choices && parsedData.choices[0].delta && parsedData.choices[0].delta.content) {
                                                let cssChunk = parsedData.choices[0].delta.content;
                                
                                                // Remove any code block symbols and formatting hints
                                                cssChunk = cssChunk.replace(/```/g, '');

                                                // Append the clean CSS content
                                                newCssCode += cssChunk;

                                                // Apply the new CSS live to the document
                                                const cmValue = self.advancedCSSStates.editAI ? newCssCode : cssString + newCssCode;
                                                cm.setValue(css_beautify(cmValue, { indent_size: 2 }));
                                            }
                                        } catch (e) {
                                            console.error('Failed to parse JSON chunk:', e, jsonLine);
                                        }
                                    }
                                }
                            }
                
                            // Continue reading the next chunk
                            processChunk();
                        };
                
                        // Start processing chunks
                        await processChunk();
                    }
                };
                fetchDescription();
            },
            error: function(response){
                self.vueGlobalProp.$_showMessage('Something went wrong with the OpenAI AJAX request: ' + response);
                //target.classList.remove('disable');
            }
        }); 
    },
    advancedCSSRenderValue: function(activeObj,value){
        const self = this;

        activeObj.lastModified = new Date(
            new Date().toLocaleString("en-US", { timeZone: self.globalSettings.timezone })
          ).getTime();
        activeObj.lastModifiedBy = bricksData.author;

        if(activeObj.id === 'at-page-css' ){
            return self.advancedCSSRenderPageCSS(activeObj, value);
            
        }

        if(activeObj.id === 'at-global-css' ){
            return self.advancedCSSRenderGlobalCSS(activeObj, value)
            
        }

        if(activeObj.id === 'at-child-css' ){
            return self.advancedCSSRenderChildCSS(activeObj, value)
            
        }

        if(activeObj.type === 'scssp' ){
            return self.advancedCSSRenderPartials(activeObj, value)
            
        }

        if(activeObj.category === 'wpcodebox' ){
            const x = document.querySelector('#bricks-builder-iframe').contentWindow;
            const files = x.document.querySelectorAll('.wpcb2-external-style');
            // External Link
            const externalLinks = Array.from(files).find(el => el.href.includes(`${activeObj.id}.css`));
            const override = {};
            if (!externalLinks){
                // Inline script
                override.Frontend = x.document.querySelector(`[wpcb-ids="${activeObj.id}"]`);
            }
            if (!override.Frontend){
                // AT override
                override.Frontend = x.document.querySelector(`#at-${activeObj.id}-css`);
            }
            return self.advancedCSSRenderCustomCSS(activeObj, value, override);
            
        }


        // Custom
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        const override = {
            'Frontend': x.document.querySelector(`#at-${activeObj.id}-css`),
            'Builder': document.querySelector(`#at-${activeObj.id}-css`),
        };

        self.advancedCSSRenderCustomCSS(activeObj, value, override);
    },
    advancedCSSRenderPageCSS: function(activeObj, value){
        const self = this;
        const pageSettings = self.vueState.pageSettings;
        const targetCss = self.vueState.breakpointActive === "desktop" ? "customCss" : `customCss:${self.vueState.breakpointActive}`;
        if (value === "") {
            self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));
            setTimeout(() => {
                delete pageSettings[targetCss];
                activeObj.contentCss = "";
            }, 10);
            if(activeObj.type !== "css") {
                setTimeout(() => {
                    delete pageSettings['customSass'];
                    activeObj.contentSass = "";
                }, 10);
            }
        } else if(value) {
            if(activeObj.type !== "css"){
                const dataOptions = { indent_size: 2 }
                pageSettings['customSass'] = value;
                activeObj.contentSass = value;

                // Compiled CSS
                const sass = self.sassInstances[0];
                sass.compile( self.advancedCSSStates.partials+value, function(result) {
                    if (result.status === 0) {
                        self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));
                        const strippedComment = self.helpers.removeCommentedCSS(result.text) ? self.helpers.removeCommentedCSS(result.text) : false;
                            if(strippedComment){
                                const compiledFromSass = css_beautify( strippedComment, dataOptions);
                                pageSettings[targetCss] = compiledFromSass;
                                activeObj.contentCss = compiledFromSass;
                            }
                    } else {
                        self.advancedCSSHandleError(result, document.querySelector('#advancedCSSUI__panel'))
                    }
                });
            } else {
                pageSettings[targetCss] = value;
                activeObj.contentCss = value;
            }
        }
    },

    advancedCSSRenderGlobalCSS: function(activeObj, value){
        const self = this;
        const globalSettings = self.vueState.globalSettings;
    
        if (value === "") {
            self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));
            setTimeout(() => {
                delete globalSettings['customCss'];
                activeObj.contentCss = "";
            }, 10);
            if (activeObj.type !== "css") {
                setTimeout(() => {
                    activeObj.contentSass = "";
                }, 10);
            }
        } else if(value){
            if (activeObj.type !== "css") {
                const dataOptions = { indent_size: 2 };
                activeObj.contentSass = value;
    
                // Compile the Sass code
                const sass = self.sassInstances[0];
                sass.compile(self.advancedCSSStates.partials + value, function(result) {
                    if (result.status === 0) {
                        self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));
                        const strippedComment = self.helpers.removeCommentedCSS(result.text) ? self.helpers.removeCommentedCSS(result.text) : false;
                        if (strippedComment) {
                            const compiledFromSass = css_beautify(strippedComment, dataOptions);
                            globalSettings['customCss'] = compiledFromSass;
                            activeObj.contentCss = compiledFromSass;
                        }
                    } else {
                        self.advancedCSSHandleError(result, document.querySelector('#advancedCSSUI__panel'));
                    }
                });
            } else {
                globalSettings['customCss'] = value;
                activeObj.contentCss = value;
            }
        }
    },
    
    advancedCSSRenderChildCSS: function(activeObj, value){
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        let override = x.document.querySelector('#at-child-override');

        // update object
        if(value === ""){
            activeObj.contentCss = "";
        } else if(value){
            activeObj.contentCss = value;
        }

        // Update style
        setTimeout(() => {
            // Update style
            if (value === "") {
                if(override) override.remove();
            } else if(value){
                if(!override) {
                    const newStyle = document.createElement('style');
                    newStyle.id = "at-child-override";
                    x.document.head.appendChild(newStyle);
                    override = x.document.querySelector('#at-child-override');
                }
                override.innerHTML = activeObj.contentCss;
            }
        },5)
    },
    advancedCSSRenderPartials: function(activeObj, value){
        const self = this;
        if (value === "") {
            self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));
            setTimeout(() => {
                activeObj.contentSass = "";
            }, 10);
        } else if(value) {
            // Check is sass is ok
            activeObj.contentSass = value;

            const partials = brxcAdvancedCSSDefault.filter(el => el && el.type === "scssp" && el.status == "1" && el.contentSass).map(el => el.contentSass).join('');

            const sass = self.sassInstances[0];
            sass.compile(partials, function(result) {
                if (result.status === 0) {
                    self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));

                    // Regenerate partials
                    self.compilePartials(self.advancedCSSStates);
                    self.compilePartialsVariables(self.advancedCSSStates);

                    // Rerender custom sass files
                    brxcAdvancedCSSDefault.forEach(item => {
                        if(item.category === "custom" && item.type === "scss"  && item.contentSass !== ''){
                            self.advancedCSSRenderValue(item,item.contentSass);
                        }
                    })
                } else {
                    self.advancedCSSHandleError(result, document.querySelector('#advancedCSSUI__panel'))
                }
            });
        }
    },
    advancedCSSRenderCustomCSS: function(activeObj, value, override){
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        // update object
        if(value === ""){
            // Empty value
            activeObj.contentCss = "";
            if(activeObj.type !== "css") activeObj.contentSass = "";
            self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));
        } else if(value){
            if(activeObj.type !== "css"){
                activeObj.contentSass = value;
                const dataOptions = { indent_size: 2 }

                const sass = self.sassInstances[0];
                sass.compile( self.advancedCSSStates.partials+value, function(result) {
                    
                    // Compiled CSS
                    if (result.status === 0) {
                        self.advancedCSSRemoveError(document.querySelector('#advancedCSSUI__panel'));
                        const strippedComment = self.helpers.removeCommentedCSS(result.text) ? self.helpers.removeCommentedCSS(result.text) : false;
                        if(strippedComment){
                            const compiledFromSass = css_beautify( strippedComment, dataOptions);
                            activeObj.contentCss = compiledFromSass;
                        }
                    } else {
                        self.advancedCSSHandleError(result, document.querySelector('#advancedCSSUI__panel'))
                    }
                });
                    
            } else {
                activeObj.contentCss = value;
            }
        }

        // Update style
        setTimeout(() => {
            for (let key in override){
                let currentOverride = override[key];
                if (value === "" || activeObj.status == "0" || activeObj[`enqueue${key}`] == "0") {
                    if(currentOverride) currentOverride.remove();
                } else {
                    if (!currentOverride || currentOverride.tagName.toLowerCase() === 'link') {
                        if (currentOverride) currentOverride.remove();
    
                        // if style is enabled
                        if(activeObj.status == "1"){
                            const newStyle = document.createElement('style');
                            newStyle.id = `at-${activeObj.id}-css`;
                            const doc = key === "Frontend" ? x.document : document;
                            doc.head.appendChild(newStyle);
                            currentOverride = doc.querySelector(`#at-${activeObj.id}-css`);
                        }
                    }
                    if(activeObj.status == "1" && currentOverride) {
                        
                        currentOverride.innerHTML = activeObj.contentCss 
                    } else if(activeObj.status == "0" && currentOverride) {
                        currentOverride.remove();
                    }
                    
                }
            }
        }, 5)
    },
    advancedCSSHandleError: function(result, wrapper){
        if(!wrapper) return;

        const messageWrapper = wrapper.querySelector('.brxc-error-handling');
        if(!messageWrapper) return;

        messageWrapper.innerHTML = `Error: ${result.message}`;
        messageWrapper.classList.remove('success');
        messageWrapper.classList.add('visible')
        messageWrapper.classList.add('error')

    },
    advancedCSSRemoveError: function(wrapper){
        if(!wrapper) return;

        const errorWrapper = wrapper.querySelector('.brxc-error-handling.error');
        const messageWrapper = wrapper.querySelector('.brxc-error-handling');
        if(!errorWrapper || !messageWrapper) return;

        messageWrapper.classList.remove('error');
        messageWrapper.innerHTML = 'CSS correctly compiled and saved!';
        messageWrapper.classList.add('success');
    },
    regenerateAdvancedCSS: async function(target) {
        const self = this;
        target.classList.add('disable');
    
        // Compile partials
        self.compilePartials(self.advancedCSSStates);
        self.compilePartialsVariables(self.advancedCSSStates);
    
        const renderPromises = [];
    
        brxcAdvancedCSSDefault.filter(item => item && item.category === "custom" && item.type !== "recipe").forEach(item => {
            item.hasChanged = true;
    
            // SASS files
            if (item.type === "scss" && item.contentSass) {
                renderPromises.push(self.advancedCSSRenderValue(item, item.contentSass));
    
            // CSS files
            } else if (item.contentCss && item.contentCss) {
                renderPromises.push(self.advancedCSSRenderValue(item, item.contentCss));
            }
        });
    
        await Promise.all(renderPromises);
    
        self.saveAdvancedCSS(target);
    },
    saveAdvancedCSS: function(target){
        const self = this;
        target.classList.add('disable');
        const settings = brxcAdvancedCSSDefault.filter(el => el 
            && !el.id.startsWith('acss_')
            && !el.id.startsWith('php_recipe_')
            && !el.id.startsWith('community_recipe')
            && !el.id.startsWith('imported_css_')
        )
        jQuery.ajax({
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'save_advanced_css_ajax_function',
                nonce: openai_ajax_req.nonce,
                advanced_css: settings, 
            },
            method: "POST",
            success: function(data) {
                self.recompileSASStoCSS(self.vueState.globalClasses, 'globalClasses')
                    .then(() => self.recompileSASStoCSS(Array.from(self.vueState[self.helpers.getTemplateType()]), 'content'))
                    .then(() => setTimeout(() => {
                        target.classList.remove('disable');
                        self.vueGlobalProp.$_savePost();
                        brxcAdvancedCSSDefault.filter(el => el && el.hasChanged === true).forEach(el => {
                            delete el.hasChanged;
                        });
                        self.advancedCSSCat();
                    }, 500))
                    .catch(error => {
                        console.log("An error occurred during the CSS recompilation process", error);
                    });
            },
            error: function(data) {
                console.log("Error fetching data from wp_options table");
                self.vueGlobalProp.$_showMessage('Abort: An error occured - the CSS has NOT been saved Correctly!')
            }
        });
    },
    recompileSASStoCSS: function(arr, type){
        const self = this;
        return new Promise((resolve, reject) => {
            try {
                const partials = brxcAdvancedCSSDefault.filter(el => el && el.type === "scssp");
                if(!partials || partials.length === 0) return resolve();

                const changed = brxcAdvancedCSSDefault.filter(el => el && el.hasChanged === true);
                if(!changed || changed.length === 0) return resolve();

                const hasCustomSass = (settings) => Object.keys(settings).some(key => key.startsWith('_cssCustomSass'));

                const clsWithCustomCSS = arr.filter(el => el && el.hasOwnProperty('settings') && hasCustomSass(el.settings))
                if(!clsWithCustomCSS || clsWithCustomCSS.length === 0) return resolve();

                const newPartial = partials.map(el => el.contentSass).join(' ');
                clsWithCustomCSS.forEach(cls => {
                    const settings = cls.settings;
                    
                    Object.keys(settings).filter(key => key.startsWith('_cssCustomSass')).forEach(key => {
                        const value = settings[key];
                        
                        const sass = self.sassInstances[0];
                        sass.compile(newPartial + value, function(result) {
                            if (result.status === 0) {
                                const strippedComment = self.helpers.removeCommentedCSS(result.text);
                                if (strippedComment) {
                                    const compiledFromSass = css_beautify(strippedComment, { indent_size: 2 });
                                    settings[key.replace('_cssCustomSass', '_cssCustom')] = compiledFromSass;

                                    //Modified
                                    if (type === "globalClasses") self.helpers.saveChanges(type, cls.id);
                                }
                            }
                        });
                    });
                }); 
                resolve();
            } catch (error) {
                reject(error);
            }
        });
    },
    setClassShortcuts: function(){
        const self = this;

        if(!self.helpers.isElementActive()) return;

        setTimeout(() => {
            // Const
            const activeClasses = document.querySelector('#bricks-panel-element-classes .active-class');
            const x = document.querySelector('#bricks-builder-iframe').contentWindow;
            if(!activeClasses) return;

            const copyToClipboardIcon = activeClasses.querySelector('.copy-class-icon'); // Copy to clipboard icon
            const cloneClassIcon = activeClasses.querySelector('.clone-class-icon'); // Clone Class Icon
            const importSylesicon = activeClasses.querySelector('.copy-class-to-id-icon'); // Import Styles from ID
            const exportStylesIcon = activeClasses.querySelector('.copy-id-to-class-icon'); // Export Styles to the ID
            const classContextualMenuIcon = activeClasses.querySelector('.class-contextual-menu-icon'); // Class Contextual Menu 
            const countClassesIcon = activeClasses.querySelector('#brxcNumClasses'); // Count Classes
            const plainClassesIcon = activeClasses.querySelector('.plain-classes-icon'); // Plain Classes

            // Remove Icon
            if(countClassesIcon) countClassesIcon.remove();
            if(copyToClipboardIcon) copyToClipboardIcon.remove();
            if(cloneClassIcon) cloneClassIcon.remove();
            if(exportStylesIcon) exportStylesIcon.remove();
            if(importSylesicon) importSylesicon.remove();
            if(classContextualMenuIcon) classContextualMenuIcon.remove();
            if(plainClassesIcon) plainClassesIcon.remove();



            // Icons that are always added - START
            // Plain Classes
            if(Object.values(self.globalSettings.elementShortcutIcons).includes("plain-classes")){
                const balloon = self.globalSettings.openPlainClassByDefault ? false : 'Plain Classes';
                const balloonPos = self.globalSettings.openPlainClassByDefault ? false : 'top-right';
                self.addIconToFields('div','plain-classes-icon', false, balloon, balloonPos, 'event.preventDefault();event.stopPropagation();ADMINBRXC.openPlainClassesModal(event, "#brxcPlainClassesOverlay")', false,  "<span class='symbol counter'>P</span>", activeClasses, 'child');
            }

            // Icons only available on Element ID
            if(!self.helpers.isClassActive()){

                // Export Styles to ID
                if(Object.values(self.globalSettings.elementShortcutIcons).includes("export-styles-to-class")){
                    self.addIconToFields('div','copy-id-to-class-icon', false, 'Export the styles to a class', 'top-right', 'ADMINBRXC.exportIDStylestoClass()', false,  "<span class='symbol counter'><i class='fas fa-file-export' title='fas fa-file-export'></i></span>", activeClasses, 'child');
                    const newExportStylesIcon = activeClasses.querySelector('.copy-id-to-class-icon');
                    newExportStylesIcon.addEventListener('click', (e) => e.stopPropagation());
                }
            }

            // Icons only available on classes
            if(self.helpers.isClassActive()){

                // Count Classes
                const classes = x.document.querySelectorAll('.' + self.vueState.activeClass.name);
                if(Object.values(self.globalSettings.classFeatures).includes("count-classes") && classes.length > 0){
                    const symbolIcon = activeClasses.querySelector('.active-class .symbol.counter');
                    const numClassesHTML = `<span id="brxcNumClasses" class="symbol counter" data-balloon="Used class on page" data-balloon-pos="top-right">${classes.length}</span>`;
                    symbolIcon.insertAdjacentHTML('afterend', numClassesHTML);

                    const newCountClassesIcon = activeClasses.querySelector('#brxcNumClasses');

                    let i = 0;
                    newCountClassesIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        classes[i].scrollIntoView({ behavior: "smooth"});
                        (i === classes.length - 1) ? i = 0 : i++;
                    })
                }

                // Copy Class to clipboard
                if(Object.values(self.globalSettings.elementShortcutIcons).includes("copy-class-to-clipboard")) {
                    self.addIconToFields('div','copy-class-icon', false, 'Copy Class to Clipboard', 'top-right', `ADMINBRXC.copytoClipboardSimple('${self.vueState.activeClass.name}','"${self.vueState.activeClass.name}" successfully copied to clipboard')`, false,  '<span class="symbol counter"><i class="fas fa-clipboard"></i></span', activeClasses, 'child');
                    const newCopyToClipboardIcon = activeClasses.querySelector('.copy-class-icon');
                    newCopyToClipboardIcon.addEventListener('click', (e) => e.stopPropagation());
                }

                // Import Styles from ID
                if(Object.values(self.globalSettings.elementShortcutIcons).includes("export-styles-to-class") && !self.vueGlobalProp.$_isLocked(self.vueState.activeClass.id)){
                    self.addIconToFields('div','copy-class-to-id-icon', false, 'Import styles from the ID element', 'top-right', '', false,  "<span class='symbol counter'><i class='fas fa-file-import' title='fas fa-file-import'></i></span>", activeClasses, 'child');
                    const newimportSylesicon = activeClasses.querySelector('.copy-class-to-id-icon');
                    newimportSylesicon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        self.vueState.brxcShowImportInput = true;
                        newimportSylesicon.remove();
                    })

                    if (self.vueState.brxcShowImportInput === true){
                        const newimportSylesiconHTML = `<span class='symbol counter'><i class='fas fa-file-import' title='fas fa-file-import'></i></span>`;
                        newimportSylesicon.innerHTML = `<span class='symbol counter'><i class='fas fa-check' title='fas fa-check'></i></span>`;
                        newimportSylesicon.setAttribute("onClick", "ADMINBRXC.importIDStylestoClass();ADMINBRXC.vueState.brxcShowImportInput = false");
                        newimportSylesicon.setAttribute("data-balloon", "Confirm?");
                        setTimeout(() => {
                            newimportSylesicon.innerHTML = newimportSylesiconHTML;
                            self.vueState.brxcShowImportInput = false
                        }, 2000)
                    }
                }

                // Clone Class
                if(Object.values(self.globalSettings.elementShortcutIcons).includes("clone-class")){
                    self.addIconToFields('div','clone-class-icon', false, 'Clone class', 'top-right', 'ADMINBRXC.cloneClass()', false,  '<span class="symbol counter"><i class="fa-solid fa-clone"></i></span', activeClasses, 'child');
                    const newCloneClassIcon = activeClasses.querySelector('.clone-class-icon');
                    newCloneClassIcon.addEventListener('click', (e) => e.stopPropagation());
                }
            }
            
            // Icons that are always added - END
            // Class Contextual Menu
            if(Object.values(self.globalSettings.elementShortcutIcons).includes("class-contextual-menu")){
                self.addIconToFields('div','class-contextual-menu-icon', false, 'Class Contextual Menu', 'top-right', 'event.stopPropagation();ADMINBRXC.openClassContextualMenu()', false,  '<span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg" style="rotate: 90deg;"><path d="M3,9.5l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Zm5,0l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Zm5,0l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Z" fill="currentColor" fill-rule="evenodd"></path></svg></span>', activeClasses, 'child');
            }
            
        
        }, 0);
    },
    // scopedVariablesCSS: function(){
    //     const self = this;
    //     const x = document.querySelector('#bricks-builder-iframe').contentWindow;
    //     let css = '';
    //     let xStylesheet = x.document.querySelector('#brxcScopedVariables');
    //     if(!xStylesheet){
    //         const el = document.createElement('style');
    //         el.id = 'brxcScopedVariables';
    //         const xHead = x.document.head;
    //         xHead.appendChild(el);
    //     }
    //     xStylesheet = x.document.querySelector('#brxcScopedVariables');

    //     function addCSS(arr){
    //         let css = '';
    //         arr.forEach(el => {
    //             if(el.hasOwnProperty('title') && el.hasOwnProperty('cssVarValue')){
    //                 css += `${el.title}:${el.cssVarValue};`;
    //             }
    //         })
    //         return css;
    //     }
    //     setTimeout(() => {
    //         // Classes
    //         const globalCls = self.vueState.globalClasses.filter(el => el && el.hasOwnProperty('name') && el.hasOwnProperty('settings') && el.settings.hasOwnProperty('_scopedVariables'));
    //         if(globalCls.length > 0){
    //             globalCls.forEach(cls => {
    //                 css += `.${cls.name}{`;
    //                 const arr = cls.settings._scopedVariables;
    //                 css += addCSS(arr);
    //                 css += `}`;
    //             })
    //         }

    //         // id
    //         const contentType = self.helpers.getTemplateType();
    //         let content = Array.from(self.vueState[contentType]);
    //         const els = content.filter(el => el && el.hasOwnProperty('settings') && el.settings.hasOwnProperty('_scopedVariables'));
    //         if(els.length > 0){
    //             els.forEach(el => {
    //                 const selector = el.hasOwnProperty('_cssId') ? `#${el._cssId}` : `#brxe-${el.id}`;
    //                 css += `${selector}{`;
    //                 const arr = el.settings._scopedVariables;
    //                 css += addCSS(arr);
    //                 css += `}`;
    //             })
    //         }

    //         xStylesheet.innerHTML = css;
    //     }, 150)
    // },
    // scopedVariablesListeners: function(){
    //     const self = this;
    //     if(!self.helpers.isElementActive() || self.vueState.activePanelGroup !== "_css") return;

    //     const panelInner = document.querySelector('[data-controlkey="_scopedVariables"]');
    //     if (!panelInner) return;

    //     function handleInputChange(event) {
    //         event.target.setAttribute("data-listening", "true");
    //         self.scopedVariablesCSS();
    //     }

    //     const observer = new MutationObserver(function() {
    //             if(self.vueState.scopedVariablesObserver === true) return;
    //             self.vueState.scopedVariablesObserver = true;
    //             self.scopedVariablesCSS();
    //             setTimeout(() => {
    //                 const inputFields = panelInner.querySelectorAll('input:not([data-listening="true"])');
    //                 inputFields.forEach(input => {
    //                     input.addEventListener('input', handleInputChange);
    //                 });
    //             }, 150)
            
    //         setTimeout(() => self.vueState.scopedVariablesObserver = false, 300)
    //     });

    //     observer.observe(panelInner, { 
    //         subtree: true, 
    //         childList: true,
    //         attributes: true,
    //     });
    // },
    hideElementInBuilderStates: {
        els: [],
        builder: [],
        frontend: [],
    },
    hideElementInBuilderCSS: function(){
        const self = this;
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        let xStylesheet = x.document.querySelector('#brxc-hide-elements-in-builder');
        if(!xStylesheet){
            const el = document.createElement('style');
            el.id = 'brxc-hide-elements-in-builder';
            const xHead = x.document.head;
            xHead.appendChild(el);
        }
        xStylesheet = x.document.querySelector('#brxc-hide-elements-in-builder');

        const css = self.hideElementInBuilderStates.builder.length > 0 ? `${self.hideElementInBuilderStates.builder.map(el => `[data-id="${el}"]`).join(',')}{display:none !important}` : '';
        xStylesheet.innerHTML = css;
    },
    hideElementInBuilder: function(){
        const self = this;
        const structureEls = document.querySelectorAll('#bricks-structure li.element');
        if(structureEls.length < 1) return;

        let hasChanges = false;

        structureEls.forEach(el => {
            const elId = el.dataset.id;
            const elObj = self.helpers.getElementObject(elId);

            // builder
            if(elObj.settings.hasOwnProperty('hideElement')){
                if(!self.hideElementInBuilderStates.builder.includes(elId)) {
                    self.hideElementInBuilderStates.builder.push(elId);
                    hasChanges = true;
                }
                el.setAttribute('data-builder-hidden', 'true');
            } else {
                const index = self.hideElementInBuilderStates.builder.indexOf(elId);
                if(index > -1) {
                    self.hideElementInBuilderStates.builder.splice(index, 1);
                    hasChanges = true;
                }
                el.removeAttribute('data-builder-hidden');
            }
            
            // frontend
            if(elObj.settings.hasOwnProperty('unrenderFrontend')){
                if(!self.hideElementInBuilderStates.frontend.includes(elId)) {
                    self.hideElementInBuilderStates.frontend.push(elId);
                    hasChanges = true;
                }
                el.setAttribute('data-frontend-hidden', 'true');
            } else {
                const index = self.hideElementInBuilderStates.frontend.indexOf(elId);
                if(index > -1) {
                    self.hideElementInBuilderStates.frontend.splice(index, 1);
                    hasChanges = true;
                }
                el.removeAttribute('data-frontend-hidden');
            }
        })
        if(hasChanges) self.hideElementInBuilderCSS();
    },
    activateTagManagerDropdown: function(id){
        const self = this;
        // if(id === self.structureStates.activeDropdown){
        //     self.structureStates.activeDropdown = false;
        // } else {
        //     self.structureStates.activeDropdown = id;
        // }
        self.structureStates.activeDropdown = id
        self.vueState.rerenderControls = Date.now();
    },
    structureStates: {
        activeDropdown: false,
    },
    runStructureHighlights: function() {
        const self = this;
        const settings = self.globalSettings.structurePanelGeneralTweaks;
        const structure = document.querySelector('#bricks-structure');
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        const iframeElements = x.document.querySelectorAll('.brxc-active-class');
        const draggableCls = ['bricks-draggable-item','bricks-draggable-handle','draggable'];
        if (!structure) return;
    
        const els = structure.querySelectorAll('.element');
        if (els.length < 1) return;
    
        const openToggle = `M23.025 6.64L12.5194 17.1446C12.4512 17.2129 12.3702 17.267 12.2812 17.304C12.192 17.341 12.0964 17.36 12 17.36C11.9036 17.36 11.808 17.341 11.7188 17.304C11.6298 17.267 11.5488 17.2129 11.4806 17.1446L0.975 6.64`;
        
        function returnAction(el){
            let action = el.querySelector('ul.actions');
            if (action) return action;

            el.querySelector(".title").insertAdjacentHTML("afterend", `<ul class="actions"></ul>`);
            return el.querySelector('ul.actions');
        }

        // Loop into the Structure elements
        els.forEach(el => {
            const elID = el.dataset.id;
            const elementObject = self.helpers.getElementObject(elID);
            if(!elementObject) return;

            const elementSettings = elementObject.settings
    
            // Style & Class Indicators
            if (settings.includes("styles-and-classes-indicators")) {
                el.removeAttribute('data-has-styles');
                el.removeAttribute('data-has-classes');
                if (self.helpers.elementHasStyle(elementSettings)) el.setAttribute('data-has-styles', 'true');
                if (self.helpers.elementHasClass(elementSettings)) el.setAttribute('data-has-classes', 'true');
            }

            // Highlight Classes
            if(self.globalSettings.classFeatures.includes("highlight-classes")) {
                // No Class
                if (!self.helpers.isClassActive()) {
                    el.removeAttribute('data-active-class')
                    iframeElements.forEach(el => el.classList.remove('brxc-active-class'))

                // Has Class
                } else {
                    // Structure Panel
                    el.removeAttribute('data-active-class');
                    if(self.vueGlobalProp.$_getElementGlobalClassNames(elementObject.settings).includes(self.vueState.activeClass.name)){
                        el.setAttribute('data-active-class', 'true');
                    }

                    // Iframe
                    const activeEls = x.document.querySelectorAll('.' + self.vueState.activeClass.name);
                    if(iframeElements.length > 0) iframeElements.forEach(el => el.classList.remove('brxc-active-class'))
                    if(activeEls.length < 1) return;
                    activeEls.forEach(el => el.classList.add('brxc-active-class'));
                }
            }
    
            // Highlight Nestable elements
            if (settings.includes("highlight-nestable-elements")) {
                el.removeAttribute('data-nestable');
                if (self.nestableElements.includes(elementObject.name)) el.setAttribute('data-nestable', 'true');
            }
    
            // Expand Children
            if (settings.includes("expand-all-children")) {
                const path = el.querySelector('.toggle svg path');
                if (path) {
                    const d = path.getAttribute('d');
                    const isOpened = d === openToggle;
                    let action = returnAction(el);

                    const existing = action.querySelector('.action.expand, .action.collapse');
                    if (existing) existing.remove();
                    const parent = action.closest('[data-id]');
                    const toggles = parent.querySelectorAll('.bricks-svg-wrapper.toggle');
                    if (toggles.length > 0) {
                        const liClass = isOpened ? 'collapse' : 'expand';
                        const liLabel = isOpened ? 'Collapse' : 'Expand';
                        const liFunction = isOpened ? 'ADMINBRXC.collapseAllChildren(event)' : 'ADMINBRXC.expandAllChildren(event)';
                        const liSpan = isOpened ? 
                            `<span class="bricks-svg-wrapper"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="bricks-svg"><path d="m23.25 0.748 -9 9" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="m9.75 20.998 0 -6.75 -6.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="m14.25 2.998 0 6.75 6.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="m9.75 14.248 -9 9" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></span>` : 
                            `<span class="bricks-svg-wrapper"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="bricks-svg"><path d="m9.75 14.248 -9 9" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="m23.25 7.498 0 -6.75 -6.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="m0.75 16.498 0 6.75 6.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="m23.25 0.748 -9 9" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></span>`;
                        const li = document.createElement('li');
                        li.className = `action ${liClass}`;
                        li.title = liLabel;
                        li.setAttribute('onclick', liFunction);
                        li.innerHTML = liSpan;
                        action.prepend(li);
                    };
                }
            }

            // Notes
            if(settings.includes('notes')){
                if (elementSettings.hasOwnProperty(self.noteStates.active)) {
                    let action = returnAction(el)

                    const existing = action.querySelector('.action.notes');
                    if (existing) existing.remove();
                    
                    const liSpan = `<span class="bricks-svg-wrapper"><i class="ti-comment-alt"></i></span>`;
                    const li = document.createElement('li');
                    li.className = `action notes`;
                    li.setAttribute('onmouseenter', `ADMINBRXC.showNotes(event, ${JSON.stringify(elementSettings[self.noteStates.active])})`);
                    li.setAttribute('onmouseleave', `ADMINBRXC.hideNotes()`)
                    li.innerHTML = liSpan;
                    action.append(li);
                } else {
                    const existing = el.querySelector('.action.notes');
                    if (existing) existing.remove();
                }
            }

            // Link
            if(settings.includes("link")){
                if (elementSettings.hasOwnProperty('link')) {
                    let action = returnAction(el)
                    
                    const existing = action.querySelector('.action.link');
                    if (existing) existing.remove();
                    
                    const liSpan = `<span class="bricks-svg-wrapper"><i class="ti-link"></i></span>`;
                    const li = document.createElement('li');
                    li.className = `action link`;
                    li.title = 'Has a link';
                    li.innerHTML = liSpan;
                    action.append(li);
                } else {
                    const existing = el.querySelector('.action.link');
                    if (existing) existing.remove();
                }
            }

            // Show Tags
            if (Object.values(self.globalSettings.structurePanelIcons).includes("tags")) {
                if(self.vueState.brxc.tagsView === 'none') {
                    const wrapper = el.querySelector('.brxc-tag-btn-wrapper');
                    if (wrapper) wrapper.remove();
                    structure.removeAttribute('data-tag-color');
                    
                } else {
                    const oldBtn = el.querySelector('.brxc-tag-btn-wrapper');
                    if(oldBtn) oldBtn.remove();

                    const tag = self.helpers.getElementTag(elementObject);
                    if(tag) {
                        const title = el.querySelector('.title .icon')
                        const optionType = typeof bricksData.elements[elementObject.name].controls !== "undefined" && bricksData.elements[elementObject.name].controls.hasOwnProperty('tag') ? bricksData.elements[elementObject.name].controls.tag.type : false;
                        const options = typeof bricksData.elements[elementObject.name].controls !== "undefined" && bricksData.elements[elementObject.name].controls.hasOwnProperty('tag') ? bricksData.elements[elementObject.name].controls.tag.options : false;
                        self.helpers.createTagBtn(title, tag, optionType, options, elID);

                        if(self.vueState.brxc.tagsView === 'developer'){
                            structure.setAttribute('data-tag-color', 'true');
                        }
                    }
                }
            }

            // Lock Elements Order
            if(Object.values(self.globalSettings.structurePanelIcons).includes("locked-elements")){
                self.lockDraggableElementsStates.active == 1 ? el.classList.remove(...draggableCls) : el.classList.add(...draggableCls) ;

            }
        });

        self.structureStates.activeDropdown = false;

        if (Object.values(self.globalSettings.structurePanelIcons).includes("tags")) {
            self.vueState.brxc.tagDropdownActive = false;
            self.showTagInStructurePanelCustomTags();

        }
    },
    noteStates: {
        active : 'adminNotes',
    },
    showNotes: function(event,txt){
        const element = event.target;
        const rect = element.getBoundingClientRect();
        const div = document.createElement('div');
        div.className = `brxc-notes`;
        div.innerHTML = `<span>${txt}</span>`;
        div.style.top = `${parseInt(rect.bottom)}px`; 
        div.style.left = `calc(${parseInt(rect.right)}px - 216px)`; 
        document.body.append(div);

    },  
    hideNotes: function(){
        const existingNotes = document.querySelectorAll('.brxc-notes');
        if(existingNotes) existingNotes.forEach(el => el.remove());
    },
    setCodeElementIcons: function(){
        const self = this;
        if(!self.helpers.isElementActive() || self.vueState.activePanelTab !== "content" || self.vueState.showInteractions === true || self.vueState.showConditions === true) return;

        const elementObj = self.helpers.getFinalObject(true);
        if(elementObj.name !== "code") return;

        setTimeout(() => {
            const panel = document.querySelector('#bricks-panel')
            const controls = panel.querySelectorAll(`.control.control-code .header .actions`);
            controls.forEach(control => {
                const existingIcon = control.querySelector('#brxc-expand-code-element');
                if(existingIcon) return;

                const el = document.createElement('SPAN');
                el.id = 'brxc-expand-code-element';
                el.setAttribute('data-balloon', 'Full Screen');
                el.setAttribute('data-balloon-pos', 'top-right');
                el.setAttribute('onclick', `ADMINBRXC.codeElementFullScreen(this)`);
                el.classList.add('bricks-svg-wrapper');
                el.innerHTML = `<i class="fas fa-display"></i>`;
                control.appendChild(el);
            })
        },5)
    },
    codeElementFullScreen: function(icon){
        const control = icon.closest('[data-controlkey]');
        if(!control) return;

        const cm = control.querySelector('.CodeMirror').CodeMirror;
        if(!cm) return;

        control.classList.contains('full-screen') ? control.classList.remove('full-screen') : control.classList.add('full-screen');

        setTimeout(() => {
            cm.refresh();
        },0)
    },
    syncLabelwithGlobalClassStates: {
        active: false,
        globalClasses: false,
    },
    syncLabelwithGlobalClass: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return self.syncLabelwithGlobalClassStates.active = false;

        const elementObj = self.helpers.getFinalObject(true);
        if(elementObj.hasOwnProperty('label')) return self.syncLabelwithGlobalClassStates.active = false;

        // has no global class
        if(!elementObj.settings.hasOwnProperty('_cssGlobalClasses') || elementObj.settings._cssGlobalClasses.length === 0){
            self.syncLabelwithGlobalClassStates.globalClasses = false;
        }

        // has global class
        if(elementObj.settings.hasOwnProperty('_cssGlobalClasses') && elementObj.settings._cssGlobalClasses.length > 0){
            if(self.syncLabelwithGlobalClassStates.active && elementObj.id === self.syncLabelwithGlobalClassStates.active && self.syncLabelwithGlobalClassStates.globalClasses === false){
                const cls = self.vueState.globalClasses.find(el => el.id === elementObj.settings._cssGlobalClasses[0]);
                if(!self.vueGlobalProp.$_isLocked(cls.id)){
                    elementObj.label = self.helpers.classNametoLabel(cls.name);
                }
            }
            self.syncLabelwithGlobalClassStates.globalClasses = elementObj.settings._cssGlobalClasses
        }

        // update active ID
        if(elementObj.id !== self.syncLabelwithGlobalClassStates.active){
            self.syncLabelwithGlobalClassStates.active = elementObj.id;
        }

    },
    
    quickSearchStates: {
        maxResults: 3,
    },
    openQuickSearch: function(){
        const self = this;
        const existing = document.querySelector('#brxcQuickSearch');
        if(existing) existing.remove();
        const main = document.querySelector('.brx-body.main');
        if(!main) return;

        self.quickSearchResetStates();
        self.quickSearchsetActiveElement();

        const a = document.createElement('div');
        a.id = "brxcQuickSearch";
        a.innerHTML = `<div class="brxc-overlay__search-box">
                            <div class="brxc-overlay__close-btn" onclick="this.parentElement.parentElement.remove()">
                                <i class="bricks-svg ti-close"></i>
                            </div>
                            <input type="search" class="iso-search" name="typography-search" placeholder="Search anything" data-type="textContent" oninput="ADMINBRXC.quickSearchStates.search = this.value;ADMINBRXC.renderQuickSearchResults();">
                            <div class="iso-search-icon">
                                <i class="bricks-svg ti-search"></i>
                            </div>
                            <div class="iso-reset" data-balloon="Reset" data-balloon-pos="left" onclick="ADMINBRXC.quickSearchStates.search = '';ADMINBRXC.renderQuickSearchResults();this.previousElementSibling.previousElementSibling.value = '';">
                                <i class="bricks-svg fas fa-undo"></i>
                            </div>
                        </div>
                        <div id="brxcQuickSearchResults"></div>`

        main.appendChild(a);
        const input = main.querySelector('#brxcQuickSearch .brxc-overlay__search-box input');
        const end = input.value.length;
        input.setSelectionRange(end, end);
        input.focus();

        // Listeners
        a.addEventListener('mousedown', (e) => {
            self.quickSearchHandleListeners(e, e.target);
            setTimeout(() => self.quickSearchRefocus(), 0);
        })
        a.addEventListener('keydown', (e) => {
            const allMenus = Array.from(a.querySelectorAll('#brxcQuickSearchHeader li.active'));
            const highlight = a.querySelector('#brxcQuickSearchHeader li.highlight');
            const allTypes = Array.from(a.querySelectorAll('#brxcQuickSearchResults [data-type]'));
            const selected = a.querySelector('#brxcQuickSearchResults [data-type].selected');
        
            const moveHighlight = (items, current, direction) => {
                let currentIndex = items.indexOf(current);
                let nextElement = '';
                current.classList.remove('highlight');
                if (direction === 'left') {
                    nextElement = currentIndex === 0 ? items[items.length - 1] : items[currentIndex - 1];
                } else {
                    nextElement = currentIndex === items.length - 1 ? items[0] : items[currentIndex + 1];
                }
                self.quickSearchStates.active = nextElement.dataset.active;
                self.quickSearchStates[`menu${nextElement.dataset.active}`] = true;
                self.renderQuickSearchResults();
                setTimeout(() => self.quickSearchRefocus(), 0);

            };
        
            const moveSelection = (items, current, direction) => {
                let index = items.indexOf(current);
                let nextElement = ''
                current.classList.remove('selected');
                if (direction === 'up') {
                    nextElement = index === 0 ? items[items.length - 1] : items[index - 1];
                } else {
                    nextElement = index === items.length - 1 ? items[0] : items[index + 1];
                }
                nextElement.classList.add('selected');
            };
        
            // Menus
            if (e.key === "ArrowLeft" && highlight) {
                e.preventDefault();
                moveHighlight(allMenus, highlight, 'left');
        
            } else if ((e.key === "ArrowRight" || (e.shiftKey && e.key === 'Tab')) && highlight) {
                e.preventDefault();
                moveHighlight(allMenus, highlight, 'right');
        
            // Data-type
            } else if (e.key === "Enter" && selected) {
                self.quickSearchHandleListeners(e, selected);
                setTimeout(() => self.quickSearchRefocus(), 0);
        
            } else if (e.key === "ArrowUp" && selected) {
                e.preventDefault();
                moveSelection(allTypes, selected, 'up');
        
            } else if ((e.key === "ArrowDown" || e.key === 'Tab') && selected) {
                e.preventDefault();
                moveSelection(allTypes, selected, 'down');
            }
        });

        function handleEscapeKey(e) {
            if (e.key === "Escape") {
                const quickSearch = document.querySelector('#brxcQuickSearch');
                if(quickSearch) quickSearch.remove();
                window.removeEventListener('keydown', handleEscapeKey);
                x.window.removeEventListener('keydown', handleEscapeKey);
            }
        }
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        window.addEventListener('keydown', handleEscapeKey);
        x.window.addEventListener('keydown', handleEscapeKey);      
    },
    
    quickSearchResetStates: function(){
        const self = this;
        self.quickSearchStates.search = '';
        self.quickSearchStates.active = 'all';
        self.quickSearchStates.activeControl = false;
        self.quickSearchStates.menuGlobalClasses = false;
        self.quickSearchStates.menuGlobalVariables = false;
        self.quickSearchStates.menuThemeVariables = false;
        self.quickSearchStates.menuElements = false;
        self.quickSearchStates.menuComponents = false;
        self.quickSearchStates.menuStructure = false;
    },
    quickSearchsetActiveElement: function(){
        const self = this;
        const activeElement = document.activeElement;
        const tag = document.activeElement.tagName === "INPUT";
        const type = document.activeElement.type === "text";
        const structure = document.activeElement.closest('#bricks-structure');
        self.quickSearchStates.activeControl = activeElement && tag && type && !structure ? document.activeElement : false;
    },
    quickSearchRefocus: function(){
        const input = document.querySelector('#brxcQuickSearch .brxc-overlay__search-box input');
        if(!input) return;
        input.focus();
        input.setSelectionRange(0, input.value.length);
    },
    quickSearchHandleListeners: function(event, target){
        const self = this;
        switch(target.dataset.type){
            case 'more':
                self.quickSearchStates.active = target.dataset.cat;
                self.renderQuickSearchResults();
                break;
            case 'add-element':
                self.addElementtoStructure(event, target.dataset.name);
                break;
            case 'add-component':
                self.addComponenttoStructure(target.dataset.id, target.dataset.name);
                break;
            case 'jump-element':
                self.openElement(target.dataset.id);
                break;
            case 'add-class':
                const addClass = () => {
                    const element = self.helpers.getFinalObject(true)
                    const classId = target.dataset.id;
                    if (typeof element !== "undefined" && !element.hasOwnProperty('settings') || Object.getPrototypeOf(element.settings).length === 0) element.settings = {};
                    if (typeof element.settings !== "undefined" && !element.settings.hasOwnProperty('_cssGlobalClasses')) element.settings._cssGlobalClasses = []
                    if (typeof element.settings._cssGlobalClasses !== "undefined" && !element.settings._cssGlobalClasses.includes(classId)) element.settings._cssGlobalClasses.push(classId);
                }
                addClass();
                break;
            case 'add-new-class':
                const addNewClass = () => {
                    const newId = self.vueGlobalProp.$_generateId();
                    const clsName = self.helpers.formatForClasses(self.quickSearchStates.search);
                    self.vueState.globalClasses.push({
                        id: newId,
                        name: clsName,
                        settings: {},
                    })
                    self.helpers.saveChanges('globalClasses');
                    self.vueGlobalProp.$_showMessage(`Global Class "${clsName}" successfully created!`);

                    // Add Class to element
                    if(self.helpers.isElementActive()){
                        const element = self.helpers.getFinalObject(true)
                        if (typeof element !== "undefined" && !element.hasOwnProperty('settings') || Object.getPrototypeOf(element.settings).length === 0) element.settings = {};
                        if (typeof element.settings !== "undefined" && !element.settings.hasOwnProperty('_cssGlobalClasses')) element.settings._cssGlobalClasses = []
                        if (typeof element.settings._cssGlobalClasses !== "undefined" && !element.settings._cssGlobalClasses.includes(newId)) element.settings._cssGlobalClasses.push(newId);
                    }
                }
                addNewClass();
                break;
            case 'add-variable':
                if(self.quickSearchStates.activeControl){
                    self.quickSearchStates.activeControl.value = target.dataset.value;
                    self.quickSearchStates.activeControl.dispatchEvent(new Event('input'));

                }
            break;
            case 'add-new-global-variable':
                const addNewGlobalVariable = () => {
                    const newId = self.vueGlobalProp.$_generateId();
                    const varName = self.helpers.formatForClasses(self.quickSearchStates.search);
                    self.vueState.globalVariables.push({
                        id: newId,
                        name: varName,
                    })
                    self.helpers.saveChanges('globalVariables');
                    self.vueGlobalProp.$_showMessage(`Global Variable "--${varName}" successfully created!`);

                    // Add Variable to element
                    if(self.quickSearchStates.activeControl){
                        self.quickSearchStates.activeControl.value = `var(--${varName})`;
                        self.quickSearchStates.activeControl.dispatchEvent(new Event('input'));
                    }

                    // Open the Variable Manager
                    self.setCSSVariableManager();
                    self.openModal(false, '#brxcCSSVariableManagerOverlay');
                    setTimeout(() => {
                        const inputs = document.querySelectorAll('.brxc-global-variable-list input[type="text"].variable-value');
                        if(!inputs || inputs.length < 1) return;
                        const input = inputs[inputs.length - 1];
                        const end = input.value.length;
                        input.setSelectionRange(end, end);
                        input.focus();
                    }, 5)
                }
                addNewGlobalVariable();
            break;
            case 'add-new-theme-variable':
                const addNewThemeVariable = () => {
                    const newId = self.vueGlobalProp.$_generateId();
                    const varName = self.helpers.formatForClasses(self.quickSearchStates.search);
                    self.vueState.themeStyleSettings.general._cssVariables.push({
                        id: newId,
                        name: varName,
                    })
                    self.vueGlobalProp.$_showMessage(`Theme Variable "--${varName}" successfully created!`);

                    // Add Variable to element
                    if(self.quickSearchStates.activeControl){
                        self.quickSearchStates.activeControl.value = `var(--${varName})`;
                        self.quickSearchStates.activeControl.dispatchEvent(new Event('input'));
                    }

                    // Open the Variable Manager
                    self.setCSSVariableManager();
                    self.openModal(false, '#brxcCSSVariableManagerOverlay');
                    setTimeout(() => {
                        const inputs = document.querySelectorAll('.brxc-theme-variable-list input[type="text"].variable-value');
                        if(!inputs || inputs.length < 1) return;
                        const input = inputs[inputs.length - 1];
                        const end = input.value.length;
                        input.setSelectionRange(end, end);
                        input.focus();
                    }, 5)
                }
                addNewThemeVariable();
            break;
        }

    },
    renderQuickSearchResults: function(){
        const self = this;
        const canvas = document.querySelector('#brxcQuickSearchResults');
        let content = '';
        let header = '';

        if(self.quickSearchStates.active === "all" || self.quickSearchStates.active === "GlobalClasses") content += self.quickSearchGlobalClasses();
        if(self.quickSearchStates.active === "all" || self.quickSearchStates.active === "GlobalVariables") content += self.quickSearchGlobalVariables();
        if((self.quickSearchStates.active === "all" || self.quickSearchStates.active === "ThemeVariables") && self.helpers.isThemeVariableActive() && self.helpers.themeHasVariables()) content += self.quickSearchThemeVariables();
        if(self.quickSearchStates.active === "all" || self.quickSearchStates.active === "Elements") content += self.quickSearchElements();
        if(self.quickSearchStates.active === "all" || self.quickSearchStates.active === "Components") content += self.quickSearchComponents();
        if(self.quickSearchStates.active === "all" || self.quickSearchStates.active === "Structure") content += self.quickSearchStructure();

        if(content !== ''){
            header += '<ul id="brxcQuickSearchHeader">';
            header += `<li class="active${self.quickSearchStates.active === 'all' ? ' highlight' : ''}" data-active="all">All</li>`
            const cats = ["Global Classes","Global Variables","Theme Variables","Elements", "Components", "Structure"]
            cats.forEach(el => {
                const name = el.replaceAll(' ','');
                header += `<li class="${self.quickSearchStates[`menu${name}`] ? 'active' : ''}${self.quickSearchStates.active === name ? ' highlight' : ''}" data-active="${name}">${el}</li>`
            })
            header += '</ul>';
        }

        canvas.innerHTML = header + content;

        // Header
        header = canvas.querySelector('#brxcQuickSearchHeader');
        if(header){
            header.addEventListener('mousedown', (e) => {
                if(!e.target.classList.contains('active')) return;
                self.quickSearchStates.active = e.target.dataset.active;
                self.renderQuickSearchResults();

            })
        }

        // First active
        const firstActive = canvas.querySelector('#brxcQuickSearchResults [data-type]:not(.brxc-more)');
        if(firstActive){
            firstActive.classList.add('selected');
        }


    },
    quickSearchRerender: function(){
        const self = this;
        const existing = document.querySelector('#brxcQuickSearch');
        if(!existing) return;
        self.quickSearchsetActiveElement();
        self.renderQuickSearchResults();
    },
    quickSearchGlobalClasses: function(){
        const self = this;
        const clsName = self.helpers.formatForClasses(self.quickSearchStates.search);

        function classExists(name){
            return self.vueState.globalClasses.find(el => el && el.name === name);
        }
        const filteredArr = self.vueState.globalClasses
            .filter(el => el && self.quickSearchStates.search !== "" && el.name.toLowerCase().includes(self.quickSearchStates.search.toLowerCase()));
        content = '';
        if(filteredArr.length > 0) {
            self.quickSearchStates.menuGlobalClasses = true;
            content += `<div class="brxc-title">Global Classes</div>`;
            const finalArr = self.quickSearchStates.active === 'all' ? filteredArr.slice(0, self.quickSearchStates.maxResults) : filteredArr;
            content += finalArr
                        .map(el => `<div${self.helpers.isElementActive() ? ` data-type="add-class" data-id="${el.id}"` : ''}><i class="fab fa-html5"></i><span>.${el.name}</span></div>`)
                        .join('');
            if(self.quickSearchStates.active === 'all' && filteredArr.length > self.quickSearchStates.maxResults) content += `<div class="brxc-more" data-type="more" data-cat="GlobalClasses"><span>${filteredArr.length - self.quickSearchStates.maxResults} more match(es).</span></div>`;
            
            // Add new class
            if(!classExists(clsName)){
                content += `<div data-type="add-new-class"><span>Create new class "${clsName}"</span></div>`
            }
        } else if(self.quickSearchStates.search !== "" && !classExists(clsName)){
            self.quickSearchStates.menuGlobalClasses = true;
            content += `<div class="brxc-title">Global Classes</div>`;
            content += `<div data-type="add-new-class"><span>Create new class "${clsName}"</span></div>`
        } else {
            self.quickSearchStates.menuGlobalClasses = false;
        }

        return content;
    },
    quickSearchGlobalVariables: function(){
        const self = this;
        const varName = self.helpers.formatForClasses(self.quickSearchStates.search);

        function varExists(name){
            return self.vueState.globalVariables.find(el => el && el.name === name);
        }
        const filteredArr = self.vueState.globalVariables
            .filter(el => el && self.quickSearchStates.search !== "" && el.name.toLowerCase().includes(self.quickSearchStates.search.toLowerCase()));
        content = '';
        if(filteredArr.length > 0) {
            self.quickSearchStates.menuGlobalVariables = true;
            content += `<div class="brxc-title">Global Variables</div>`;
            const finalArr = self.quickSearchStates.active === 'all' ? filteredArr.slice(0, self.quickSearchStates.maxResults) : filteredArr;
            content += finalArr
                        .map(el => `<div${self.quickSearchStates.activeControl ? ` data-type="add-variable" data-value="var(--${el.name})"` : ''}><i class="fas fa-square-root-variable"></i><span>--${el.name}</span></div>`)
                        .join('');
            if(self.quickSearchStates.active === 'all' && filteredArr.length > self.quickSearchStates.maxResults) content += `<div class="brxc-more" data-type="more" data-cat="GlobalVariables"><span>${filteredArr.length - self.quickSearchStates.maxResults} more match(es).</span></div>`;
            
            // Add new Global Variable
            if(!varExists(varName)){
                content += `<div data-type="add-new-global-variable"><span>Create a New Global Variable "--${varName}"</span></div>`
            }
        } else if (self.quickSearchStates.search !== "" && !varExists(varName)){
            self.quickSearchStates.menuGlobalVariables = true;
            content += `<div class="brxc-title">Global Variables</div>`;
            content += `<div data-type="add-new-global-variable"><span>Create a New Global Variable "--${varName}"</span></div>`
        } else {
            self.quickSearchStates.menuGlobalVariables = false;
        }

        return content;
    },
    quickSearchThemeVariables: function(){
        const self = this;
        const varName = self.helpers.formatForClasses(self.quickSearchStates.search);

        function varExists(name){
            return self.vueState.themeStyleSettings.general._cssVariables.find(el => el && el.name === name);
        }
        const filteredArr = self.vueState.themeStyleSettings.general._cssVariables
            .filter(el => el && self.quickSearchStates.search !== "" && el.name.toLowerCase().includes(self.quickSearchStates.search.toLowerCase()));
        content = '';
        if(filteredArr.length > 0) {
            self.quickSearchStates.menuThemeVariables = true;
            content += `<div class="brxc-title">Theme Variables</div>`;
            const finalArr = self.quickSearchStates.active === 'all' ? filteredArr.slice(0, self.quickSearchStates.maxResults) : filteredArr;
            content += finalArr
                        .map(el => `<div${self.quickSearchStates.activeControl ? ` data-type="add-variable" data-value="var(--${el.name})"` : ''}><i class="fas fa-square-root-variable"></i><span>--${el.name}</span></div>`)
                        .join('');
            if(self.quickSearchStates.active === 'all' && filteredArr.length > self.quickSearchStates.maxResults) content += `<div class="brxc-more" data-type="more" data-cat="ThemeVariables"><span>${filteredArr.length - self.quickSearchStates.maxResults} more match(es).</span></div>`;

            // Add new Theme Variable
            if(!varExists(varName)){
                content += `<div data-type="add-new-theme-variable"><span>Create a New Theme Variable "--${varName}"</span></div>`
            }
        } else if (self.quickSearchStates.search !== "" && !varExists(varName)){
            self.quickSearchStates.menuThemeVariables = true;
            content += `<div class="brxc-title">Theme Variables</div>`;
            content += `<div data-type="add-new-theme-variable"><span>Create a New Theme Variable "--${varName}"</span></div>`
        } else {
            self.quickSearchStates.menuThemeVariables = false;
        }

        return content;
    },
    quickSearchElements: function(){
        const self = this;
        const filteredArr = Object.values(bricksData.elements)
            .filter(el => el && self.quickSearchStates.search !== "" && el.label.toLowerCase().includes(self.quickSearchStates.search.toLowerCase()));
        content = '';
        if(filteredArr.length > 0) {
            self.quickSearchStates.menuElements = true;
            content += `<div class="brxc-title">Add Element to the Structure</div>`;
            const finalArr = self.quickSearchStates.active === 'all' ? filteredArr.slice(0, self.quickSearchStates.maxResults) : filteredArr;
            content += finalArr
                        .map(el => `<div data-type="add-element" data-name="${el.name}"><i class="${el.icon}"></i><span>${el.label.toLowerCase()}</span></div>`)
                        .join('');
            if(self.quickSearchStates.active === 'all' && filteredArr.length > self.quickSearchStates.maxResults) content += `<div class="brxc-more" data-type="more" data-cat="Elements"><span>${filteredArr.length - self.quickSearchStates.maxResults} more match(es).</span></div>`;
        } else {
            self.quickSearchStates.menuElements = false;
        }

        return content;
    },
    quickSearchComponents: function() {
        const self = this;
        const filteredArr = self.vueState.components.map(obj => obj.elements[0])
            .filter(el => el && self.quickSearchStates.search !== "" && el.label.toLowerCase().includes(self.quickSearchStates.search.toLowerCase()));
        content = '';
        if(filteredArr.length > 0) {
            self.quickSearchStates.menuComponents = true;
            content += `<div class="brxc-title">Add Component to the Structure</div>`;
            const finalArr = self.quickSearchStates.active === 'all' ? filteredArr.slice(0, self.quickSearchStates.maxResults) : filteredArr;
            content += finalArr
                        .map(el => `<div data-type="add-component" data-id="${el.id}" data-name="${el.label}"><i class="${bricksData.elements[el.name].icon}"></i><span>${el.label}</span></div>`)
                        .join('');
            if(self.quickSearchStates.active === 'all' && filteredArr.length > self.quickSearchStates.maxResults) content += `<div class="brxc-more" data-type="more" data-cat="Components"><span>${filteredArr.length - self.quickSearchStates.maxResults} more match(es).</span></div>`;
        } else {
            self.quickSearchStates.menuComponents = false;
        }

        return content;
    },
    quickSearchStructure: function(){
        const self = this;
        let arr = self.helpers.getPageContentAndPageComponents();
        const filteredArr = arr
        .filter(el => {
            const searchTerm = self.quickSearchStates.search.toLowerCase();
            if (searchTerm === "") return false;
            const obj = el.obj;
            const elementObj = self.vueGlobalProp.$_getElementConfig(obj.name);
            const nameMatch = elementObj.label.toLowerCase().includes(searchTerm);
            const labelMatch = obj.label ? obj.label.toLowerCase().includes(searchTerm) : false;
            const globalClassMatch = obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('_cssGlobalClasses') ? obj.settings._cssGlobalClasses.some(el => self.vueGlobalProp.$_getGlobalClass(el)?.name.toLowerCase().includes(searchTerm)) : false;
            const textMatch = obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('text') ? obj.settings.text.toLowerCase().includes(searchTerm) : false;
            const idMatch = obj.id.toLowerCase().includes(searchTerm);
            const cssIdMatch = obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('_cssId') ? obj.settings._cssId.toLowerCase().includes(searchTerm) : false;
            return nameMatch || globalClassMatch || labelMatch || textMatch || idMatch || cssIdMatch;
        });

        content = '';
        if(filteredArr.length > 0) {
            self.quickSearchStates.menuStructure = true;
            content += `<div class="brxc-title">Jump to Element inside the Structure</div>`;
            const finalArr = self.quickSearchStates.active === 'all' ? filteredArr.slice(0, self.quickSearchStates.maxResults) : filteredArr;
            content += finalArr
                        .map(el => `<div data-type="jump-element" data-id="${el.obj.id}"${el.hasOwnProperty('component') ? ' class="component"' : ''}><i class="${self.vueGlobalProp.$_getElementConfig(el.obj.name).icon}"></i><span>${el.obj.hasOwnProperty('label') ? el.obj.label : self.vueGlobalProp.$_getElementConfig(el.obj.name).label} <span>(#${el.obj.hasOwnProperty('settings') && el.obj.settings.hasOwnProperty('_cssId') ? el.obj.settings._cssId : `brxe-${el.obj.id}`})<span></span></div>`)
                        .join('');
            if(self.quickSearchStates.active === 'all' && filteredArr.length > self.quickSearchStates.maxResults) content += `<div class="brxc-more" data-type="more" data-cat="Structure"><span>${filteredArr.length - self.quickSearchStates.maxResults} more match(es).</span></div>`;
        } else {
            self.quickSearchStates.menuStructure = false;
        }

        return content;
    },
    setFocusModeListener: function(){
        const self = this;
        const structure = document.querySelector('#bricks-structure');
        if(!structure) return;

        function focusModeClearAtts(){
            const focusedElement = structure.querySelector(".structure-item[data-focus='true']");
            if(focusedElement) focusedElement.removeAttribute('data-focus');
        }

        structure.addEventListener('mousedown', (e) => {
            const shortcut = self.vueState.isMac ? e.metaKey : e.ctrlKey;
            if(!shortcut) return;

            // Struture
            structure.setAttribute('data-focus-mode', 'true');
            let alert = structure.querySelector('#brxcFocusModeAlert');
            if(!alert){
                const structureHeader = structure.querySelector('#bricks-panel-header');

                // Create a new element to insert
                const newElement = document.createElement('div');
                newElement.id = 'brxcFocusModeAlert';
                newElement.innerHTML = `<div id="brxcFocusModeLabel"><i class="fas fa-crosshairs"></i>Focus Mode activated</div><div id="brxcFocusModelClose"><i class="bricks-svg ti-close"></i></div>`

                // Insert the new element after the structureHeader
                structureHeader.parentNode.insertBefore(newElement, structureHeader.nextSibling);

                const clostBtn = structure.querySelector('#brxcFocusModelClose');
                clostBtn.addEventListener('mousedown', () => {
                    focusModeClearAtts();
                    structure.removeAttribute('data-focus-mode');
                    const alert = structure.querySelector('#brxcFocusModeAlert');
                    if(alert) alert.remove();
                })
            }

            focusModeClearAtts();

            const element = e.target.closest('.structure-item');
            if(element)element.setAttribute('data-focus', 'true');
        })
    },
    lockDraggableElementsStates: {
        active: false,
    },
    setLockElements: function(){
        const self = this;
        self.lockDraggableElementsStates.active = self.globalSettings.structurePanelLockedElements;
        if(self.lockDraggableElementsStates.active == 1){
            const structure = document.querySelector('#bricks-structure');
            structure.setAttribute('data-locked-elements','true');
        }
    },
    toggleLockElementsState: function(target){
        const self = this;
        self.lockDraggableElementsStates.active = !self.lockDraggableElementsStates.active;
        const icon = target.querySelector('i');
        icon.classList = self.lockDraggableElementsStates.active == 1 ? ['ti-lock'] : ['ti-unlock']
        target.dataset.balloon = self.lockDraggableElementsStates.active == 1 ? "Elements Order Locked" : "Elements Order Unlocked";
        const structure = document.querySelector('#bricks-structure');
        self.lockDraggableElementsStates.active == 1 ? structure.setAttribute('data-locked-elements','true') : structure.removeAttribute('data-locked-elements');
    
        self.vueState.rerenderControls = Date.now();

    },
    runStateFunctions: function() {
        const self = this;
    
        // First to run
        self.helpers.isBuilderTweaksTabActive('classes-and-styles') && Object.values(self.globalSettings.classFeatures).includes("focus-on-first-class") ? self.focusOnFirstClass() : '';
        self.helpers.isBuilderTweaksTabActive('elements') && Object.values(self.globalSettings.elementShortcutIcons).includes("modified-mode") ? self.modifiedMode() : '';
    
        setTimeout(() => {
            let arr;
    
            // Global Variables
            if (self.helpers.isCSSVariablesTabActive('theme-variables')) {
                self.checkForThemeChange();
            }
    
            // Global Colors
            arr = Object.values(ADMINBRXC.globalSettings.themeSettingsTabs);
            if (arr.includes("global-colors")) {
                self.replaceColorsPalette();
            }
    
            // Builder Tweaks
            if (self.helpers.isBuilderTweaksTabActive()) {
    
                // Structure Panel
                self.runStructureHighlights();
                // arr.includes("multiselect") ? self.applyMultipleSettings() : '';
    
                // Classes
                arr = Object.values(self.globalSettings.classFeatures);
                arr.includes("locked-class-indicator") ? self.lockedClassIndicator() : '';
                arr.includes("variable-picker") ? self.addDynamicVariableIcon() : '';
                arr.includes("variable-color-picker") ? self.addDynamicColorListener() : '';
                arr.includes("autoformat-field-values") ? self.autoformatControlValues() : '';
                arr.includes("color-preview") ? self.setDynamicColorOnHover() : '';
                arr.includes("class-preview") ? self.setDynamicClassOnHover() : '';
                arr.includes("disable-id-styles") ? self.forceClassStlyes() : '';
                arr.includes("autocomplete-variable") ? self.setVariableAutocomplete() : '';
                if (arr.includes("class-indicator")) {
                    self.groupClassIndicator();
                    self.classIndicator()
                }
                arr.includes("breakpoint-indicator") ? self.breakpointIndicator() : '';
                arr.includes("sync-label") ? self.syncLabelwithGlobalClass() : '';
                // arr.includes("scoped-variables") ? self.scopedVariablesListeners() : '';
    
                // Elements
                self.setTextShortcutsWrapper();
                arr = Object.values(self.globalSettings.elementFeatures);
                arr.includes("close-accordion-tabs") ? self.setActiveStyleTabs() : '';
                arr.includes("disable-borders-boxshadows") ? self.setBorderAndBoxShadow() : '';
                arr.includes("resize-elements-icons") ? self.setElementsColumns() : '';
                arr.includes("lorem-ipsum") ? self.addDynamicLoremIcon() : '';
                arr.includes("superpower-custom-css") ? self.setSuperPowerCSS() : '';
                Object.values(self.globalSettings.defaultElementFeatures).includes('generated-code') ? self.setGeneratedCSS() : '';
                Object.values(self.globalSettings.defaultElementFeatures).includes('generated-code') ? self.setGeneratedHTML() : '';
                arr.includes("grid-builder") ? self.addGridUIIcon() : '';
                if(Object.values(self.globalSettings.defaultElementFeatures).includes("hide-remove-element")) {
                    self.hideElementInBuilder();
                    self.setHideFloatingBar();
                }
                if (arr.includes("focus-point")) {
                    self.addBgPositionIcon();
                    self.addObjPositionIcon();
                }
                arr.includes("mask-helper") ? self.addBgMaskIcon() : '';
                arr.includes("dynamic-data-modal") ? self.addDynamicDataTrigger() : '';
                if (arr.includes("copy-interactions-conditions")) {
                    self.setCopyInteractions();
                    self.setCopyConditions();
                }
                arr.includes("box-shadow-generator") ? self.setBoxShadowGenerator() : '';
                arr.includes("text-wrapper") ? self.setbasicTextOptions() : '';
                arr.includes('code-element-tweaks') ? self.setCodeElementIcons() : '';
    
                // Icon Shortcuts
                self.setClassShortcuts();
                self.addPanelHeaderIcons();
                arr = Object.values(self.globalSettings.elementShortcutIcons);
                arr.includes("tabs-shortcuts") && self.globalSettings.shortcutsTabs.length > 0 ? self.panelShortcuts() : '';
                arr.includes("pseudo-shortcut") && self.globalSettings.shortcutsIcons.length > 0 ? self.headerIconsState() : '';

                // Quick Search
                self.quickSearchRerender();
            }
    
            // AI
            self.helpers.isAIActive() && self.globalSettings.isAIApiKeyEmpty === "0" ? self.addDynamicAIIcon() : '';
    
            // Strict Editor
            self.setStrictEditorView();
    
            // Global features
            self.setGenerateGlobalQuery();
            self.setQueryList();

            // Preview
            Object.values(self.globalSettings.globalFeatures).includes('zoom-out') ? self.zoomOutRemoveDraggable() : '';
        }, 0);
    },
    
    runObserver: function() {
        const self = this;
        const panelInner = document.querySelector('#bricks-panel-inner');
        if (!panelInner) return;
    
        const observer = new MutationObserver(function(mutations) {
            let shouldSkip = false;
    
            // Check if the mutation happens inside a .CodeMirror instance
            mutations.forEach(function(mutation) {
                if (mutation.target.closest('.CodeMirror') || mutation.target.closest('.brxc-skip-remount')) {
                    shouldSkip = true;
                }
            });
    
            // Skip running the observer if a mutation happens inside .CodeMirror
            if (shouldSkip || self.vueState.brxcRunningObserver === true) return;
    
            self.vueState.brxcRunningObserver = true;
            
            self.runStateFunctions();
    
            setTimeout(() => self.vueState.brxcRunningObserver = false, 300);
        });
    
        observer.observe(panelInner, { 
            subtree: true, 
            childList: true,
        });
    },
    initObservers: function(){
        const self = this;
        // Main Observer
        self.runObserver();
    },
    setKeyboardShortcuts: function(){
        const self = this;

        const preventDefault = (e) => {
            e.preventDefault();
            e.stopPropagation();
        }
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        function runShortcuts(e){
            const shortcut = self.vueState.isMac ? e.metaKey && e.ctrlKey : e.ctrlKey && e.shiftKey;
            if(shortcut){
                switch(e.key.toLowerCase()){
                    case self.globalSettings.keyboardShortcuts.gridGuides.toLowerCase():
                        preventDefault(e);
                        self.gridGuide(document.querySelector('#bricks-toolbar li.grid-guide'));
                        break;
                    case self.globalSettings.keyboardShortcuts.xMode.toLowerCase():
                        preventDefault(e);
                        self.XCode(document.querySelector('#bricks-toolbar li.x-mode'))
                        break;
                    case self.globalSettings.keyboardShortcuts.contrastChecker.toLowerCase():
                        preventDefault(e);
                        self.contrast(document.querySelector('#bricks-toolbar li.constrast'))
                        break;
                    case self.globalSettings.keyboardShortcuts.darkmode.toLowerCase():
                        preventDefault(e);
                        self.darkMode(document.querySelector('#bricks-toolbar li.darkmode'))
                        break;
                    case self.globalSettings.keyboardShortcuts.cssStylesheets.toLowerCase():
                        preventDefault(e);
                        self.openAvancedCSSModal()
                        break;
                    case self.globalSettings.keyboardShortcuts.codepenConverter.toLowerCase():
                        preventDefault(e);
                        self.codepenImporterInit();self.openModal(false, '#brxcCodePenImporter');
                        break;
                    case self.globalSettings.keyboardShortcuts.resources.toLowerCase():
                        preventDefault(e);
                        self.openModal(false, "#brxcResourcesOverlay", false, false);
                        break;
                    case self.globalSettings.keyboardShortcuts.openai.toLowerCase():
                        preventDefault(e);
                        self.openModal(false, "#brxcGlobalOpenAIOverlay")
                        break;
                    case self.globalSettings.keyboardShortcuts.generateAIStructure.toLowerCase():
                        preventDefault(e);
                        self.generatedAIStructureInit();
                        self.openModal(false, '#brxcGenerateAIStructureOverlay');
                        break;
                    case self.globalSettings.keyboardShortcuts.brickslabs.toLowerCase():
                        preventDefault(e);
                        self.bricksLabsAPI(false, false, true);
                        self.openModal(false, "#brxcBricksLabsOverlay");
                        break;
                    case self.globalSettings.keyboardShortcuts.plainClasses.toLowerCase():
                        preventDefault(e);
                        self.helpers.isElementActive() ? self.openPlainClassesModal(e, '#brxcPlainClassesOverlay' ) : self.vueGlobalProp.$_showMessage('Abort: no element selected!');
                        break;
                    case self.globalSettings.keyboardShortcuts.nestedElemenets.toLowerCase():
                        preventDefault(e);
                        self.setCustomComponents();
                        self.openModal(false, '#brxcCustomComponentsOverlay',document.querySelector('#brxcCustomComponentsSearch input'))
                        break;
                    case self.globalSettings.keyboardShortcuts.findAndReplace.toLowerCase():
                        preventDefault(e);
                        self.helpers.isElementActive() ? self.openFindReplaceModal(e,false, '#brxcFindReplaceModal') : self.openFindReplaceModal(e,true, '#brxcFindReplaceModal');
                        break;
                    case self.globalSettings.keyboardShortcuts.colorManager.toLowerCase():
                        preventDefault(e);
                        self.setColorManager();
                        self.openModal(false, "#brxcColorManagerOverlay");
                        break;
                    case self.globalSettings.keyboardShortcuts.classManager.toLowerCase():
                        preventDefault(e);
                        self.setClassManager();
                        self.setClassManagerBulkActions();
                        self.helpers.isElementActive() && self.helpers.isClassActive() ? self.openClassInManager(self.vueState.activeClass.id) : self.openModal(false, "#brxcClassManagerOverlay");
                        break;
                    case self.globalSettings.keyboardShortcuts.variableManager.toLowerCase():
                        preventDefault(e);
                        self.openModal(false, "#brxcCSSVariableManagerOverlay");
                        self.setCSSVariableManager();
                        break;
                    case self.globalSettings.keyboardShortcuts.queryLoopManager.toLowerCase():
                        preventDefault(e);
                        self.queryManagerInit();
                        self.openModal(false,'#brxcQueryManagerOverlay');
                        break;
                    case self.globalSettings.keyboardShortcuts.promptManager.toLowerCase():
                        preventDefault(e);
                        self.promptManagerInit();
                        self.openModal(false,'#brxcPromptManagerOverlay');
                        break;
                    case self.globalSettings.keyboardShortcuts.structureHelper.toLowerCase():
                        preventDefault(e);
                        self.setStructureHelper();
                        self.openModal(false, "#brxcStructureHelper");
                        break;
                    case self.globalSettings.keyboardShortcuts.remoteTemplate.toLowerCase():
                        preventDefault(e);
                        self.openRemoteTemplatesModal();
                }
            }
        }
        document.body.addEventListener('keydown', function(e) {
            if(self.vueState.isMac ? e.metaKey && !e.shiftKey && e.key.toLowerCase() === self.globalSettings.keyboardShortcuts.quickSearch.toLowerCase() : e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === self.globalSettings.keyboardShortcuts.quickSearch.toLowerCase()){
                preventDefault(e);
                self.openQuickSearch();
            } else {
                runShortcuts(e)  
            }
        });
        x.document.body.addEventListener('keydown', function(e) {
            if(self.vueState.isMac ? e.metaKey && !e.shiftKey && e.key.toLowerCase() === self.globalSettings.keyboardShortcuts.quickSearch.toLowerCase() : e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === self.globalSettings.keyboardShortcuts.quickSearch.toLowerCase()){
                preventDefault(e);
                self.openQuickSearch();
            } else {
                runShortcuts(e)  
            }
        });
    },
    setDefaultPseudoClasses: function(){
        const self = this;
        const pseudoList = self.vueState.pseudoClasses;
        const defaultPseudo = [':before',':after',':hover', ':active', ':focus'];
        let hasNewPseudo = false;
        defaultPseudo.forEach(pseudo => {
            if (Object.values(pseudoList).indexOf(pseudo) > -1) return;
            hasNewPseudo = true;
            self.vueState.pseudoClasses.push(pseudo);
        })
        if (hasNewPseudo) self.helpers.saveChanges('pseudoClasses');
    },
    findAndReplace: function(searchValue, replaceValue, property, element, position, inclGlobalClasses){
        const self = this;
        property = property.options[property.selectedIndex].value;
        element = element.options[element.selectedIndex].value;
        let content = self.helpers.getContent();;
        let numChanges = 0;
        

        function replaceHexWithColor(obj, color) {
            let hexFound = false;
        
            if (Array.isArray(obj)) {
                for (let i = 0; i < obj.length; i++) {
                    const result = replaceHexWithColor(obj[i], color);
                    if (result.found) {
                        obj[i] = result.newValue;
                        hexFound = true;
                    }
                }
            } else if (typeof obj === "object" && obj !== null) {
                for (const key of Object.keys(obj)) {
                    const result = replaceHexWithColor(obj[key], color);
                    if (result.found) {
                        obj[key] = result.newValue;
                        hexFound = true;
                    }
                }
        
                if (obj.hasOwnProperty("hex") && obj.hex === searchValue) {
                    obj = color;
                    hexFound = true;
                    numChanges++;
                }
            }
        
            return { found: hexFound, newValue: obj };
        }

        function replaceColor(replaceColor){
            const palettes = self.vueState.colorPalette;
            let matchingColor = false;
            palettes.forEach(palette => {
                palette.colors.forEach( color => {
                    for (const [key, value] of Object.entries(color)) {
                        if (color[key] === replaceColor)  {
                            matchingColor = color;
                        }
                    }
                })
            })
            return matchingColor;
        }
        function replaceStyle(id, isGlobalClass = false){
            const color = replaceColor(replaceValue)
            const obj = isGlobalClass ? self.vueGlobalProp.$_getGlobalClass(id) : self.helpers.getElementObject(id);
            if(!obj || !obj.hasOwnProperty('settings')) return;

            for (const [key, value] of Object.entries(obj.settings)) {
                if(!self.helpers.isCSSControlKey(key)) continue ;

                if(property === "all" || key === property) {
                    // colors
                    if(color){
                        const checkColor = replaceHexWithColor(obj.settings, color);
                    } else {
                        // other
                        const oldValue = obj.settings[key];
                        obj.settings[key] = JSON.parse(JSON.stringify(value).replaceAll(searchValue, replaceValue));

                        if (JSON.stringify(oldValue) != JSON.stringify(obj.settings[key])) numChanges++;
                    }

                }
            }
   
        }

        function setStyle(obj, id) {
            // Category check
            if(element === "all" || obj.name === element){
                replaceStyle(id);
                if(inclGlobalClasses === "yes" && obj.settings.hasOwnProperty('_cssGlobalClasses')){
                    obj.settings._cssGlobalClasses.forEach(clsId => {
                        replaceStyle(clsId, true);
                    })
                }
            }
            if(Object.keys(obj.children).length > 0){
                Object.keys(obj.children).forEach(function (key){
                    const newObj = self.helpers.getElementObject(obj.children[key]);
                    setStyle(newObj, obj.children[key]);
                });
            }
        }
        if(position === "page"){
            content.forEach(child => {
                if(element === "all" || child.name === category){
                    replaceStyle(child.id);
                    if(inclGlobalClasses === "yes" && child.settings.hasOwnProperty('_cssGlobalClasses')){
                        child.settings._cssGlobalClasses.forEach(clsId => {
                            replaceStyle(clsId, true);
                        })
                    }
                }
            })
        } else {
            // active element
            const el = self.helpers.getFinalObject(true)
            const parentID = el.parent;
            if(!parentID || typeof content == "undefined") return;

            function checkParent(elemID){
                let obj;
                if(elemID !== false) obj = self.helpers.getElementObject(elemID);
                
                // sibling
                
                if(position === "siblings"){
                    obj.children.forEach(child => {
                        const obj = self.helpers.getElementObject(child);
                        if(element === "all" || obj.name === element){
                            replaceStyle(child);
                            if(inclGlobalClasses === "yes" && obj.settings.hasOwnProperty('_cssGlobalClasses')){
                                obj.settings._cssGlobalClasses.forEach(clsId => {
                                    replaceStyle(clsId, true);
                                })
                            }
                        }
                    })
                
                // children

                } else if(position === "children"){
                    obj = self.helpers.getFinalObject(true);
                    if (typeof obj === "undefined" || !obj.hasOwnProperty('children') || obj.children.length < 1) return;
                    obj.children.forEach(child => {
                        const obj = self.helpers.getElementObject(child)
                        setStyle(obj, child)
                    })

                // custom postion
                } else {
                    if (obj.name === position){
                        obj.children.forEach(child => {
                            const obj = self.helpers.getElementObject(child)
                            setStyle(obj, child)
                        })
                    } else {
                        if(obj.parent) checkParent(obj.parent);
                    }
                }
            }

            checkParent(parentID);
        }
        
        if(numChanges > 0 ){
            self.vueState.rerenderControls = Date.now();
            self.vueGlobalProp.$_showMessage(`${numChanges} styles correctly replaced!`);
        } else {
            self.vueGlobalProp.$_showMessage(`No corresponding style has been found.`);
        }
    },
    expandClass: function(type, property, category, position, erase){
        const self = this;
        let content = self.helpers.getContent();;
        category = category.options[category.selectedIndex].value;
        property = property.options[property.selectedIndex].value;

        // active element
        const el = self.helpers.getFinalObject(true)
        if (!el) return;
        const classes = el.settings._cssGlobalClasses;
        const cssClasses =  (el.settings._cssClasses) ? el.settings._cssClasses.split(' ') : false;
        if (type === "Classes" && !classes && !cssClasses) return self.vueGlobalProp.$_showMessage('No Class found on the element');
        let styles = [];
        for (const [key, value] of Object.entries(el.settings)) {
            if (self.helpers.isCSSControlKey(key)) styles.push({[key]: value});
        }
        if (type === "Styles" && styles.length < 1) return self.vueGlobalProp.$_showMessage('No Style found on the element');
        let parentID = el.parent;
        if(!parentID || typeof content == "undefined") parentID = false;

        function replaceClass(id){
            for(let i = 0; i < content.length; i++){
                for (const [key, value] of Object.entries(content[i])) {
                    if (key === 'id' && value === id) {
                        if(Object.getPrototypeOf(content[i].settings).length === 0) content[i].settings = {};

                        // classes
                        if (type === "Classes") {
                            if (typeof content[i].settings !== "undefined" && !content[i].settings.hasOwnProperty('_cssGlobalClasses') || erase === "true") content[i].settings._cssGlobalClasses = [];
                            if (typeof content[i].settings !== "undefined" && !content[i].settings.hasOwnProperty('_cssClasses') || erase === "true") content[i].settings._cssClasses = "";
                            if(classes && classes.length > 0){
                                classes.forEach(el => {
                                    if (!content[i].settings._cssGlobalClasses.includes(el)) content[i].settings._cssGlobalClasses.push(el);
                                });
                            }

                            if(cssClasses && cssClasses.length > 0){
                                cssClasses.forEach(el => {
                                    if (!content[i].settings._cssClasses.includes(el)) content[i].settings._cssClasses = `${content[i].settings._cssClasses} ${el}`;
                                });
                            }
                        }

                        // styles
                        if (type === "Styles") {
                            styles.forEach(style => {
                                for (const [key, value] of Object.entries(style)) {
                                    if(property === "all" || key === property) content[i].settings[key] = JSON.parse(JSON.stringify(value));
                                }
                            })
                        }
                    }
                }
            }
        }
        function setClass(obj, id) {
            // Category check
            if(category === "all" || obj.name === category){
                replaceClass(id);
            }
            if(Object.keys(obj.children).length > 0){
                Object.keys(obj.children).forEach(function (key){
                    const newObj = self.helpers.getElementObject(obj.children[key]);
                    setClass(newObj, obj.children[key]);
                });
            }
        }

        function checkParent(elemID){
            let obj;
            if(elemID !== false) obj = self.helpers.getElementObject(elemID);
            
            // sibling
            
            if(position === "siblings"){
                if (obj === false) return;
                obj.children.forEach(child => {
                    const obj2 = self.helpers.getElementObject(child)
                    if(category === "all" || obj2.name === category){
                        replaceClass(child);
                    }
                })

            // children

            } else if(position === "children"){
                obj =self.helpers.getFinalObject(true);
                if (typeof obj === "undefined" || !obj.hasOwnProperty('children') || obj.children.length < 1) return;
                obj.children.forEach(child => {
                    const obj = self.helpers.getElementObject(child)
                    setClass(obj, child)
                })

            // page

            } else if(position === "page"){
                content.forEach(child => {
                    if(category === "all" || child.name === category){
                        replaceClass(child.id);
                    }
                })
            
            // custom container

            } else {
                if (typeof obj === "undefined" || !obj.hasOwnProperty('children') || obj.children.length < 1) return;
                if (obj.name === position){
                    obj.children.forEach(child => {
                        const obj = self.helpers.getElementObject(child)
                        setClass(obj, child)
                    })
                } else {
                    if(obj.parent) checkParent(obj.parent);
                }
            }
        }
        checkParent(parentID);
        self.vueGlobalProp.$_showMessage(type + ' correctly extended!');
    },
    classConverterStates:{
        data: [],
        delimiter: '__',
        copyStyles: true,
        deleteStyles: false,
        syncLabels: false,
    },
    popopulateClassConverterStates: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        self.classConverterStates.active = "all";
        self.classConverterStates.category = "";
        self.classConverterStates.data = [];
        const elements = [];

        function populateElements(id, level){
            const obj = JSON.parse(JSON.stringify(self.helpers.getElementObject(id)));
            const component = self.vueGlobalProp.$_getComponentById(id);

            // Components
            if(component && typeof component === "object" && component.hasOwnProperty('id')){
                obj.level = level;
                elements.push(obj);
                level++;

                if(obj.hasOwnProperty('children') && obj.children){
                    obj.children.forEach( newId => {
                        populateElements(newId, level);
                    }) 
                }

                return;
            }

            obj.level = level;
            elements.push(obj);

            // Children
            if (obj.hasOwnProperty('children') && Array.isArray(obj.children) && obj.children.length > 0) {
                level++;
                obj.children.forEach(newId => {
                    populateElements(newId, level);
                })
            }
        }

        function checkchildren(element, arr, compId, isParent, isComponent = false){
            const active = self.classConverterStates.elements.find(el => el && el.id === element.id);
            active.componentId = compId;
            const isComponentRoot = self.helpers.isComponentRoot(active.id);
            if(isParent || isComponentRoot) active.componentParent = true;
            if(isComponentRoot || isComponent) active.isComponent = true;
            if (!element.hasOwnProperty('children') || !Array.isArray(element.children) || element.children.length < 1) return;
            element.children.forEach(id => {
                const obj = self.helpers.getElementObject(id);
                if(self.helpers.isComponentRoot(id) || (obj.settings.hasOwnProperty('classConverterComponent') && obj.settings.classConverterComponent === true)) return;
                const isComponentChild = isComponentRoot || isComponent ? true : false;
                checkchildren(obj, arr, compId, false, isComponentChild);
            })
        }

        // root loop
        populateElements(elementObj.id, 0);
        self.classConverterStates.elements = elements;

        // Root Element
        const compId = self.vueGlobalProp.$_generateId();
        let rootObj = {
            id: compId,
            basename: elementObj.hasOwnProperty('label') ? self.helpers.formatForClasses(elementObj.label) : elementObj.name,
            label: elementObj.hasOwnProperty('label') ? elementObj.label : elementObj.name,
        };

        checkchildren(elementObj, rootObj.content, compId, true);
        self.classConverterStates.data.push(rootObj);

        //component loop
        const components = elements.filter((el, index) => 
            index !== 0 && ( // Exclude comp root to avoid duplicates
                el && self.helpers.isComponentRoot(el.id) || // Bricks components
                (el.settings?.hasOwnProperty('classConverterComponent') && el.settings.classConverterComponent === true) // AT component roots
            )
        );
        components.forEach(comp => {

            const compId = self.vueGlobalProp.$_generateId();
            let newObj = {
                id: compId,
                basename: comp.hasOwnProperty('label') ? self.helpers.formatForClasses(comp.label) : comp.name,
                label: comp.hasOwnProperty('label') ? comp.label : comp.name,
            };
            checkchildren(comp, newObj.content, compId, true);
            if(!self.classConverterStates.data.includes(newObj)) self.classConverterStates.data.push(newObj);
        })
        if(self.classConverterStates.data.length === 1) self.classConverterStates.active = self.classConverterStates.data[0].id;
    },
    renderClassConverter: function(){
        const self = this;
        const canvas = document.querySelector('#brxcClassConvertCanvas');
        const activeComponent = self.classConverterStates.data.find(comp => comp && comp.id === self.classConverterStates.active);
        const delimiter = activeComponent && activeComponent.hasOwnProperty('delimiter') ? activeComponent.delimiter : self.classConverterStates.delimiter;
        const basename = activeComponent ? activeComponent.basename : '';
        const category = activeComponent && activeComponent.hasOwnProperty('category') ? activeComponent.category : self.classConverterStates.category;
        const copyStyles = activeComponent && activeComponent.hasOwnProperty('copyStyles') ? activeComponent.copyStyles : self.classConverterStates.copyStyles;
        const deleteStyles = activeComponent && activeComponent.hasOwnProperty('deleteStyles') ? activeComponent.deleteStyles : self.classConverterStates.deleteStyles;
        const syncLabels = activeComponent && activeComponent.hasOwnProperty('syncLabels') ? activeComponent.syncLabels : self.classConverterStates.syncLabels;
        let content = '';
        if(self.classConverterStates.data.length > 1){
            content += `<div class="m-top-16">
                            <label for="ClassDelimiter" class="has-tooltip">
                                <span>Components</span>
                                <div data-balloon="Select a component to apply specific settings to it." data-balloon-pos="bottom" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                            </label>
                            <div class="brxc-overlay__action-btn-wrapper">`;
            content += `<div class="brxc-overlay__action-btn${self.classConverterStates.active === "all" ? ` primary`: ''}" data-id="all" onclick="ADMINBRXC.classConverterStates.active = 'all';ADMINBRXC.renderClassConverter();">Default</div>`
            self.classConverterStates.data.forEach(el => {
                content += `<div class="brxc-overlay__action-btn${el.id === self.classConverterStates.active ? ` primary`: ''}" data-id="${el.id}" onclick="ADMINBRXC.classConverterStates.active = '${el.id}';ADMINBRXC.renderClassConverter();">${el.label}</div>`
            })
            content += `</div></div>`;
        }
        content += `<div class="input-wrapper">`
        // Basename
        content += `<div style="flex-basis: 75%;"${self.classConverterStates.data.length > 1 && self.classConverterStates.active === "all" ? 'class="disable"' : ''}>
                        <label for="ClassPrefix" class="has-tooltip">
                            <span>Basename</span>
                            <div data-balloon="Set the basename of the class. Example for BEM: 'feature' is the basename of 'feature__heading'." data-balloon-pos="bottom-left" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                        </label>
                        <input type="text" id="ClassPrefix" class="brxc-input-text m-bottom-24" value="${basename}" placeholder="Type your class prefix here." oninput="ADMINBRXC.classConverterUpdateComponent('basename', this.value);"></input>
                    </div>`
        content += `<div style="flex-basis: 25%;">
                        <label for="ClassDelimiter" class="has-tooltip">
                            <span>Delimiter</span>
                            <div data-balloon="Set the delimiter of the class. Example for BEM: '__' is the delimiter of 'feature__heading'." data-balloon-pos="bottom-right" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                        </label>
                        <input type="text" id="ClassDelimiter" class="brxc-input-text m-bottom-24" value="${delimiter}" placeholder="Type your delimiter prefix here." value="__" oninput="ADMINBRXC.classConverterUpdateComponent('delimiter', this.value)"></input>
                        </div>
                    </div>
                    <label for="classConverterPreviewCanvas">
                        <span>Preview</span>
                    </label>
                    <ul>
                    <div id="brxcClassConverterPreviewCanvas">`;
        // Preview 
        content += self.setClassConverterPreview();           
        content += `</div></ul>`;
        // Group
        content += `<label for="brxcClassConverterClassCategory" class="has-tooltip">
                        <span>Class Category <span class="brxc__light">(Optional)</span></span>
                        <div data-balloon="Set the Category of the class. The category will be added to the Class Manager." data-balloon-pos="top" data-balloon-length="medium">
                            <i class="fas fa-circle-question"></i>
                        </div>
                    </label>
                    <div id="classConverterGrpWrapper">
                        <input type="text" id="brxcClassConverterClassCategory" class="brxc-input-text m-bottom-24" value="${category}" placeholder="Type the category of the class here." oninput="ADMINBRXC.classConverterUpdateComponent('category', this.value);ADMINBRXC.autocomplete(this,Array.from(ADMINBRXC.vueState.globalClassesCategories).map(el => el && el.name),false)"></input>
                    </div>
                `;
        content += `<label class="has-tooltip">
                        <span>Copy the ID styles to the class(es)?</span>
                        <div data-balloon="Choose if the styles set on the ID level should be transfered to the generated class." data-balloon-pos="top-right" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                    </label>
                    <div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                        <input type="radio" id="clsConverter-no" name="clsConverter-copy-styles" class="brxc-input__checkbox" onclick="ADMINBRXC.classConverterUpdateComponent('copyStyles', false);"${copyStyles === false ? " checked" : ""}>
                        <label for="clsConverter-no" class="brxc-overlay__panel-inline-btns">No</label>
                        <input type="radio" id="clsConverter-yes" name="clsConverter-copy-styles" class="brxc-input__checkbox" onclick="ADMINBRXC.classConverterUpdateComponent('copyStyles', true);"${copyStyles === true ? " checked" : ""}>
                        <label for="clsConverter-yes" class="brxc-overlay__panel-inline-btns">Yes</label>
                        <input type="radio" id="clsConverter-skip" name="clsConverter-copy-styles" class="brxc-input__checkbox" onclick="ADMINBRXC.classConverterUpdateComponent('copyStyles', 'skip');"${copyStyles === "skip" ? " checked" : ""}>
                        <label for="clsConverter-skip" class="brxc-overlay__panel-inline-btns">Yes, unless the class already exists</label>
                    </div>
                    <label class="has-tooltip">
                        <span>Erase the ID styles?</span>
                        <div data-balloon="Choose if the styles set on the ID level should be erased after being transfered to the class." data-balloon-pos="top" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                    </label>
                    <div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                        <input type="radio" id="clsConverter-noo" name="clsConverter-erase-styles" class="brxc-input__checkbox" onclick="ADMINBRXC.classConverterUpdateComponent('deleteStyles', false);"${deleteStyles === false ? " checked" : ""}>
                        <label for="clsConverter-noo" class="brxc-overlay__panel-inline-btns">No</label>
                        <input type="radio" id="clsConverter-yess" name="clsConverter-erase-styles" class="brxc-input__checkbox" onclick="ADMINBRXC.classConverterUpdateComponent('deleteStyles', true);"${deleteStyles === true ? " checked" : ""}>
                        <label for="clsConverter-yess" class="brxc-overlay__panel-inline-btns">Yes</label>
                    </div>
                    <label class="has-tooltip">
                        <span>Sync Elements Labels?</span>
                        <div data-balloon="If checked, the elements label will automatically be renamed based on the corresponding class name." data-balloon-pos="top" data-balloon-length="medium"><i class="fas fa-circle-question"></i></div>
                    </label>
                    <div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24">
                        <input type="radio" id="clsConverter-sync-no" name="clsConverter-sync-labels" class="brxc-input__checkbox" onclick="ADMINBRXC.classConverterUpdateComponent('syncLabels', false);"${syncLabels === false ? " checked" : ""}>
                        <label for="clsConverter-sync-no" class="brxc-overlay__panel-inline-btns">No</label>
                        <input type="radio" id="clsConverter-sync-yes" name="clsConverter-sync-labels" class="brxc-input__checkbox" onclick="ADMINBRXC.classConverterUpdateComponent('syncLabels', true);"${syncLabels === true ? " checked" : ""}>
                        <label for="clsConverter-sync-yes" class="brxc-overlay__panel-inline-btns">Yes</label>
                    </div>`
        canvas.innerHTML = content;
    },
    setClassConverter:function(){
        const self = this;
        self.popopulateClassConverterStates();
        self.renderClassConverter();
    },
    setClassConverterPreview: function(){
        const self = this;
        let content = '';
        self.classConverterStates.elements.forEach(el =>{
            const activeComponent = self.classConverterStates.data.find(comp => comp && comp.id === el.componentId);
     
            const delimiter = activeComponent && activeComponent.hasOwnProperty('delimiter') ? activeComponent.delimiter : self.classConverterStates.delimiter;
            const basename = activeComponent.basename;
            const isParent = el.hasOwnProperty('componentParent') && el.componentParent === true;
            const isComponent = el.hasOwnProperty('isComponent') && el.isComponent === true;
            const prefix = isParent ? basename : `${basename}${delimiter}`;
            const value = isParent ? '' : el.hasOwnProperty('label') ? self.helpers.formatForClasses(el.label) : el.name;
            content += `<li style="--margin:${el.level};${isComponent ? `--builder-bg-3: var(--builder-bg-component);--builder-color-accent: var(--builder-color-component);` : ''}" class="${self.classConverterStates.active === "all" || el.componentId === self.classConverterStates.active ? 'active' : ''}${isParent ? ' parent' : ''}${isComponent ? ' component' : ''}">
                            <div class="icon" data-balloon="${bricksData.elements[el.name].label}" data-balloon-pos="top-left">
                                <i class="${bricksData.elements[el.name].icon}"></i>
                            </div>
                            <span>.${prefix}</span>`
            content += !el.hasOwnProperty('componentParent') || el.componentParent !== true ? `<input type="text" data-id="${el.id}" value="${value}" oninput="ADMINBRXC.classConverterUpdateElement(this.dataset.id, 'label', this.value)">` : '';
             content += el.hasOwnProperty('skip') && el.skip === true ? `<button data-balloon="click to include${isParent ? ' all children' : ''}" data-id="${el.id}" data-balloon-pos="left" onClick="ADMINBRXC.classConverterUpdateElement(this.dataset.id, 'skip', false${isParent ? ', true' : ''})">
                                                                                <i class="fas fa-toggle-off"></i>
                                                                            </button>
                                                                        </li>` : 
                                                                        `<button data-balloon="click to skip${isParent ? ' all children' : ''}" data-id="${el.id}" data-balloon-pos="left" onClick="ADMINBRXC.classConverterUpdateElement(this.dataset.id, 'skip', true${isParent ? ', true' : ''})">
                                                                                <i class="fas fa-toggle-on"></i>
                                                                            </button>
                                                                        </li>`;
        })
        return content;

    },
    classConverterRenderPreview: function(){
        const self = this;
        const canvas = document.querySelector('#brxcClassConverterPreviewCanvas');
        content = self.setClassConverterPreview();
        canvas.innerHTML = content;
    },
    classConverterUpdateComponent: function(prop, value){
        const self = this;
        const activeComponent = self.classConverterStates.data.find(el => el && el.id === self.classConverterStates.active);
        if(!activeComponent) {
            self.classConverterStates[prop] = value;
        } else {
            activeComponent[prop] = value;
        }
        self.classConverterRenderPreview();
    },
    classConverterUpdateElement: function(id, prop, value, isParent = false){
        const self = this;
        const activeElement = self.classConverterStates.elements.find(el => el && el.id === id);
        if(!activeElement) return console.log('active not found');

        activeElement[prop] = value;

        if(isParent){
            function applyOnChildren(parentId){
                const obj = self.helpers.getElementObject(parentId);
                const parent = self.classConverterStates.elements.find(el => el && el.id === obj.id);
                if(parent){
                    parent[prop] = value;
                    const children = parent.children;
                    if(Array.isArray(children)){
                        children.forEach(childId => {
                            applyOnChildren(childId);
                            
                        })
                    }
                }
            }
            applyOnChildren(activeElement.id);
        }

        if(prop === "skip") self.classConverterRenderPreview();
    },
    classConverter: function(){
        const self = this;

        function checkGlobalClass(classname, element, category, copyStyles, deleteStyles, syncLabels){
            let newClassID;
            let foundMatch = false;
            const obj = Array.from(self.vueState.globalClasses).find(el => el && el.name === classname);
            if(obj){
                foundMatch = true;
                newClassID = obj.id;
            }

            if(foundMatch === true && (copyStyles === "skip" || self.vueGlobalProp.$_isLocked(newClassID))) {
                return;
            }
            if(!foundMatch) {
                if(!category || category.length < 1) category = false;
                newClassID = self.vueGlobalProp.$_generateId();
                self.generateGlobalClass('', classname, category, newClassID);
                classCreated++;
            }

            // Export styles
            if(copyStyles === true || copyStyles === "skip"){
                const styles = [];
                const excludedKeys = ['icon'];
                for (const [key, value] of Object.entries(element.settings)) {
                    const prop = key.split(':')[0];
                    if( ['_cssCustom','_cssCustomSass'].includes(prop) ){
                        const dot = self.helpers.isComponentActive() ? '.' : '#';
                        let id = typeof element.settings !== "undefined" && element.settings.hasOwnProperty('_cssId') ? `${dot}${element.settings._cssId}` : `${dot}brxe-${element.id}`;
                        styles.push({[key]: value.replaceAll(id, '.' + classname)});
                        if (deleteStyles === true) {
                            delete element.settings[key];
                        }
                    } else if (!excludedKeys.includes(prop) && self.helpers.isCSSControlKey(key)) {
                        styles.push({[key]: value});
                        if (deleteStyles === true) {
                            delete element.settings[key];
                        }
                    }
                }

                const arr = Array.from(self.vueState.globalClasses).filter(el => el && el.id === newClassID);
                if(arr.length > 0){
                    arr.forEach(el => {
                        if(styles.lengh < 1) return;
                        if(!el.hasOwnProperty('settings')) el.settings = {};
                        styles.forEach((style) => {
                            for (const [key, value] of Object.entries(style)) {
                                el.settings[key] = JSON.parse(JSON.stringify(value));
                            }
                        })
                    })

                }
            }


            if (typeof element !== "undefined" && !element.hasOwnProperty('settings') || Object.getPrototypeOf(element.settings).length === 0) element.settings = {};
            if (typeof element.settings !== "undefined" && !element.settings.hasOwnProperty('_cssGlobalClasses')) element.settings._cssGlobalClasses = []
            if (typeof element.settings._cssGlobalClasses !== "undefined" && !element.settings._cssGlobalClasses.includes(newClassID)) element.settings._cssGlobalClasses.push(newClassID);

            // Sync labels
            if(syncLabels && typeof element !== "undefined"){
                element.label = self.helpers.classNametoLabel(classname);
            }

        }

        let classCreated = 0;

        const els = self.classConverterStates.elements.filter(el => el && (!el.hasOwnProperty('skip') || el.skip !== true));
        if(els.length < 1) return console.log('no elements found');
        els.forEach(el => {
            const activeComponent = self.classConverterStates.data.find(comp => comp && comp.id === el.componentId);
            const delimiter = activeComponent && activeComponent.hasOwnProperty('delimiter') ? activeComponent.delimiter : self.classConverterStates.delimiter;
            const category = activeComponent && activeComponent.hasOwnProperty('category') ? activeComponent.category : self.classConverterStates.category;
            const copyStyles = activeComponent && activeComponent.hasOwnProperty('copyStyles') ? activeComponent.copyStyles : self.classConverterStates.copyStyles;
            const deleteStyles = activeComponent && activeComponent.hasOwnProperty('deleteStyles') ? activeComponent.deleteStyles : self.classConverterStates.deleteStyles;
            const syncLabels = activeComponent && activeComponent.hasOwnProperty('syncLabels') ? activeComponent.syncLabels : self.classConverterStates.syncLabels;
            const clsName = el.hasOwnProperty('componentParent') && el.componentParent === true ? self.helpers.formatForClasses(activeComponent.basename) : self.helpers.formatForClasses(`${activeComponent.basename}${delimiter}${el.hasOwnProperty('label') ? el.label : el.name}`);
            const settings = self.helpers.getElementObject(el.id);
            checkGlobalClass(clsName, settings, category, copyStyles, deleteStyles, syncLabels);

        })

        self.vueState.rerenderControls = Date.now();
        self.vueGlobalProp.$_showMessage(`${classCreated} Classes successfully created`);
        self.closeModal({target: true}, true, '#brxcClassConverterOverlay');
    },
    hideElementStates: {
        active: true,
    },
    setHideFloatingBar: function(){
        const self = this;
        const structure = document.querySelector('#bricks-structure > main');
        if(!structure) return;

        const existing = structure.querySelector('#brxcHideFloatingBar');
        if(existing) existing.remove();

        if(!self.helpers.isElementActive() || !self.hideElementStates.active || self.vueState.activeElement.hasOwnProperty('cid')) return;
 
        const obj = self.helpers.getFinalObject(true);
        if(!obj || obj.settings.hasOwnProperty('cid')) return;

        const targetDisplay = self.helpers.createTarget('_display'); 
        const displayNone = obj && obj.settings.hasOwnProperty(targetDisplay) && obj.settings[targetDisplay] === "none";
        const hideBuilder = obj.settings.hasOwnProperty('hideElement');
        const removeFrontend = obj.settings.hasOwnProperty('unrenderFrontend');


        const bar = document.createElement('DIV');
        bar.id = 'brxcHideFloatingBar';
        bar.innerHTML = `
            <div>
                <span>Display</span>
                <i class="fas fa-toggle-${displayNone ? 'off' : 'on'}" data-toggle="display"></i>
            </div>
            <div>
                <span>Builder</span>
                <i class="fas fa-toggle-${hideBuilder ? 'off' : 'on'}" data-toggle="builder"></i>
            </div>
            <div>
                <span>Frontend</span>
                <i class="fas fa-toggle-${removeFrontend ? 'off' : 'on'}" data-toggle="frontend"></i>
            </div>
        `

        structure.appendChild(bar);
        bar.addEventListener('click', (e) => {
            if(!e.target.dataset.toggle) return;

            const toggle = e.target.dataset.toggle;
            switch(toggle){
                case 'display':
                    self.hideElement();
                    break;
                case 'builder':
                    self.hideElementBuilder();
                    break;
                case 'frontend':
                    self.removeElementFrontend();
                    break;
            }
        })
    },
    hideElement: function(){
        const self = this;
        const activeEl = self.helpers.getFinalObject(true)
        if(!activeEl.hasOwnProperty('settings')) activeEl.settings = {};
        const target = self.helpers.createTarget('_display');
        activeEl.settings.hasOwnProperty(target) ? delete activeEl.settings[target] : activeEl.settings[target] = 'none';
    },
    hideElementBuilder: function(){
        const self = this;
        const activeEl = self.helpers.getFinalObject(true)
        if(!activeEl.hasOwnProperty('settings')) activeEl.settings = {};
        activeEl.settings.hasOwnProperty('hideElement') ? delete activeEl.settings.hideElement : activeEl.settings.hideElement = true;
    },
    removeElementFrontend: function(){
        const self = this;
        const activeEl = self.helpers.getFinalObject(true)
        if(!activeEl.hasOwnProperty('settings')) activeEl.settings = {};
        activeEl.settings.hasOwnProperty('unrenderFrontend') ? delete activeEl.settings.unrenderFrontend : activeEl.settings.unrenderFrontend = true;
    },
    moveElement: function (event, position) {
        const self = this;
        const activeEl = self.helpers.getFinalObject(true);
        if (!activeEl || !activeEl.hasOwnProperty('parent')) return;
    
        let newParentId = false;
        let index = false;
        const parentObject = self.helpers.getElementObject(activeEl.parent);
        const parentChildren = parentObject?.children || [];
        const currentIndex = parentChildren.indexOf(activeEl.id);

        // Element is on root
        if(activeEl.parent === 0){
            const type = self.helpers.getTemplateType();
            const parentArr = self.vueState[type].filter(el => el && el.hasOwnProperty('parent') && el.parent === 0);
            const currentElIndex = parentArr.indexOf(activeEl);
            switch(position){
                case 'top':
                    newParentId = 0;
                    if (currentElIndex === 0) {
                        index = self.vueState[type].length - 1;
                    } else {
                        index = currentElIndex - 1
                    }
                    break;
                case 'down':
                    newParentId = 0;
                    if (currentElIndex === parentArr.length - 1) {
                        index = 0; 
                    } else {
                        index = currentElIndex + 1
                
                    }
                    break;
                case 'right':
                    const parentArrNestable = parentArr.filter(el => el === activeEl || self.vueGlobalProp.$_isNestable({ name: el.name }))
                    if(parentArrNestable.length === 1){
                        // silence
                    } else if(parentArrNestable.indexOf(activeEl) === 0){
                        const obj = parentArrNestable[1];
                        newParentId = obj.id;
                        index = 0;
                    } else {
                        const obj = parentArrNestable[parentArrNestable.indexOf(activeEl) - 1];
                        newParentId = obj.id;
                        index = obj.children.length;
                    }
                    break;
            }
        
        // Element is nested
        } else {
            switch(position){
                case 'top':
                    newParentId = activeEl.parent;
                    index = currentIndex > 0 ? currentIndex - 1 : parentChildren.length - 1;
                    break;
                case 'down':
                    newParentId = activeEl.parent;
                    index = currentIndex < parentChildren.length - 1 ? currentIndex + 1 : 0;
                    break;
                case 'right':
                    for (let i = currentIndex - 1; i >= 0; i--) {
                        const obj = self.helpers.getElementObject(parentChildren[i]);
                        if (self.vueGlobalProp.$_isNestable({ name: obj.name })) {
                            newParentId = obj.id;
                            index = obj.children.length; // End of new parent's children
                            break;
                        }
                    }
                    if (!newParentId) {
                        for (let i = currentIndex + 1; i < parentChildren.length; i++) {
                            const obj = self.helpers.getElementObject(parentChildren[i]);
                            if (self.vueGlobalProp.$_isNestable({ name: obj.name })) {
                                newParentId = obj.id;
                                index = 0; // Start of new parent's children
                                break;
                            }
                        }
                    }
                    break;
                case 'left':
                    if (parentObject.parent === 0) {
                        newParentId = 0;
                        const type = self.helpers.getTemplateType();
                        const parentIndex = self.vueState[type].filter(el => el.hasOwnProperty('parent') && el.parent === 0).indexOf(parentObject)
                        index = parentIndex + 1;
                    } else {
                        const grandParentObject = self.helpers.getElementObject(parentObject?.parent);
                        const grandParentChildren = grandParentObject?.children || [];
                        const parentIndex = grandParentChildren.indexOf(activeEl.parent);
                        if (grandParentObject) {
                            newParentId = grandParentObject.id;
                            index = parentIndex + 1;
                        }
                    }
                break;
            }
        
        }
        if (newParentId !== false && index !== undefined && index !== null && index !== false) {
            try {
                self.vueGlobalProp.$_moveElement({
                    element: activeEl,
                    parentId: newParentId,
                    index: index,
                });
    
                self.runStateFunctions();
                setTimeout(() => {
                    self.disableMoveElement();
                }, 100);
            } catch (error) {
                console.error("Failed to move element:", error);
            }
        }
    },    
    styleOverviewStates: {
        elementObj: false,
        globalClasses: [],
        structure: true,
        componentsExpanded: true,
        panel: "table",
        search: '',
        pseudo: '',
        copy: {
            type: null,
            id: null,
            styles: null,
            bpKey: null,
            pseudo: null,
        },
    },
    styleOverviewInit: function(elementObj, elementClasses = true, globalClasses = []){
        const self = this;
        if(!elementObj) return self.styleOverviewStates.panel === "table" ? self.setStyleOverview() : self.setStyleOverviewCSS();
        
        self.styleOverviewStates.elementObj = elementObj;
        if (elementClasses){
            self.styleOverviewStates.globalClasses = elementObj?.settings?.hasOwnProperty('_cssGlobalClasses') && Array.isArray(elementObj.settings._cssGlobalClasses) ? elementObj.settings._cssGlobalClasses : [];
        } else {
            self.styleOverviewStates.globalClasses = globalClasses && Array.isArray(globalClasses) ? globalClasses : [];
        }
        self.styleOverviewStates.panel === "table" ? self.setStyleOverview(true) : self.setStyleOverviewCSS();
    },
    styleOverviewCopy: function(bpKey, type, id){
        const self = this;
        let styles = [];
        const bp = Array.from(self.vueState.breakpoints).find(el => el && el.key === bpKey);

        const obj = type === 'id' ? self.helpers.getElementObject(id) : self.vueGlobalProp.$_getGlobalClass(id);
        if(!obj || !obj.hasOwnProperty('settings')) return;

        const settings = obj.settings

        for(const key of Object.keys(settings)){
            if(self.helpers.keyMatchBreakpoint(key, bpKey) && self.helpers.keyMatchPseudo(key,self.styleOverviewStates.pseudo) && self.helpers.isCSSControlKey(key.split(':')[0])) styles[key.split(':')[0]] = settings[key];

        }

        self.styleOverviewStates.copy.type = type;
        self.styleOverviewStates.copy.id = id;
        self.styleOverviewStates.copy.bpKey = bpKey;
        self.styleOverviewStates.copy.styles = styles;

        self.vueGlobalProp.$_showMessage(`Styles on ${bp.label} have been successfully copied!`)
        self.setStyleOverview();
    },
    styleOverviewPaste: function(bpKey, type, id){
        const self = this;
        const bp = Array.from(self.vueState.breakpoints).find(el => el && el.key === bpKey);
        const obj = type === 'id' ? self.helpers.getElementObject(id) : self.vueGlobalProp.$_getGlobalClass(id);
        if(!obj || !obj.hasOwnProperty('settings')) return;
        
        const settings = obj.settings
        Object.keys(self.styleOverviewStates.copy.styles).forEach(key => {
            let finalKey = key;
            if(bpKey !== "desktop") finalKey += `:${bpKey}`
            if(self.styleOverviewStates.pseudo !== '') finalKey += `:${self.styleOverviewStates.pseudo}`;

            settings[finalKey] = self.styleOverviewStates.copy.styles[key];
        })

        self.vueGlobalProp.$_showMessage(`Styles on ${bp.label} have been successfully pasted!`)
        self.setStyleOverview();
    },
    styleOverviewReset: function(bpKey, type, id){
        const self = this;
        const bp = Array.from(self.vueState.breakpoints).find(el => el && el.key === bpKey);

        const obj = type === 'id' ? self.helpers.getElementObject(id) : self.vueGlobalProp.$_getGlobalClass(id);
        if(!obj || !obj.hasOwnProperty('settings')) return;
        
        const settings = obj.settings

        Object.keys(settings).forEach(key => {
            if(self.helpers.keyMatchBreakpoint(key, bpKey) && self.helpers.keyMatchPseudo(key,self.styleOverviewStates.pseudo) && self.helpers.isCSSControlKey(key.split(':')[0])) delete settings[key];
        })

        self.vueGlobalProp.$_showMessage(`Styles on ${bp.label} have been successfully removed!`)
        self.setStyleOverview();
    },
    setStyleOverviewBPMenu: function(target){
        const self = this;
        const canvas = target.nextElementSibling;
        const table = target.closest('table');
        const type = table.dataset.table;
        const id = table.id;
        if(target.classList.contains('active')){
            target.classList.remove('active');
            canvas.innerHTML = '';
            return;
        } else {
            target.classList.add('active')
        }
       
        const bpKey = target.dataset.key;
        let content = `<ul>`;
        content += `<li onclick="ADMINBRXC.styleOverviewCopy('${bpKey}','${type}','${id}');">Copy Styles</li>`;
        if(self.styleOverviewStates.copy.styles !== null && Object.keys(self.styleOverviewStates.copy.styles).length > 0 ) content += `<li onclick="ADMINBRXC.styleOverviewPaste('${bpKey}','${type}','${id}');">Paste Styles</li>`;
        content += `<li onclick="ADMINBRXC.styleOverviewReset('${bpKey}','${type}','${id}');">Reset Styles</li>`;
        content += `</ul>`;
        canvas.innerHTML = content;

    },
    setStylTable: function(type, classId){
        const self = this;
        const breakpoints = self.vueState.breakpoints;
        const elementObject = self.styleOverviewStates.elementObj;
        const pseudo = self.styleOverviewStates.pseudo;
        const activeEl = type === "id" ? elementObject : self.vueGlobalProp.$_getGlobalClass(classId);
        if(!activeEl) return;
        const activeSettings = activeEl.settings;
        const uniqueKeys = self.helpers.stylesByPseudo(activeSettings);
        const existingKeys = [];
        const excludedKeys = ['shadeChildren', 'shadeMode', 'shadeParent', 'shadeType', 'shadeOrder', 'title'];
        let tableContent = '';

        // Create Row
        function createRow(originalObj, obj, key, prefix, path = [], nested = false) {
            let hasStyle = false
            if(excludedKeys.includes(key.split(':')[0])) return '';
    
            // Create the <tr>
            let row = `<tr class="isotope-selector">`;
            
            // If value is string, process the <td>
            if (typeof obj[key] === 'string' && !['id', 'name'].includes(key)) {
                // Prevent duplicated rows inside the table
                existingKeys.push(prefix);

                // Remove the breakpoints from the key
                key = key.split(':')[0];

                // Set the row to have styles
                noStyles = false;

                // Parse the CSS Selector
                let cssSelector;
                if (typeof bricksData.elements[elementObject.name].controls[key] !== "undefined" && Array.isArray(bricksData.elements[elementObject.name].controls[key].css) && bricksData.elements[elementObject.name].controls[key].css.length > 0) {
                    cssSelector = bricksData.elements[elementObject.name].controls[key].css[0].property
                } else {
                    switch(prefix){
                        case '_margin':
                        case '_padding':
                            cssSelector = `${self.helpers.camelCaseToHumanReadable(prefix)}-${self.helpers.camelCaseToHumanReadable(key)}`;
                            break;
                        case '_typography':
                            if(key === "raw") {
                                cssSelector = "color";
                                break;
                            }
                            cssSelector = self.helpers.camelCaseToHumanReadable(key);
                            break;
                        default: 
                        const equal = self.helpers.camelCaseToHumanReadable(prefix) === self.helpers.camelCaseToHumanReadable(key);

                        cssSelector = equal ? self.helpers.camelCaseToHumanReadable(prefix) : `${self.helpers.camelCaseToHumanReadable(prefix)} - ${self.helpers.camelCaseToHumanReadable(key)}`;
                    }
                }

                if(self.styleOverviewStates.search !== '' && !cssSelector.includes(self.styleOverviewStates.search)) return '';

                // Add the CSS Selector as first <td>
                const control = bricksData.elements[elementObject.name].controls[prefix.split(':')[0]];
                if(!control) return '';
                row +=`<td class="brxc-style-overview__css-selectors" data-click="true" data-tab="${(control.hasOwnProperty('tab')) ? control.tab : ''}" data-group="${(control.hasOwnProperty('group')) ? control.group : ''}" data-pseudo="${pseudo}">${cssSelector}</td>`;
                
                // Loop inside each breakpoints
                breakpoints.forEach(bp => {
                    // If the key is the result of a loop
                    if(nested){
                        let custompath = path.split('.');
                        bp.hasOwnProperty('key') && bp.key === "desktop" ? custompath[0] = prefix.split(':')[0] : custompath[0] = `${prefix.split(':')[0]}:${bp.key}`;
                        pseudo === '' ? '' : custompath[0] = `${custompath[0]}:${pseudo}`;
                        let target = originalObj;
                        for (let i = 0; i < custompath.length - 1; i++) {
                            if (typeof target[custompath[i]] !== "undefined") target = target[custompath[i]];
                        }
                        const finalPath = custompath.join('.');
                        let value;
                        if((target[custompath[custompath.length - 1]])){
                            value = (target[custompath[custompath.length - 1]]);
                            hasStyle = true;
                        } else {
                            value = '';
                        }
                        
                        row +=`<td><input type="text" placeholder="-" value="${(typeof value === "undefined" || !value.hasOwnProperty(key) || typeof value[key] === "undefined") ? '' : value[key]}" data-path='${finalPath}.${key}' oninput="ADMINBRXC.updateStyleOverviewValue(this.value,this.dataset.path,'${type}','${classId}')" /></td>`;
                    
                    // If the key is in the root of the object
                    } else {
                        let valuePath = (bp.hasOwnProperty('key') && bp.key === "desktop") ? key : `${key}:${bp.key}`;
                        pseudo !== '' ? valuePath = `${valuePath}:${pseudo}` : '';
                        let value;
                        if(obj[valuePath]) {
                            value = obj[valuePath];
                            hasStyle = true;
                        } else {
                            value = '';
                        };

                        row +=`<td><input type="text" placeholder="-" value="${value}" data-path='${valuePath}' oninput="ADMINBRXC.updateStyleOverviewValue(this.value,this.dataset.path,'${type}','${classId}')" /></td>`;
                    }
                })

                // Add the final <td> to the row
                row += '<td class="brxc-trash-can-col"><div class="disabled-style-icon-table trash-can" data-balloon="Delete" data-balloon-pos="left" onclick="ADMINBRXC.deleteRowStyleOverview(this);"><span class="bricks-svg-wrapper"><i class="fas fa-trash-can"></i></span></div></td></tr>';
            
            // If value is an object, loop inside the object to find a string
            } else if (typeof obj[key] === 'object') {
                const newPath = (path === key) ? key : `${path}.${key}`;
                for(const childKey of Object.keys(obj[key])){
                    createRow(originalObj, obj[key], childKey, prefix, newPath, true); 
                }
            }

            // Add the row to the table
      
            if(hasStyle) {
                return tableContent += row;
            } else {
                return;
            }
        }
          
        // Create the table
        const theadLabel = (type === "id") 
        ? `<div class="brxc-style-overview__id-tag-wrapper"><span class="brxc-style-overview__id-tag" data-click="true">#${(elementObject.settings.hasOwnProperty('_cssId')) ? elementObject.settings._cssId : 'brxe-' + elementObject.id}</span><div class="disabled-style-icon-table" data-balloon="Click to unlock styling on ID level" data-balloon-pos="bottom" onclick="ADMINBRXC.removeLockFromStyleOverview(this);"><span class="bricks-svg-wrapper"><i class="fas fa-lock"></i></span></div></div>`
        : `<span class="brxc-style-overview__class-tag locked-${self.vueGlobalProp.$_isLocked(activeEl.id)}" data-click="true">.${activeEl.name}</span>`;
        const tableClass = (type === "id") 
        ? `<table id="${elementObject.id}" class="GeneratedTable isotope-container${(self.forceClassStlyesStates.showLock || (Object.values(self.globalSettings.classFeatures).includes("disable-id-styles")) && typeof self.vueState.activeClass === "object" && Object.keys(self.vueState.activeClass).length > 0) ? ' brxc-lock-id-styles' : ''}" data-table="id">` 
        : `<table id="${activeEl.id}" class="GeneratedTable isotope-container locked-${self.vueGlobalProp.$_isLocked(activeEl.id)}" data-table="class">`;
        let table = `${tableClass}
          <thead>
            <tr class="isotope-selector always-on">
              <th>${theadLabel}</th>`;
              breakpoints.forEach(bp=> {
                table +=`<th><div class="brxc-breakpoint-wrapper"><div class="brxc-breakpoint-inner"><div class="brxc-skip-remount brxc-group-icon${(self.vueState.breakpointActive === bp.key) ? ' active' : ''}" data-balloon="${bp.label}" data-balloon-pos="bottom">${self.helpers.bpIcons(bp.icon)}</div><div class="brxc-breakpoint-settings" data-key="${bp.key}" onclick="ADMINBRXC.setStyleOverviewBPMenu(this)"><span class="bricks-svg-wrapper"><svg version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg" style="rotate: 90deg;"><path d="M3,9.5l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Zm5,0l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Zm5,0l-6.55671e-08,-1.77636e-15c-0.828427,-3.62117e-08 -1.5,-0.671573 -1.5,-1.5c3.62117e-08,-0.828427 0.671573,-1.5 1.5,-1.5l-6.55671e-08,1.77636e-15c0.828427,-3.62117e-08 1.5,0.671573 1.5,1.5c3.62117e-08,0.828427 -0.671573,1.5 -1.5,1.5Z" fill="currentColor" fill-rule="evenodd"></path></svg></span></div><div class="brxc-breakpoint-menu-canvas"></div></div></div></th>`;
              })
              table += `<th class="brxc-trash-can-col"></th>`
        table +=`</tr>
          </thead>
          <tbody>`;
          let noStyles = true;
          
          // Loop inside the values
          const arrKey = pseudo === '' ? 'no-pseudo' : pseudo;
        
          uniqueKeys[arrKey].forEach(key =>{

                // Prevent duplicated rows inside the table
                if(existingKeys.includes(key.split(':')[0])) return '';

                let prefix = key.split(':')[0];
                // Process the row creation
                createRow(activeSettings, activeSettings, key, prefix, key, false)
          })
          // return empty if there is no rows
          if(tableContent === "") {
            return '';
          }

          table += tableContent;

          // If there is no styles, print a default row
          if(noStyles) {
            table += `<tr class="isotope-selector"><td class="brxc-no-style-found">No Styles Found.</td>`;
            breakpoints.forEach(bp => {
                table +=`<td></td>`;
            })
            table += `</tr>`;
        }

        // Add closing tags to the table
        table += `</tbody></table>`;

        // Return the table
        return table;
    },
    deleteRowStyleOverview: function(target){
        const self = this;
        const tr = target.closest('tr');
        const inputs = tr.querySelectorAll('input');
        const table = target.closest('table');
        inputs.forEach(el =>{
            el.value = '';
            const evt = new Event('input');
            el.dispatchEvent(evt);
        })
        self.setStyleOverview()
    },
    removeLockFromStyleOverview: function(target){
        const self = this;
        const panel = document.querySelector('#bricks-panel-element');
        if(!panel) return;
        const icon = panel.querySelector('.disabled-style-icon');
        self.forceClassStlyesStates.showLock = false;
        (icon) ? icon.remove() : '';
        target.closest('table').classList.remove('brxc-lock-id-styles');
    },
    updateStyleOverviewValue: function(value,path, type, classId){
        const self = this;
        let activeEl = type === 'id' ? self.styleOverviewStates.elementObj : self.vueGlobalProp.$_getGlobalClass(classId);
        const activeSettings = activeEl.settings;

        if(path){
            path = path.split('.')

            let target = activeSettings;

            if(!value || value === "") {
                for (let i = 0; i < path.length - 1; i++) {
                    if(target.hasOwnProperty(path[i])) target = target[path[i]];
                }

                if (typeof target[path[path.length - 1]] !== "undefined") delete target[path[path.length - 1]];
                for(const key of Object.keys(target)){
                    if (typeof target[key] === "object" && Object.keys(target[key]).length === 0) delete target[key];
                }
            } else {
                for (let i = 0; i < path.length - 1; i++) {
                    if (!target[path[i]]) target[path[i]] = {};
                    target = target[path[i]];
                }
                target[path[path.length - 1]] = value;
            }
        }
    },

    setStyleOverviewPreview: function(){
        const self = this;

        const content = Array.from(self.helpers.getContent(true)).filter(el => el && el.parent === 0);
        const activeId = self.styleOverviewStates.elementObj.id;
        function addElement(originalElement, element, level, isComponent){
            let content = '';
            content += `<li class="${element.id === activeId ? 'active' : ''}" data-id="${originalElement.id}"${isComponent ? ` data-component="${isComponent.id}"` : ''} style="--margin:${level};${isComponent ? `--builder-bg-3: var(--builder-bg-component);` : ''}"}>
                            <div class="icon"><i class="${bricksData.elements[element.name].icon}"></i></div>
                            <span>${element.label ? element.label : bricksData.elements[element.name].label}</span>
                        </li>`;
            return content;
        }

        function checkchildren(element, level, isComponent) {
            if (element.children.length < 1 || (isComponent && self.styleOverviewStates.componentsExpanded === false)) {
                return;
            }
            level++;
        
            element.children.forEach(id => {
                const childOriginalElement = self.helpers.getElementObject(id, true);
                const settings = self.helpers.getElementObject(id);
                const childIsComponent = isComponent || 
                    (self.vueState.hasOwnProperty('components') && 
                     self.vueState.components.find(el => el.id === settings.id));
        
                output += addElement(childOriginalElement, settings, level, childIsComponent);
                checkchildren(settings, level, childIsComponent);
            });
        }

        let output = `<ul id="brxcStyleOverviewPreview" class="brxc-structure-list__wrapper ${self.structureHelperStates.expanded === true ? 'expanded' : 'collapsed'}">`;
        content.forEach(el => {
            const originalElement = self.helpers.getElementObject(el.id, true);
            const element = self.helpers.getElementObject(el.id);
            let isComponent = self.vueState.hasOwnProperty('components') && self.vueState.components.find(el => el.id === element.id);
            output += addElement(originalElement, element, 0, isComponent);
            checkchildren(element, 0, isComponent);
        })
        output += '</ul>';

        return output;

    },
    setStyleOverview: function(focus = false){
        const self = this;
        const canvas = document.querySelector('#brxcStyleOverviewOverlay #brxcStyleOverviewCanvas');
        const pseudo = self.styleOverviewStates.pseudo;

        // opening wrapper
        let content = '';
        let tables = '';
        
        content += `<div id="brxcStyleOverviewWrapper" class="${self.styleOverviewStates.structure ? 'brxc-preview' : ''}"><div id="brxcStyleOverviewBody">`;

        // Header
        if(self.styleOverviewStates.panel === "table") content += self.setStyleOverviewHeader();

        // id table
        tables += self.setStylTable("id", false, pseudo);

        //class tables
        if(self.styleOverviewStates.globalClasses){
            self.styleOverviewStates.globalClasses.forEach(el => {
                const cls = self.vueGlobalProp.$_getGlobalClass(el);
                if(!cls) return;
                tables += self.setStylTable("class", el, pseudo);
            })
        }
        if(tables !== ''){
            content += tables;
        } else {
            content += `<div class="notification" style=""><span class="bricks-svg-wrapper" data-name="no-results"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="bricks-svg"><path d="M0.75 12a11.25 11.25 0 1 0 22.5 0 11.25 11.25 0 1 0 -22.5 0Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path><path d="M15.665 18.75a0.76 0.76 0 0 0 0.744 -0.9 4.5 4.5 0 0 0 -8.818 0 0.759 0.759 0 0 0 0.744 0.9Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path><path d="m6.75 6.75 3 3 -3.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path><path d="m17.25 6.75 -3 3 3.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path></svg></span><div class="message"><p>No styles found.</p></div></div>`;
        }
        content += '</div>'

        // preview
        if(self.styleOverviewStates.structure) content += self.setStyleOverviewPreview();

        
        
        // closing wrapper
        content += '</div>';

        canvas.innerHTML = content;

        // Preview
        const previewWrapper = document.querySelector('#brxcStyleOverviewPreview');
        if(previewWrapper){
            previewWrapper.addEventListener('click', (e) => {
                const li = e.target.closest('[data-id]');
                if(!li) return;

                const id = li.dataset?.id
                if(id){
                    const elementObj = self.helpers.getElementObject(id);
                    self.styleOverviewInit(elementObj, true);
                }
            })
        }

        const body = document.querySelector('#brxcStyleOverviewBody');
        if(body){
            //click 
            body.addEventListener('click', (event) => {
                const el = event.target.closest('[data-click="true"]');
                if(!el) return;

                const table = el.closest('table');
                const tab = el.dataset.tab;
                const group = el.dataset.group;
                const pseudo = el.dataset.pseudo;
                self.vueState.activeClass = table.dataset.table === "class" ? self.vueGlobalProp.$_getGlobalClass(table.id) : '';
                self.openElement(self.styleOverviewStates.elementObj.id);

                if (!pseudo || pseudo === '') {
                    self.vueState.pseudoClassActive = '';
                    self.vueState.pseudoClassPopup = false;
                } else {
                    self.vueState.pseudoClassActive = `:${pseudo}`;
                    self.vueState.pseudoClassPopup = true;
                }
                if(group) self.vueState.activePanelGroup = group;
                if(tab) self.vueState.activePanelTab = tab;
                self.closeModal(event, event.target, '#brxcStyleOverviewOverlay');
            })

            //autocomplete
            body.addEventListener('focusin', (event) => {
                const el = event.target;
                if (el.tagName === 'INPUT' && el.closest('td')) {
                    self.autocomplete(el, self.cssVariables, "style", true);
                }
            });
        }

        //focus
        const searchInput = document.querySelector('#brxcStyleOverviewCanvas input[type="search"]');
        if(searchInput&& focus){
            searchInput.focus();
            searchInput.setSelectionRange(searchInput.value.length, searchInput.value.length);
        }

    },
    styleOverviewToggleOption: function(key){
        const self = this;
        self.styleOverviewStates[key] = !self.styleOverviewStates[key]
        self.styleOverviewInit();
    },
    setStyleOverviewHeader: function(){
        const self = this;
        const activeElement = self.styleOverviewStates.elementObj;
        const pseudo = self.styleOverviewStates.pseudo;

        function hasStyle(){
            let hasPseudo = false;
            for(const key of Object.keys(activeElement.settings)){
                const arr = key.split(':');
                if(arr[1] === undefined && self.helpers.isCSSControlKey(arr[0])) hasPseudo = true;
            }

            if(hasPseudo === true) return true;

            if(self.styleOverviewStates.globalClasses){
                self.styleOverviewStates.globalClasses.forEach(el => {
                    const obj = self.vueGlobalProp.$_getGlobalClass(el);
                    if(obj && obj.hasOwnProperty('settings')){
                        for(const key of Object.keys(obj.settings)){
                            const arr = key.split(':');
                            if(arr[1] === undefined && self.helpers.isCSSControlKey(arr[0])) hasPseudo = true;
                        }
                    }
                })
            }

            if(hasPseudo === true) return true;

            return false;
        }
        function hasPseudoStyle(pseudo){
            let hasPseudo = false;
            for(const key of Object.keys(activeElement.settings)){
                if(JSON.stringify(key).includes(pseudo)) hasPseudo = true;
            }
            if(hasPseudo === true) return true;

            if(self.styleOverviewStates.globalClasses){
                self.styleOverviewStates.globalClasses.forEach(el => {
                    const obj = self.vueGlobalProp.$_getGlobalClass(el);
                    if(obj && obj.hasOwnProperty('settings')){
                        for(const key of Object.keys(obj.settings)){
                            if(JSON.stringify(key).includes(pseudo)) hasPseudo = true;
                        }
                    }
                })
            }

            if(hasPseudo === true) return true;

            return false;

        }

        let content = '<div id="brxcStyleOverviewCanvasHeader">';
        //pseudo
        content += `<div class="brxc-overlay__panel-switcher-wrapper style-overview">
                        <input type="radio" id="style-overview-no-pseudo" name="style-overview-switch" class="brxc-input__radio" onclick="ADMINBRXC.styleOverviewStates.pseudo = '';ADMINBRXC.setStyleOverview();"${(pseudo === '') ? ' checked=""' : ''}>
                        <label for="style-overview-no-pseudo" class="brxc-input__label${hasStyle() ? ' has-style' : ''}">No Pseudo</label>`;
        self.vueState.pseudoClasses.forEach(el => {
            content += `<input type="radio" id="style-overview-${el.substr(1, el.length - 1)}" name="style-overview-switch" class="brxc-input__radio" onclick="ADMINBRXC.styleOverviewStates.pseudo = '${el.replace(':','')}';ADMINBRXC.setStyleOverview();"${(pseudo === el.replace(':','')) ? ' checked=""' : ''}>
                        <label for="style-overview-${el.substr(1, el.length - 1)}" class="brxc-input__label${hasPseudoStyle(el) ? ' has-style' : ''}"><span>${el}</span></label>`;
        })
        content += `<div class="brxc-overlay__panel-switcher-wrapper">
                        <input type="radio" id="style-overview-bricks" name="style-overview-switch-css" class="brxc-input__radio" onclick="ADMINBRXC.styleOverviewStates.panel = 'table';ADMINBRXC.styleOverviewInit();" checked>
                        <label for="style-overview-bricks" class="brxc-input__label" style="margin-left: auto"><span>Bricks</span></label>
                        <input type="radio" id="style-overview-css" name="style-overview-switch-css" class="brxc-input__radio" onclick="ADMINBRXC.styleOverviewStates.panel = 'css';ADMINBRXC.styleOverviewInit();">
                        <label for="style-overview-css" class="brxc-input__label has-style"><span>CSS</span></label>
                        <div class="brxc-header-icons ${self.styleOverviewStates.structure === true ? ' active' : ''}" data-balloon="Toggle Structure" data-balloon-pos="left" onclick="ADMINBRXC.styleOverviewToggleOption('structure')"><span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-bars-staggered"></i></span></div>
                        <div class="brxc-header-icons ${self.styleOverviewStates.componentsExpanded === true ? ' active' : ''}" data-balloon="Toggle Components" data-balloon-pos="left" onclick="ADMINBRXC.styleOverviewToggleOption('componentsExpanded')"><span class="bricks-svg-wrapper"><i class="bricks-svg fas ti-package"></i></span></div>
                    </div>`;
        content += `</div>`;

        content += '<div class="isotope-wrapper--late" data-gutter="0" data-filter-layout="fitRows" style="--col:1">';
        
        //Search

        content += `<div class="brxc-overlay__search-box"><div class="iso-search-icon"><i class="bricks-svg ti-search"></i></div><input type="search" class="iso-search" name="typography-search" placeholder="Type here to filter the CSS properties" data-type="textContent" value="${self.styleOverviewStates.search}" oninput="ADMINBRXC.styleOverviewStates.search = this.value;ADMINBRXC.setStyleOverview(true)"><div class="iso-reset" onclick="ADMINBRXC.styleOverviewStates.search = '';ADMINBRXC.setStyleOverview(true)"><i class="bricks-svg ti-close"></i></div></div>`;
        
        // Classes Buttons
        content += '<div class="brxc-style-overview__class-wrapper">';
        if(self.styleOverviewStates.globalClasses){
            self.styleOverviewStates.globalClasses.forEach(el => {
                const cls = self.vueGlobalProp.$_getGlobalClass(el);
                if(!cls) return;
                content += `<a class="brxc-style-overview__class-btn locked-${self.vueGlobalProp.$_isLocked(cls.id)}" onclick="document.getElementById('${cls.id}')?.scrollIntoView();">.${cls.name}</a>`;
            })
        }
        content += '</div></div></div>';
        return content;
    },
    setStyleOverviewCSS: function(){
        const self = this;
        const canvas = document.querySelector('#brxcStyleOverviewOverlay #brxcStyleOverviewCanvas');
        let content = '';

        content += `<div id="brxcStyleOverviewWrapper" class="${self.styleOverviewStates.structure ? 'brxc-preview' : ''}">
                        <div id="brxcStyleOverviewBody">
                            <div class="brxc-overlay__panel-switcher-wrapper">
                                <input type="radio" id="style-overview-bricks" name="style-overview-switch-css" class="brxc-input__radio" onclick="ADMINBRXC.styleOverviewStates.panel = 'table';ADMINBRXC.styleOverviewInit();">
                                <label for="style-overview-bricks" class="brxc-input__label has-style" style="margin-left: auto"><span>Bricks</span></label>
                                <input type="radio" id="style-overview-css" name="style-overview-switch-css" class="brxc-input__radio" onclick="ADMINBRXC.styleOverviewStates.panel = 'css';ADMINBRXC.styleOverviewInit();" checked>
                                <label for="style-overview-css" class="brxc-input__label"><span>CSS</span></label>
                                <div class="brxc-header-icons ${self.styleOverviewStates.structure === true ? ' active' : ''}" data-balloon="Toggle Structure" data-balloon-pos="left" onclick="ADMINBRXC.styleOverviewToggleOption('structure')"><span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-bars-staggered"></i></span></div>
                        <div class="brxc-header-icons ${self.styleOverviewStates.componentsExpanded === true ? ' active' : ''}" data-balloon="Toggle Components" data-balloon-pos="left" onclick="ADMINBRXC.styleOverviewToggleOption('componentsExpanded')"><span class="bricks-svg-wrapper"><i class="bricks-svg fas ti-package"></i></span></div>
                            </div>`;
        
        const elementObj = self.styleOverviewStates.elementObj;
        const globalClasses = self.styleOverviewStates.globalClasses

        // id table
        content += `<div class="brxc-style-overview__id-tag-wrapper" style="margin-bottom:8px;"><span class="brxc-style-overview__id-tag" data-click="true" data-balloon="Click to jump on the ID styles" data-balloon-pos="right">#${(elementObj.settings.hasOwnProperty('_cssId')) ? elementObj.settings._cssId : 'brxe-' + elementObj.id}</span></div>`;
        content += self.setStyleCSS("element", elementObj, false);

        //class tables
        if(globalClasses && Array.isArray(globalClasses) && globalClasses.length > 0){
            self.styleOverviewStates.globalClasses.forEach(el => {
                let activeEl = self.vueGlobalProp.$_getGlobalClass(el);
                if(!activeEl) return;
                content += `<div class="brxc-style-overview__id-tag-wrapper" style="margin: 20px 0 8px 0;"><span class="brxc-style-overview__class-tag locked-${self.vueGlobalProp.$_isLocked(activeEl.id)}" data-click="true" data-balloon="Click to jump on this Class styles" data-balloon-pos="right">.${activeEl.name}</span></div>`;
                content += self.setStyleCSS("globalClass", activeEl, [elementObj.name]);
            })
        }
        content += '</div>';

        // preview
        if(self.styleOverviewStates.structure) content += self.setStyleOverviewPreview();

        // closing wrapper
        content += '</div>';

        canvas.innerHTML = content;

        // Preview
        const previewWrapper = document.querySelector('#brxcStyleOverviewPreview');
        if(previewWrapper){
            previewWrapper.addEventListener('click', (e) => {
                const li = e.target.closest('[data-id]');
                if(!li) return;

                const id = li.dataset?.id
                if(id){
                    const elementObj = self.helpers.getElementObject(id);
                    self.styleOverviewInit(elementObj, true);
                }
            })
        }

        const textAreas = document.querySelectorAll('textarea.brxc-style-overview-css');
        textAreas.forEach(textarea => {
            const dataOptions = { indent_size: 2 }

            textarea.value = css_beautify(textarea.value, dataOptions);

            const options = self.codeMirrorOptions(textarea);
            options.autofocus = false;
            options.readOnly = true;

            CodeMirror.fromTextArea(textarea, self.codeMirrorOptions(options));
        })
    },
    setStyleCSS: function(type, activeEl, name){
        const self = this;
        content = `<div class="brxc-codemirror__wrapper"><textarea class="brxc-style-overview-css">${self.vueGlobalProp.$_generateCss(type, activeEl, name)}</textarea>`;
        content += `<div class="brxc-overlay__action-btn" style="margin-left: auto" onclick="ADMINBRXC.copytoClipboard(this, this.previousElementSibling.CodeMirror.getValue(), 'Copied!', 'Copy to Clipboard')"><span>Copy to Clipboard</span></div></div>`;

        return content;
    },
    setContextualMenuItems: function(){
        const self = this;
        let contextualMenu = document.querySelector("#bricks-builder-context-menu").children[0].children[0];
        let icons = '';
        if(self.helpers.isBuilderTweaksTabActive('structure-panel')){
            let arr = Object.values(self.globalSettings.structurePanelContextualMenu);
            if(arr.includes('hide-element')) {
                icons += `<li id="hideElement" onClick='ADMINBRXC.hideElement()'><span class="label">Hide Element</span>`
                if(Object.values(self.globalSettings.defaultElementFeatures).includes('hide-remove-element')) {
                    icons += `<span class="bricks-svg-wrapper action frontend" data-balloon="Remove on Frontend" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.removeElementFrontend()">F</span>`;
                    icons += `<span class="bricks-svg-wrapper action builder" data-balloon="Hide in Builder" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.hideElementBuilder()">B</span>`;
                    icons += `<span class="bricks-svg-wrapper action settings" data-balloon="Floating Bar" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.hideElementStates.active = !ADMINBRXC.hideElementStates.active;ADMINBRXC.setHideFloatingBar()"><i class="fa-solid fa-ellipsis"></i></span>`;
                }
                icons += `</li>`;
            }
            if (arr.includes('move-element')) {
                const directions = [
                    { direction: 'left', label: 'Indent Left', icon: 'fa-arrow-left' },
                    { direction: 'right', label: 'Indent Right', icon: 'fa-arrow-right' },
                    { direction: 'top', label: 'Move Up', icon: 'fa-arrow-up' },
                    { direction: 'down', label: 'Move Down', icon: 'fa-arrow-down' },
                ];
            
                const buttons = directions
                    .map(
                        ({ direction, label, icon }) => `
                        <span class="action" 
                              data-balloon="${label}" 
                              data-balloon-pos="top" 
                              onClick="event.stopPropagation();ADMINBRXC.moveElement(event, '${direction}');ADMINBRXC.vueState.showContextMenu = ADMINBRXC.vueState.activeElement?.id;">
                            <i class="fas ${icon}"></i>
                        </span>`
                    )
                    .join('');
            
                icons += `
                    <li id="moveElement">
                        <span class="label">Move</span>
                        <div class="buttons">${buttons}</div>
                    </li>`;
            }
            arr.includes('extend-classes-and-styles') ? icons += `<li id="brxcExpandClasses" onClick='ADMINBRXC.openExtendClassModal(event,"#brxcExtendModal")'>Extend Classes & Styles</li>`: '';
            arr.includes('find-and-replace-styles') ? icons += `<li id="brxcFindandReplaceStyles" onClick='ADMINBRXC.openFindReplaceModal(event,false, "#brxcFindReplaceModal")'>Find & Replace Styles</li>`: '';
            arr.includes('class-converter') ? icons += `<li id="brxcBEMConverter" onClick='ADMINBRXC.setClassConverter();ADMINBRXC.openModal(false, "#brxcClassConverterOverlay")';'><span class="label">Class Converter</span></li>` : '';
            arr.includes('style-overview') ? icons += `<li id="brxcStyleOverview" onClick='ADMINBRXC.styleOverviewInit(ADMINBRXC.helpers.getFinalObject(true),true);ADMINBRXC.openModal(false, "#brxcStyleOverviewOverlay", document.querySelector("#brxcStyleOverviewOverlay input[type=search]"));this.style.display = "none"; this.style.display = "flex";'>Style Overview</li>` : '';
            
            arr.includes('component-class-manager') ? icons += `<li id="brxcComponentClassManager" onClick='ADMINBRXC.openClassManager("component");'>Component Class Manager</li>` : '';
            arr.includes('ai-generated-structure') ? icons += `<li id="brxcComponentClassManager" onClick='ADMINBRXC.generatedAIStructureInit();ADMINBRXC.openModal(false, "#brxcGenerateAIStructureOverlay");'>AI Generated Structure</li>` : '';
            arr.includes('codepen-converter') ? icons += `<li id="brxcComponentClassManager" onClick='ADMINBRXC.codepenImporterInit();ADMINBRXC.openModal(false, "#brxcCodePenImporter");'>Codepen Converter</li>` : '';
            icons += `<li id="brxcSaveComponent" onClick='ADMINBRXC.setAddCustomComponents();ADMINBRXC.openModal(false, "#brxcAddCustomComponentsOverlay");'>Save as Nested Element</li>`;
            icons += `<li class="sep"></li>`;
        }

        contextualMenu.insertAdjacentHTML("beforeBegin", icons);
    },
    toggleTagsState: function (){
        const self = this;
        if(self.vueState.brxc.tagsView === 'developer'){
            self.vueState.brxc.tagsView = 'none';
        } else if (self.vueState.brxc.tagsView === 'none'){
            self.vueState.brxc.tagsView = 'overview'
        }  else if (self.vueState.brxc.tagsView === 'overview'){
            self.vueState.brxc.tagsView = 'developer';
        }
        self.showTagInStructurePanel()
    },
    toggleNotesState: function(el){
        const self = this;
        if(self.noteStates.active === 'adminNotes'){
            self.noteStates.active = 'editorNotes';
            el.setAttribute('data-balloon', 'Editor Notes')
        } else {
            self.noteStates.active = 'adminNotes';
            el.setAttribute('data-balloon', 'Admin Notes')
        }
        self.vueState.rerenderControls = Date.now();
    },
    structureHelperStates:{
        expanded: true,
        showTag: false,
        showId: false,
        highlight: false,
        renameMode: false,
        extendComponent: true,
        activeFilter: false,
        filterArr: [],
    },
    setStructureHelper: function(){
        const self = this;
        self.setStructureHelperList();
        if(self.structureHelperStates.activeFilter){
            const activeLi = document.querySelector(`#brxcStructureHelper .brxc-overlay__pannel-col--left li[data-id="${self.structureHelperStates.activeFilter}"]`);
            if(activeLi) activeLi.click()
            
        }
    },
    setStructureHelperList: function(){
        const self = this;
        const canvas = document.querySelector('#structurPanelList');
        if(!canvas) return;

        let content = `<div class="brxc-structure-panel-list__header">
                        <span>Structure</span>
                        <div class="actions">`;
        self.structureHelperStates.expanded !== true ? content += `<div class="bricks-svg-wrapper active" data-balloon="Expand" data-balloon-pos="bottom-right" onclick="ADMINBRXC.structureHelperStates.expanded = true;ADMINBRXC.setStructureHelperList()"><i class="fas fa-up-right-and-down-left-from-center"></i></div>` : content += `<div class="bricks-svg-wrapper" data-balloon="Collapse" data-balloon-pos="bottom-right" onclick="ADMINBRXC.structureHelperStates.expanded = false;ADMINBRXC.setStructureHelperList()"><i class="fa-solid fa-down-left-and-up-right-to-center"></i></i></i></div>`;
        content += `<div class="bricks-svg-wrapper${ADMINBRXC.structureHelperStates.showTag ? ' active' : ''}" data-balloon="${ADMINBRXC.structureHelperStates.showTag ? 'Hide HTML tags' : 'Show HTML tags'}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.structureHelperStates.showTag = ${ADMINBRXC.structureHelperStates.showTag ? false : true};ADMINBRXC.setStructureHelperList()"><i class="fas fa-code"></i></div>`;
        content += `<div class="bricks-svg-wrapper${ADMINBRXC.structureHelperStates.showId ? ' active' : ''}" data-balloon="${ADMINBRXC.structureHelperStates.showId ? 'Hide Ids' : 'Show Ids'}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.structureHelperStates.showId = ${ADMINBRXC.structureHelperStates.showId ? false : true};ADMINBRXC.setStructureHelperList()"><i class="fas fa-id-card"></i></div>`;
        content += `<div class="bricks-svg-wrapper${ADMINBRXC.structureHelperStates.highlight ? ' active' : ''}" data-balloon="${ADMINBRXC.structureHelperStates.highlight ? 'Disable Highlight' : 'Enable Highlight'}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.structureHelperStates.highlight = ${ADMINBRXC.structureHelperStates.highlight ? false : true};ADMINBRXC.setStructureHelperList()"><i class="fas fa-eye${!ADMINBRXC.structureHelperStates.highlight ? '-slash' : ''}"></i></div>`;
        content += `<div class="bricks-svg-wrapper${ADMINBRXC.structureHelperStates.renameMode ? ' active' : ''}" data-balloon="${ADMINBRXC.structureHelperStates.renameMode ? 'Rename Mode On' : 'Rename Mode Off'}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.structureHelperStates.renameMode = ${ADMINBRXC.structureHelperStates.renameMode ? false : true};ADMINBRXC.setStructureHelperList()"><i class="fas fa-edit"></i></div>`;
        content += `<div class="bricks-svg-wrapper${ADMINBRXC.structureHelperStates.extendComponent ? ' active' : ''}" data-balloon="${ADMINBRXC.structureHelperStates.extendComponent ? 'Components Extended' : 'Components Collapsed'}" data-balloon-pos="bottom-right" onclick="ADMINBRXC.structureHelperStates.extendComponent = ${ADMINBRXC.structureHelperStates.extendComponent ? false : true};ADMINBRXC.setStructureHelperList()"><i class="ti-package"></i></div>`;
        content += `</div></div>`; 
        content += self.structureHelperPreview();

        canvas.innerHTML = content;

        const li = canvas.querySelectorAll('li');
        if(!li || li.length < 1) return;

        if(self.structureHelperStates.renameMode) {
            li.forEach(el => {
                const input = el.querySelector('input');
                ['blur', 'keyup'].forEach(type => {
                    input.addEventListener(type, (e) => {
                    if(type === "keyup" && e.key != "Enter") return;
                    if(e.target.value === "") return self.setStructureHelperList();
                    const obj = self.helpers.getElementObject(el.dataset.id);
                    if(!obj) return;
                    obj.label = e.target.value;
                    })
                })
            })

            return;
        }

        li.forEach(el => {
            el.addEventListener('click', (e) => {
                const obj = self.helpers.getElementObject(el.dataset.id);
                if(!obj) return;
                self.openElement(obj.id);
                self.closeModal(e, e.target, '#brxcStructureHelper');

            })
        })
    },
    structureHelperPreview: function(){
        const self = this;

        const content = Array.from(self.helpers.getContent(true)).filter(el => el && el.parent === 0);


        function addElement(originalElement, element, level, isComponent){
            const check = Array.from(self.structureHelperStates.filterArr).find(el => el && el.hasOwnProperty('id') && el.id === element.id);
            let classNames = [];
            if(check || self.structureHelperStates.highlight) classNames.push('active');
            if(self.structureHelperStates.renameMode) classNames.push('editable');
            let content = '';
            content += `
            <li class="${classNames.join(' ')}" data-id="${originalElement.id}"${isComponent ? ` data-component="${isComponent.id}"` : ''} style="--margin:${level};${isComponent ? `--builder-bg-2: var(--builder-bg-component);` : ''}"}>
                <div class="icon"><i class="${bricksData.elements[element.name].icon}"></i></div>`;
                if(self.structureHelperStates.showTag) {
                    const obj = self.helpers.getElementObject(element.id);
                    const tag = self.helpers.getElementTag(obj);
                    content += `<span class="show-tag">${tag}</span>`;
                }
                content +=  self.structureHelperStates.renameMode ? `<input type="text" value="${element.label ? element.label : bricksData.elements[element.name].label}" />`: `<span>${element.label ? element.label : bricksData.elements[element.name].label}</span>`;
                if(self.structureHelperStates.showId) {
                    const elId = element.settings.hasOwnProperty('_cssId') ? element.settings._cssId : `brxe-${element.id}`;
                    content += `<span class="show-id">#${elId}
                                <div class="copy-id-icon" data-balloon="Copy ID to Clipboard" data-balloon-pos="top-right" onclick="event.stopPropagation();ADMINBRXC.copytoClipboardSimple('#${elId}','#${elId} successfully copied to clipboard')"><i class="fas fa-clipboard"></i></div>
                                </span>`;
                }
            content +=  `</li>`;
            return content;
        }

        function checkchildren(element, level, isComponent) {
            if (element.children.length < 1 || (isComponent && self.structureHelperStates.extendComponent === false)) {
                return;
            }
            level++;
        
            element.children.forEach(id => {
                const childOriginalElement = self.helpers.getElementObject(id, true);
                const settings = self.helpers.getElementObject(id);
                const childIsComponent = isComponent || 
                    (self.vueState.hasOwnProperty('components') && 
                     self.vueState.components.find(el => el.id === settings.id));
        
                output += addElement(childOriginalElement, settings, level, childIsComponent);
                checkchildren(settings, level, childIsComponent);
            });
        }

        let output = self.structureHelperStates.expanded === true ? '<ul class="brxc-structure-list__wrapper expanded">' : `<ul class="brxc-structure-list__wrapper collapsed">`;
        content.forEach(el => {
            const originalElement = self.helpers.getElementObject(el.id, true);
            const element = self.helpers.getElementObject(el.id);
            let isComponent = self.vueState.hasOwnProperty('components') && self.vueState.components.find(el => el.id === element.id);
            output += addElement(originalElement, element, 0, isComponent);
            checkchildren(element, 0, isComponent);
        })
        output += '</ul>';

        return output;
    },
    shCheckProp: function(event, prop){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && Object.keys(el.settings).some(function(k){ return ~k.indexOf(prop) }));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shCheckPropArray: function(event, prop, number){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;


        // Classes
        const contentArray = self.helpers.getContentWithComponents();
        const usedGlobalClasses = contentArray
        .flatMap(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') ? el.settings._cssGlobalClasses : []);

        const corrispondingGlobalClasses = self.vueState.globalClasses
        .filter(el => usedGlobalClasses.includes(el.id) && Array.isArray(el.settings[prop]) && el.settings[prop].length > number)
        .map(el => el.id);

        const corrispondingElements = contentArray
        .filter(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') && corrispondingGlobalClasses.some(value => el.settings._cssGlobalClasses.includes(value)));

        // Function
        self.structureHelperStates.filterArr = contentArray
        .filter(el => (
            Array.isArray(corrispondingElements) && corrispondingElements.length > 0 && corrispondingElements.includes(el)) 
            || (el && el.settings.hasOwnProperty(prop) && Array.isArray(el.settings[prop]) && el.settings[prop].length > number));

        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shSearchValueInKey: function(event, prop, value){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

   
        // Classes
        const contentArray = self.helpers.getContentWithComponents();
        const usedGlobalClasses = contentArray
        .flatMap(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') ? el.settings._cssGlobalClasses : []);

        const corrispondingGlobalClasses = self.vueState.globalClasses
        .filter(el => usedGlobalClasses.includes(el.id) && Array.isArray(el.settings[prop]) && el.settings[prop].length > 0 && JSON.stringify(el.settings[prop]).includes(value))
        .map(el => el.id);

        const corrispondingElements = contentArray
        .filter(el => el && el.settings.hasOwnProperty('_cssGlobalClasses') && corrispondingGlobalClasses.some(value => el.settings._cssGlobalClasses.includes(value)));

        // Function
        self.structureHelperStates.filterArr = contentArray
        .filter(el => (
            Array.isArray(corrispondingElements) && corrispondingElements.length > 0 && corrispondingElements.includes(el)) 
            || (el && el.settings.hasOwnProperty(prop) && Array.isArray(el.settings[prop]) && el.settings[prop].length > 0) && JSON.stringify(el.settings[prop]).includes(value));
        
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shSearchValueInKeyObj: function(event, prop, value){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && el.settings.hasOwnProperty(prop) && JSON.stringify(el.settings[prop]).includes(value));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shSearchValue: function(event, key, value){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && el.settings.hasOwnProperty(key) && el.settings[key] === value);
        self.setStructureHelperList();
    },
    shMissingProp: function(event, prop, missing){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && el.settings.hasOwnProperty(prop) && !el.settings[prop].hasOwnProperty(missing));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shCheckAriaAttributes: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        function checkStyles(settings){
            if(settings.hasOwnProperty('_attributes') && Array.isArray(settings['_attributes']) && settings['_attributes'].length > 0) return false;
            let hasStyles = false
            settings['_attributes'].forEach(el => {
                if(el.name.startsWith('aria-')) hasStyles = true;
            })
            return hasStyles;
        }
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shHasIDStyles: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        function checkStyles(settings){
            let hasStyles = false;
            for(const key of Object.keys(settings)){
                if(self.helpers.isCSSControlKey(key)){
                    hasStyles = true;
                }
            }
            return hasStyles;
        }
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shHasPseudoStyles: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        const pseudos = self.vueState.pseudoClasses;
        function checkStyles(settings){
            let hasStyles = false;
            for(const key of Object.keys(settings)){
                const parsedKey = JSON.stringify(key)
                pseudos.forEach(pseudo => {
                    if(parsedKey.includes(pseudo)){
                        hasStyles = true;
                    }
                })
                
            }
            return hasStyles;
        }
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shHasBreakpointStyles: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();
        // Function
        const bps = self.vueState.breakpoints;
        function checkStyles(settings){
            let hasStyles = false;
            for(const key of Object.keys(settings)){
                const parsedKey = JSON.stringify(key)
                bps.forEach(bp => {
                    if(parsedKey.includes(`:${bp.key}`)){
                        hasStyles = true;
                    }
                })
                
            }
            return hasStyles;
        }
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shCheckCustomCSSinGlobalClasses: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        function checkStyles(settings){
            let hasStyles = false;
            if(!settings.hasOwnProperty('_cssGlobalClasses') || !Array.isArray(settings._cssGlobalClasses) || settings._cssGlobalClasses.length < 1) return hasStyles;
            settings._cssGlobalClasses.forEach(classId => {
                const classObj = self.vueGlobalProp.$_getGlobalClass(classId);
                if(!classObj || !classObj.hasOwnProperty('settings')) return;

                for(const key of Object.keys(classObj.settings)){
                    if(JSON.stringify(key).includes('_cssCustom')) hasStyles = true;
                }
            })
            return hasStyles;
        }
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shHasStaticColors: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();
        // Function
        const bps = self.vueState.breakpoints;
        function checkStyles(settings){
            let hasStyles = false;
            const parsedSettings = JSON.stringify(settings);
            ['"hex":"#', '"rgb":"rgb', '"hsl":"hsl'].forEach(el => {
                if(parsedSettings.includes(el)) hasStyles = true;
            })
            
            return hasStyles;
        }
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shConditionDateTime: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        const content = self.helpers.getContentWithComponents();

        // Function
        function checkStyles(settings){
            let hasStyles = false;
            const parsedSettings = JSON.stringify(settings);
            ['"key":"weekday"', '"key":"date"', '"key":"time"', '"key":"datetime"'].forEach(el => {
                if(parsedSettings.includes(el)) hasStyles = true;
            })
            
            return hasStyles;
        }
        
        
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && el.settings.hasOwnProperty('_conditions') && Array.isArray(el.settings['_conditions']) && el.settings['_conditions'].length > 0 && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    shNonConsecutiveHeaders: function(event){
        const self = this;
        const setItem = self.helpers.setActiveItem('#brxcStructureHelper .brxc-overlay__pannel-col--left li', event);
        if(!setItem) return;

        
        const content = [];

        function checkChildren(id,arr){
            const obj = self.helpers.getElementObject(id);
            if(obj.name === "heading") arr.push(obj);
            if(obj.hasOwnProperty('children') && Array.isArray(obj.children) && obj.children.length > 0){
                obj.children.forEach(childId => {
                    checkChildren(childId, arr);
                })
            } 
        }
        const tempContent = Array.from(self.helpers.getContent()).filter(el => el && el.hasOwnProperty('parent') && el.parent === 0);
        if (!tempContent || tempContent.length < 1) return;

        tempContent.forEach(el => {
            const obj = self.helpers.getElementObject(el.id);
            checkChildren(obj.id, content);
        })
        
        let oldHeading = false;
        // Function
        const bps = self.vueState.breakpoints;
        function checkStyles(settings){
            let hasStyles = false;
            if(oldHeading === false){
                oldHeading = settings.tag ? parseInt(settings.tag.substr(1)) : parseInt(bricksData.elements.heading.tag.substr(1))
            } else {
                const newHeading = settings.tag ? parseInt(settings.tag.substr(1)) : parseInt(bricksData.elements.heading.tag.substr(1))
                if(newHeading - oldHeading > 1) hasStyles = true;
                oldHeading = newHeading;
            }

            return hasStyles;
        }
        self.structureHelperStates.filterArr = Array.from(content).filter(el => el && checkStyles(el.settings));
        self.setStructureHelperList();
        self.structureHelperStates.activeFilter = event.target.dataset.id;
    },
    setHeaderStructurePanel: function(){
        const self = this;
        let header = document.querySelector("#bricks-structure #bricks-panel-header ul.actions li");
        if(!header) return;

        let icons = '';

        if(Object.values(self.globalSettings.structurePanelIcons).includes('ai-generated-structure')) {
            icons += `<li data-balloon="Generate Structure with AI" onClick='ADMINBRXC.generatedAIStructureInit();ADMINBRXC.openModal(false, "#brxcGenerateAIStructureOverlay");' data-balloon-pos="bottom"><span class="bricks-svg-wrapper"><i class="bricks-svg fas fa-robot"></i></span></li>`;
        }
        if(Object.values(self.globalSettings.structurePanelIcons).includes('tags')){
            icons += `<li data-balloon="Toggle Elements Tag" onClick='ADMINBRXC.toggleTagsState();' data-balloon-pos="bottom"><span class="bricks-svg-wrapper"><i class="fas fa-tag"></i></span></li>`;
        }
        if(Object.values(self.globalSettings.structurePanelIcons).includes('structure-helper')){
            icons += `<li data-balloon="Open Structure Helper${self.globalSettings.keyboardShortcuts.hasOwnProperty('structureHelper') ? ` (ctrl+cmd+${self.globalSettings.keyboardShortcuts.structureHelper})` : '' }" onClick='ADMINBRXC.setStructureHelper();ADMINBRXC.openModal(false, "#brxcStructureHelper");' data-balloon-pos="bottom"><span class="bricks-svg-wrapper"><i class="fas fa-circle-question"></i></span></li>`;
        }
        if(Object.values(self.globalSettings.structurePanelGeneralTweaks).includes('notes')){
            icons += `<li data-balloon="Admin Notes" onClick='ADMINBRXC.toggleNotesState(this);' data-balloon-pos="bottom"><span class="bricks-svg-wrapper"><i class="ti-comment-alt"></i></span></li>`;
        }
        if(Object.values(self.globalSettings.structurePanelIcons).includes('locked-elements')){
            const isLocked = self.globalSettings.structurePanelLockedElements;
            icons += `<li data-balloon="Elements Order ${isLocked ? "Locked" : "Unlocked"}" onClick='ADMINBRXC.toggleLockElementsState(this);' data-balloon-pos="bottom"><span class="bricks-svg-wrapper"><i class="ti-${isLocked ? "" : "un"}lock"></i></span></li>`;
        }
        header.insertAdjacentHTML("beforeBegin", icons);
    },
    setControlsOptions: function(){
        const self = this;
        const allElements = [];
        const allControls = [];

        for (const [key, value] of Object.entries(bricksData.elements)) {
            const el1 = key;
            const el2 = value;
            allElements.push([el2.name,el2.label]);
            if(bricksData.elements[el1].hasOwnProperty('controls') && typeof bricksData.elements[el1].controls === "object"){
                for (const [key, value] of Object.entries(bricksData.elements[el1].controls)) {
                    if (typeof value !== "undefined" && value.hasOwnProperty('css')) self.CSScontrolKeys.push(key)
                    if (key.startsWith('_') && value.hasOwnProperty('css')) {
                        if(key === "_flexDirection"){
                            allControls.push([key,"Flex direction"]);
                        } else if(key === "_innerContainerMargin"){
                            allControls.push([key,"Inner Container margin"]);
                        } else if(key === "_innerContainerPadding"){
                            allControls.push([key,"Inner Container padding"]);
                        } else if(key === "_rowGapColors"){
                            allControls.push([key,"Row gap (Colors)"]);
                        } else if(key === "_gridGap"){
                            allControls.push([key,"Grid gap"]);
                        } else if(typeof value !== "undefined" && value.hasOwnProperty('label')) {
                            allControls.push([key,value.label])
                        } else {
                            (value.type) ? allControls.push([key,value.type.charAt(0).toUpperCase() + value.type.slice(1)]) : '';
                        }
                    }
                }
            }
        }
        for (const [key, value] of Object.entries(bricksData.controls.themeStyles.controls)) {
            const el1 = key;
            for (const [key, value] of Object.entries(bricksData.controls.themeStyles.controls[el1])) {
                if (typeof value !== "undefined" && value.hasOwnProperty('css')) self.CSScontrolKeys.push(key)
            }
        }
        self.CSScontrolKeys = [... new Set(self.CSScontrolKeys)];

        const categoryWrappers = document.querySelectorAll('.brxc-categoryOptions');
        self.globalSettings.elements = allElements
            .filter((item, index, self) => index === self.findIndex((inner) => inner[0] === item[0] && inner[1] === item[1]))
            .sort((a, b) => (a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0));
        (categoryWrappers.length > 0) ? categoryWrappers.forEach(wrapper => {
            self.globalSettings.elements.forEach(el => {
                wrapper.innerHTML += `<option value="${el[0]}">${el[1]}</option>` 
            })
        }) : '';

        const propertyWrappers = document.querySelectorAll('.brxc-propertyOptions');
        self.globalSettings.styleControls = allControls
            .filter((item, index, self) => index === self.findIndex((inner) => inner[0] === item[0] && inner[1] === item[1]))
            .sort((a, b) => (a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0));
        (propertyWrappers.length > 0) ? propertyWrappers.forEach(wrapper => {
            self.globalSettings.styleControls.forEach(control => {
                wrapper.innerHTML += `<option value="${control[0]}">${control[1]}</option>` 
            })
        }) : '';


    },
    reorderClasses: function(){
       const self = this;
       if(self.vueState.globalClasses && typeof self.vueState.globalClasses === "object") self.vueState.globalClasses.sort((a, b) => { if (a.name < b.name) return -1; if (a.name > b.name) return 1; return 0; });
    },
    groupClassesByLockStatus: function(){
        const self = this;
        if(self.vueState.globalClasses && typeof self.vueState.globalClasses === "object"){
            const locked = []; 
            const unlocked = [];
            self.vueState.globalClasses.forEach(el => {
                self.vueGlobalProp.$_isLocked(el.id) ? locked.push(el) : unlocked.push(el);
            })
            self.vueState.globalClasses = JSON.parse(JSON.stringify(locked.concat(unlocked)));
        }
    },
    rightShortcutStates: {
        active: false,
    },
    setRightShortcutCol: function(force = false){
        const self = this;
        if(Object.values(self.globalSettings.structurePanelGeneralTweaks).includes('new-element-shortcuts')){
            document.body.setAttribute('data-has-shortcuts-sidebar', 'true');
            const structure = document.querySelector('#bricks-structure');
            const structurePanel = structure.querySelector('main.panel-content');
            const existingMenu = structure.querySelector('.brxce-panel-shortcut__wrapper');

            if(!self.rightShortcutStates.active){
                self.rightShortcutStates.active = self.globalSettings.generalCats.rightShortcuts;
            }
            
            if(existingMenu){
                !force ? self.rightShortcutStates.keyboard = self.rightShortcutStates.keyboard === '1' ? '0' : '1' : '';
                existingMenu.remove();
            }

            const existingKey = [];
            
            function setKey(e){
                e = e.replace(/\s/g, '');
                for(let i = 0; i<e.length; i++){
                    if(!existingKey.includes(e[i].toLowerCase())){
                        existingKey.push(e[i].toLowerCase());
                        return e[i].toUpperCase();
                    }
                }

                return false;
            }
            let rightCol = `<div class="brxce-panel-shortcut__wrapper">
                                <div class="brxce-panel-shortcut__container">`;
            if (Array.isArray(self.rightShortcutStates.active) && self.rightShortcutStates.active.length > 0) {
                self.rightShortcutStates.active.forEach(key => {
                    // Handle "nested-elements" case
                    if (key === "nested-elements") {
                        rightCol += `
                            <li data-balloon="Nested Elements" data-balloon-pos="left" 
                                class="brxc-right-sidebar-shortcuts custom-components" 
                                onClick="ADMINBRXC.setCustomComponents();ADMINBRXC.openModal(false, '#brxcCustomComponentsOverlay', document.querySelector('#brxcCustomComponentsSearch input'))">
                                <span class="bricks-svg-wrapper"><i class="fas fa-plus"></i></span>
                            </li>`;
                        return;
                    }
            
                    // Check if the key corresponds to an element
                    const isElement = !!bricksData.elements[key];
                    const el = isElement ? bricksData.elements[key] : self.helpers.getElementObject(key);
            
                    // Skip if element is invalid
                    if (!el) return;
            
                    // Determine icon and keyboard shortcut
                    const icon = isElement ? el.icon : bricksData.elements[el.name]?.icon || 'fas fa-question-circle';
                    const keyboard = setKey(el.label);
            
                    // Build common attributes
                    const dataAttributes = `
                        data-panel="${el.name}"
                        data-label="${el.label}"
                        ${isElement ? `data-name="${el.name}"` : `data-component-id="${el.id}" data-component-name="${el.name}"`}
                        ${keyboard ? `data-order="${keyboard}"` : ''}
                    `;
            
                    // Build the list item
                    rightCol += `
                        <li class="brxc-right-sidebar-shortcuts" ${dataAttributes.trim()}>
                            <span class="bricks-svg-wrapper"><i class="${icon}"></i></span>
                            ${keyboard ? `<span class="keyboard-shortcut">${keyboard}</span>` : ''}
                        </li>`;
                });
            }
            

            rightCol += '</div>';

            // Keyboard Shortcuts
            rightCol += `<li id="brxcKeyBoardShortcuts" class="${self.rightShortcutStates.keyboard === '1' ? 'active' : ''}" data-balloon="Keyboard Shortcuts ${self.rightShortcutStates.keyboard === '1' ? 'ON' : 'OFF'}" data-balloon-pos="left" onclick="ADMINBRXC.setRightShortcutCol()"><span class="bricks-svg-wrapper"><i class="fas fa-keyboard"></i></span></li>`;
            
            // Options
            rightCol += `<li id="brxcShortcutsOptions" class="" data-balloon="Shortcuts Settings" data-balloon-pos="left" onclick="ADMINBRXC.setShortcutsOptionsInit()"><span class="bricks-svg-wrapper"><i class="fas fa-gear"></i></span></li></div>`;

            structurePanel.insertAdjacentHTML(
                'afterend',
                rightCol
            );

            // Listeners
            const icons = structure.querySelectorAll('li.brxc-right-sidebar-shortcuts[data-panel]');
            icons.forEach(icon => {
                icon.addEventListener('mousedown', (event) => {
                    const isElement = !!icon.dataset.name || false;
                    isElement ? self.addElementtoStructure(event, icon.dataset.name) : self.addComponenttoStructure(icon.dataset.componentId, icon.dataset.componentName);
                });

                let balloon = null;

                icon.addEventListener('mouseenter', () => {
                    if (!balloon) {
                        const rect = icon.getBoundingClientRect();
                        balloon = document.createElement('div');
                        balloon.className = 'brxc-shortcut-balloon';
                        balloon.textContent = icon.dataset.label;
                        balloon.style.top = `${rect.y + 18}px`;
                        balloon.style.right = `${window.innerWidth - rect.left + 7}px`;

                        document.body.appendChild(balloon);
                    }
                });

                icon.addEventListener('mouseleave', () => {
                    if (balloon) {
                        balloon.remove();
                        balloon = null;
                    }
                });
            });


            // ACSS
            const acssApp = document.querySelector('.acss-dashboard-app')
            if(acssApp){
                const acssStyle = acssApp.shadowRoot.querySelector('#svelte-y41ihy');
                if(acssStyle) {
                    const defaultStyles = acssStyle.textContent;
                    const newStyles = defaultStyles.replace(/right:\s*10px/, 'right: 50px');
                    acssStyle.innerHTML = newStyles;
                }
            }

        } else {
            document.body.removeAttribute('data-has-shortcuts-sidebar');
            const existingMenu = document.querySelector('#bricks-structure .brxce-panel-shortcut__wrapper');
            if(existingMenu) existingMenu.remove();
        }
    },
    setShortcutsOptionsInit: function(){
        const self = this;
        const existing = document.querySelector('#brxcShortcutsSettings');
        if(existing) existing.remove();

        const a = document.createElement('DIV');
        a.id = "brxcShortcutsSettings";
        a.innerHTML = `
        <div id="brxcShortcutsSettingsHeader">
            <span class="title">Shortcut Settings</span>
            <span class="bricks-svg-wrapper save" data-balloon="Save" data-balloon-pos="bottom" onclick="ADMINBRXC.saveRightShortcuts();"><i class="fas fa-floppy-disk"></i></span>
            <span class="bricks-svg-wrapper close" data-balloon="Close" data-balloon-pos="bottom" onclick="document.querySelector('#brxcShortcutsSettings').remove()"><svg version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="bricks-svg"><path d="M400,145.49l-33.49,-33.49l-110.51,110.51l-110.51,-110.51l-33.49,33.49l110.51,110.51l-110.51,110.51l33.49,33.49l110.51,-110.51l110.51,110.51l33.49,-33.49l-110.51,-110.51l110.51,-110.51Z" fill="currentColor"></path></svg></span>
        </div>
        <div id="brxcShortcutsSettingsMain"></div>`
        document.body.appendChild(a);

        self.shortcutsOptionsRenderElements();

        // Listeners
        const wrapper = document.querySelector('#brxcShortcutsSettingsMain');
        if(wrapper){
            wrapper.addEventListener('click', (e) => {
                const parent = e.target.parentElement;
                const name = parent.dataset.name || parent.dataset.componentId;
            
                if (name) {
                    if (e.target.classList.contains('fa-toggle-on')) {
                        self.shortcutsOptionsDeactivateElement(name);
                    } else if (e.target.classList.contains('fa-toggle-off')) {
                        self.shortcutsOptionsActivateElement(name);
                    }
                }
            });
        }
    },
    shortcutsOptionsRenderElements: function(){
        const self = this;
        const wrapper = document.querySelector('#brxcShortcutsSettingsMain');
        if(!wrapper) return;
        const nestedELements = {
            name: 'nested-elements',
            label: 'Nested Elements',
            icon: 'fas fa-plus',
        }
        const elements = JSON.parse(JSON.stringify(bricksData.elements));
        elements['nested-elements'] = nestedELements;

        let content = '';
        
        // Active
        if(Array.isArray(self.rightShortcutStates.active)){
            content += `
                <div id="brxcShortcutsSettingsActiveLabel" class="no-handle">
                    <span>Active</span>
                    <span onclick="ADMINBRXC.shortcutsOptionsDeactivateAllElements();">Toggle All</span>
                </div>
                <div id="brxcShortcutsSettingsActive">
            `;

            if (self.rightShortcutStates.active.length > 0) {
                self.rightShortcutStates.active.forEach(el => {
                    const isElement = !!elements[el];
                    const obj = isElement ? elements[el] : self.helpers.getElementObject(el);

                    if (!obj) return;

                    const name = isElement ? obj.name : obj.id;
                    const icon = isElement ? obj.icon : bricksData.elements[obj.name]?.icon || 'fas fa-question-circle';
                    const label = obj.label;

                    content += `
                        <div>
                            <div class="handle"><i class="fas fa-grip-vertical"></i></div>
                            <div ${isElement ? `data-name="${name}"` : `data-component-id="${name}"`}>
                                <i class="icon ${icon}"></i>
                                <span>${label}</span>
                                <i class="toggle fas fa-toggle-on"></i>
                            </div>
                        </div>
                    `;
                });
            } else {
                content += `<p data-control="info">No active elements</p>`;
            }

            content += `</div>`;

    
            // Inactive
            content += '<div id="brxcShortcutsSettingsInactiveLabel"><span>Inactive</span><span onclick="ADMINBRXC.shortcutsOptionsActivateAllElements();">Toggle All</span></div>';
            content += '<div id="brxcShortcutsSettingsInactive">';
            let count = 0;

            // Elements
            for(const [key, value] of Object.entries(elements)){
                if(self.rightShortcutStates.active.includes(key)) continue;
                content += `<div data-name="${elements[key].name}"><i class="icon ${elements[key].icon}"></i><span>${elements[key].label}</span><i class="toggle fas fa-toggle-off"></i></div>`;
                count++;
            }
            if(self.vueState.hasOwnProperty('components')){
                const arr = self.vueState.components.map(el => el.elements[0])
                arr.forEach(el => {
                    if(self.rightShortcutStates.active.includes(el.id)) return;
                    content += `<div data-component-id="${el.id}"><i class="icon ${elements[el.name].icon}"></i><span>${el.label}</span><i class="toggle fas fa-toggle-off"></i></div>`;
                    count++;
                })
            }

            // Components
            if(count === 0){
                content += `<p data-control="info">No active elements</p>`;
            }
            content += '</div>';
        }

        // Return
        wrapper.innerHTML = content;

        // Listeners
        const sortableContainer = wrapper.querySelector('#brxcShortcutsSettingsActive');
        new Sortable(sortableContainer, {
            selectedClass: "sortable-selected",
            handle: ".handle",
            animation: 150,
            helper: 'clone',
            filter: ".no-handle",
            onEnd: (evt) => {
                self.rightShortcutStates.active = Array.from(evt.to.children).map(el => el.children[1].dataset.name || el.children[1].dataset.componentId);
                self.setRightShortcutCol(true);

            },
        });
    },
    shortcutsOptionsDeactivateElement: function (name){
        const self = this;
        const index = self.rightShortcutStates.active.indexOf(name);
        if(index === -1) return

        self.rightShortcutStates.active.splice(index, 1);
        self.shortcutsOptionsRenderElements();
        self.setRightShortcutCol(true);
    },
    shortcutsOptionsDeactivateAllElements: function (name){
        const self = this;
        self.rightShortcutStates.active = [];
        self.shortcutsOptionsRenderElements();
        self.setRightShortcutCol(true);
    },
    shortcutsOptionsActivateElement: function (name){
        const self = this;
        self.rightShortcutStates.active.push(name);
        self.shortcutsOptionsRenderElements();
        self.setRightShortcutCol(true);
    },
    shortcutsOptionsActivateAllElements: function (name){
        const self = this;
        
        self.rightShortcutStates.active = [
            ...Object.values(bricksData.elements).map(el => el.name),
            ...(self.vueState.components?.map(el => el.id) || []),
            'nested-elements'
        ];

        self.shortcutsOptionsRenderElements();
        self.setRightShortcutCol(true);
    },
    saveRightShortcuts: function(){
        const self = this;
        const obj = self.rightShortcutStates.active;
        jQuery.ajax({
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'save_right_shortcuts_ajax_function',
                nonce: openai_ajax_req.nonce,
                shortcuts: obj,
            },
            method: "POST",
            success: function(data) {
                self.vueGlobalProp.$_showMessage('Shortcuts settings saved successfully!')
            },
            error: function(data) {
                self.vueGlobalProp.$_showMessage('Something went wrong - Shortcuts setting not saved.')
            }
        });
    },
    addElementtoStructure: function(event, elName){
        const self = this;
        const id = self.vueGlobalProp.$_generateId();

        const newElement = self.vueGlobalProp.$_addNewElement(
            {
                element: {
                    name:elName,
                    id: id,
                }
            }, 
            {shiftKey: event.shiftKey}, 
            true);
        FRAMEBRXC.vueGlobalProp.$_addNewElement(
            {
                element: {
                    name:elName,
                    id: id,
                }
            }, 
            {shiftKey: event.shiftKey}, 
            true);
        // Tag Manager
        if (self.helpers.isBuilderTweaksTabActive('structure-panel') && Object.values(self.globalSettings.structurePanelIcons).includes("tags")) {
            setTimeout(() => self.showTagInStructurePanel(), 0);
        }

        // Focus element on shift click
        if (elName === "section" && event && event.shiftKey) {
            setTimeout(() => {
                const section = self.helpers.getElementObject(newElement.id);
                const container = self.helpers.getElementObject(section.children[0])
                self.vueState.activeId = container.id;
                self.helpers.activeElement = container;
            }, 0)
        }
    },
    addComponenttoStructure: function(componentId, componentName){
        const self = this;

        self.vueGlobalProp.$_addToStore({
            id: self.vueGlobalProp.$_generateId(),
            cid: componentId,
            name: componentName, 
            children: []
        })

        // Tag Manager
        if (self.helpers.isBuilderTweaksTabActive('structure-panel') && Object.values(self.globalSettings.structurePanelIcons).includes("tags")) {
            setTimeout(() => self.showTagInStructurePanel(), 0);
        }
    },
    customComponentStates: {
        search: '',
        activeCategory: 'all',
        defaultCategory: [
            {id: "default", label: "Default", default: true},
        ],
        add: {
            type: 'Add',
            id: false,
            label: '',
            category: '',
            icon: 'ti-arrow-up'
        }
    },
    setAddCustomComponents: function(){
        const self = this;
        self.customComponentStates.add.type = 'Add';
        self.customComponentStates.add.id = false;
        self.customComponentStates.add.label = '';
        self.customComponentStates.add.category = '';
        self.customComponentStates.add.icon = 'ti-arrow-up';
        self.mountAddCustomComponents();
    },
    addCustomComponentsPreview: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        let content = '';
        const elements = [];

        function populateElements(id, level){
            const obj = JSON.parse(JSON.stringify(self.helpers.getElementObject(id)));
            obj.level = level;
            elements.push(obj);

            if (!obj.hasOwnProperty('children') || !Array.isArray(obj.children) || obj.children.length < 1) return;
            level++;
            obj.children.forEach(newId => {
                populateElements(newId, level);
            })
        }
        populateElements(elementObj.id, 0);
        elements.forEach(el =>{
            content += `<li style="--margin:${el.level}">
                            <div class="icon">
                                <i class="${bricksData.elements[el.name].icon}"></i>
                            </div>
                            <span>${el.hasOwnProperty('label') ? el.label : bricksData.elements[el.name].label}</span>
                        </li>`;
        })
        return content;

    },
    mountAddCustomComponents: function(){
        const self = this;
        const canvas = document.querySelector('#brxcAddCustomComponentsCanvas');
        let content = '';
        content += `<div class="brxc-overlay__panel-inline-btns-wrapper m-bottom-24" style="padding: 0px">
                        <input type="radio" id="add-custum-component-add" name="add-custom-component-switch" class="brxc-input__radio" onclick="ADMINBRXC.customComponentStates.add.type = 'Add';ADMINBRXC.mountAddCustomComponents();"${ADMINBRXC.customComponentStates.add.type === 'Add' ? ' checked' : ''}>
                        <label for="add-custum-component-add" class="brxc-overlay__panel-inline-btns">Add</label>
                        <input type="radio" id="add-custum-component-edit" name="add-custom-component-switch" class="brxc-input__radio" onclick="ADMINBRXC.customComponentStates.add.type = 'Edit';ADMINBRXC.mountAddCustomComponents();"${ADMINBRXC.customComponentStates.add.type === 'Edit' ? ' checked' : ''}>
                        <label for="add-custum-component-edit" class="brxc-overlay__panel-inline-btns">Edit</label>
                    </div>
                    <label for="brxcCustomComponentPreview" class="has-tooltip">
                        <span>Preview</span>
                        <div data-balloon="This is the DOM structure that will be saved in the database" data-balloon-pos="top-left" data-balloon-length="large">
                            <i class="fas fa-circle-question"></i>
                        </div>
                    </label>
                    <ul class="brxc-custom-components__preview-container">`;
        content += self.addCustomComponentsPreview();
        content += `</ul>`;
        if(self.customComponentStates.add.type === "Edit"){
            content += `<label for="brxcCustomComponentEdit" class="has-tooltip">
                            <span>Edit The following component</span>
                            <div data-balloon="Choose the nested element you want to edit" data-balloon-pos="top" data-balloon-length="large">
                                <i class="fas fa-circle-question"></i>
                            </div>
                        </label>
                        <div class="m-bottom-24">
                            <select id="brxcCustomComponentSelect" class="brxc-plain-class-select">
                                <option>--- Choose a Component ---</option>`;
                self.globalSettings.customComponentsElements.forEach(el => {
                    let categoryName = self.helpers.getCustomComponentCatObjById(el.category).label;
                    if(!categoryName) categoryName = "Uncategorized";
                    content += `<option value="${el.id}"${self.customComponentStates.add.id === el.id ? ' selected' : ''}>${el.label} (${categoryName})</option>`;
                })
                content += `</select>
                        </div>`;
        }                 
        content += `<label for="brxcCustomComponentLabel" class="has-tooltip">
                        <span>Label</span>
                        <div data-balloon="Set a label to your nested element" data-balloon-pos="top-left" data-balloon-length="large">
                            <i class="fas fa-circle-question"></i>
                        </div>
                    </label>
                    <div id="classConverterGrpWrapper">
                        <input type="text" id="brxcCustomComponentLabel" class="brxc-input-text m-bottom-24" value="${self.customComponentStates.add.label ? self.customComponentStates.add.label : ''}" data-prop="label" placeholder="Type the name of your nested element here."></input>
                    </div>
                    <label for="brxcCustomComponentCategory" class="has-tooltip">
                        <span>Category <span class="brxc__light">(Optional)</span></span>
                        <div data-balloon="Assign a category to the nested element" data-balloon-pos="top" data-balloon-length="large">
                            <i class="fas fa-circle-question"></i>
                        </div>
                    </label>
                    <div class="brxc-custom-components__category-wrapper">
                        <input type="text" id="brxcCustomComponentCategory" class="brxc-input-text m-bottom-24" value="${self.customComponentStates.add.category ? self.customComponentStates.add.category : ''}" data-prop="category" placeholder="Type the category of the nested element here."></input>
                    </div>
                    <label for="brxcCustomComponentIcon" class="has-tooltip">
                        <span>Icon</span></span>
                        <div data-balloon="Choose an icon related to the nested element" data-balloon-pos="top-left" data-balloon-length="large">
                            <i class="fas fa-circle-question"></i>
                        </div>
                    </label>
                    <div class="brxc-custom-components__icon-container m-bottom-24">
                        <div class="brxc-custom-components__icon-wrapper m-bottom-24">`;
                        self.helpers.tiIcons.forEach((icon, index) => {
                            content += `<input type="radio" id="brxc-${icon.replaceAll(' ', '-').toLowerCase()}" name="brxc-component-icons" class="brxc-input__radio" data-value="${icon}"${self.customComponentStates.add.icon && self.customComponentStates.add.icon === icon ? ' checked' : ''}>
                                        <label for="brxc-${icon.replaceAll(' ', '-').toLowerCase()}"><i class="${icon}"></i></label>`
                        })
            content += `</div>
                    </div>
                    <div class="brxc-overlay__action-btn-wrapper right m-top-16"> 
                        <div class="brxc-overlay__action-btn primary" onclick="ADMINBRXC.addNewCustomComponent();"><span>${self.customComponentStates.add.type ? self.customComponentStates.add.type : ''} Nested Element</span></div>
                    </div>`
        canvas.innerHTML = content;

        // Listeners;
        const inputs = canvas.querySelectorAll('input[data-prop]');
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                self.customComponentStates.add[input.dataset.prop] = input.value;
            })
        })
        const select = canvas.querySelector('#brxcCustomComponentSelect');
        if(select){
            select.addEventListener('change', () => {
                self.customComponentStates.add.id = select.value;
                const obj = self.helpers.getCustomComponentObjById(select.value);
                self.customComponentStates.add.label = obj.label;
                self.customComponentStates.add.icon = obj.icon;
                obj.hasOwnProperty('category') && obj.category !== ''? self.customComponentStates.add.category = self.helpers.getCustomComponentCatObjById(obj.category).label : self.customComponentStates.add.category = '';
                self.mountAddCustomComponents();
            })
        }
        const radios = canvas.querySelectorAll('input[name="brxc-component-icons"]');
        radios.forEach(radio => {
            radio.addEventListener('click', () => {
                self.customComponentStates.add.icon = radio.dataset.value;
            })
        })
        const category = canvas.querySelector('#brxcCustomComponentCategory');
        self.autocomplete(category, Array.from(self.globalSettings.customComponentsCategories).map(el => el && el.label), false);


    },
    addNewCustomComponent: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        let categoryId = false;
        let elements = [];
        let globalClasses = []

        function populateElements(id){
            const obj = JSON.parse(JSON.stringify(self.helpers.getElementObject(id)));
            elements.push(obj);
            
            // Global Classes
            if(obj.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(obj.settings._cssGlobalClasses) && obj.settings._cssGlobalClasses.length > 0){
                obj.settings._cssGlobalClasses.forEach(id => {
                    let classObj = self.vueGlobalProp.$_getGlobalClass(id);
                    if(classObj){
                        classObj = JSON.parse(JSON.stringify(classObj));
                        globalClasses.push(classObj);
                        globalClasses = [...new Set(globalClasses)];
                    }
                })
            }

            if (!obj.hasOwnProperty('children') || !Array.isArray(obj.children) || obj.children.length < 1) return;
            obj.children.forEach(newId => {
                populateElements(newId);
            })
        }
        populateElements(elementObj.id);

        // Categories
        if(self.customComponentStates.add.category !== ''){
            const existingCategory = self.helpers.getCustomComponentCatObjByName(self.customComponentStates.add.category);
            if(existingCategory) {
                categoryId = existingCategory.id;
            } else {
                categoryId = self.vueGlobalProp.$_generateId();
                self.globalSettings.customComponentsCategories.push({
                    id: categoryId,
                    label: self.customComponentStates.add.category
                })
            }
            self.customComponentStates.activeCategory = categoryId;
        }

        // Elements
        if(self.customComponentStates.add.type === "Add"){
            const obj = {
                id: self.vueGlobalProp.$_generateId(),
                label: self.customComponentStates.add.label,
                icon: self.customComponentStates.add.icon,
                elements: elements,
                globalClasses: globalClasses
            }
            if(categoryId) obj.category = categoryId;

            self.globalSettings.customComponentsElements.push(obj)
        } else if(self.customComponentStates.add.type === "Edit") {
            const obj = self.helpers.getCustomComponentObjById(self.customComponentStates.add.id);
            obj.label = self.customComponentStates.add.label;
            obj.icon = self.customComponentStates.add.icon;
            obj.elements = elements;
            categoryId ? obj.category = categoryId : delete obj.category;
        }

        if(!self.customComponentStates.add.label || self.customComponentStates.add.label === "" ||
           !self.customComponentStates.add.icon || self.customComponentStates.add.icon === "" ||
           (self.customComponentStates.add.type === "Edit" && !self.customComponentStates.add.id)
        ){
            self.vueGlobalProp.$_showMessage('ABORT: Missing required field values!')
            return;
        }

        self.customComponentStates.add.type === "Add" ? self.vueGlobalProp.$_showMessage('Component correctly created!') : self.vueGlobalProp.$_showMessage('Component correctly edited!');
        self.setCustomComponents();
        self.openModal(false, '#brxcCustomComponentsOverlay', document.querySelector('#brxcCustomComponentsSearch input'));
    },
    setCustomComponents: function(){
        const self = this;
        self.customComponentsMountCategories();
        self.customComponentsMountElements();
    },
    customComponentsMountCategories: function(){
        const self = this;
        const canvas = document.querySelector('#brxcCustomComponentsCats');
        if(!canvas) return;

        let cats = '<ul>';
        let count;
        const arr = brxcNestedElementsDefault.concat(self.globalSettings.customComponentsElements);
        const categories = self.customComponentStates.defaultCategory.concat(self.globalSettings.customComponentsCategories);

        function isActive (id) {
            if(self.helpers.getCustomComponentCatObjById(id).id === self.customComponentStates.activeCategory) return true;
            return false;
        }

        // All
        count = arr.length;
        cats += `<li class="${self.customComponentStates.activeCategory === "all" ? 'active' : ''}"${self.customComponentStates.activeCategory === "all" ? ' data-active="true"' : ''} data-id="all" onClick="ADMINBRXC.customComponentsFilterCat(event)"><input type="text" value="All" readonly/><span class="count">${count}</span></li>`
        
        // Uncategorized
        count = Array.from(arr).filter(el => el && self.helpers.isCustomComponentUncategorized(el)).length;
        cats += `<li class="${self.customComponentStates.activeCategory === "uncategorized" ? 'active' : ''}"${self.customComponentStates.activeCategory === "uncategorized" ? ' data-active="true"' : ''} data-id="uncategorized" onClick="ADMINBRXC.customComponentsFilterCat(event)"><input type="text" value="Uncategorized" readonly/><span class="count">${count}</span></li>`

        // Categories
        categories.forEach(catObj => {
            count = Array.from(arr).filter(el => el && el.hasOwnProperty('category') && catObj.id === el.category).length;
            cats += `<li class="${isActive(catObj.id) ? 'active' : ''}"${isActive(catObj.id) ? ' data-active="true"' : ''} data-id="${catObj.id}" ondragenter="this.classList.add('dragged')" ondragleave="this.classList.remove('dragged')" ondrop="event.preventDefault();ADMINBRXC.onDropVariableCatList(this);" ondragover="event.preventDefault();" onClick="ADMINBRXC.customComponentsFilterCat(event)">
                        <input type="text" data-initial="${catObj.label}" value="${catObj.label}"${catObj.id !== self.customComponentStates.activeCategory ? ' readonly' : ''}/>
                        <div class="action">`;
            if(!catObj.hasOwnProperty('default') && catObj.id === self.customComponentStates.activeCategory){
                    cats += `<div class="deleteCat" onClick="event.stopPropagation();ADMINBRXC.deleteCustomComponementCategory('${self.customComponentStates.activeCategory}')" data-balloon="Delete category" data-balloon-pos="top-right"><span class="bricks-svg-wrapper"><i class="ti-trash"></i></span></div>`;
            }
                    cats += `<span class="count">${count}</span>
                        </div>
                    </li>`;
        })

        cats += '</ul><input type="text" id="addNewCat" placeholder="+ New category" onkeyup="ADMINBRXC.addCustomComponentCategory(this, event);" />';

        if(canvas && cats) canvas.innerHTML = cats;

        // rename cat
        const input = canvas.querySelector('li.active input');
        if(input){
            input.addEventListener('keyup', (event) => {
                if(event.key !== "Enter") return;
                if(event.target.value === event.target.dataset.initial) return self.customComponentsMountCategories();
                if(categories.map(el => el && el.label).includes(event.target.value)) return self.vueGlobalProp.$_showMessage(`ABORT: category "${event.target.value}" already exists`);
                const activeObj = self.helpers.getCustomComponentCatObjById(event.target.parentElement.dataset.id);
                if(!activeObj) return;
                activeObj.label = event.target.value;
                self.vueGlobalProp.$_showMessage(`Category correctly renamed to ${event.target.value}`)
                self.customComponentsMountCategories();
            })
        }
    },
    deleteCustomComponementCategory: function(id){
        const self = this;

        // Remove category from elements
        self.globalSettings.customComponentsElements.filter(el => el && el.hasOwnProperty('category') && el.category === id).map(el => delete el.category);
        
        // Remove Category
        const obj = self.helpers.getCustomComponentObjById(id);
        const order = self.globalSettings.customComponentsCategories.indexOf(obj);
        self.globalSettings.customComponentsCategories.splice(order, 1);

        // Rerender
        self.customComponentStates.activeCategory = "all";
        self.vueGlobalProp.$_showMessage('Category successfully deleted!');
        self.setCustomComponents();
    },
    addCustomComponentCategory: function(input, event){
        if(event && event.key !== "Enter") return;

        const self = this;
        let count = 0;
        let id;
        const categories = self.customComponentStates.defaultCategory.concat(self.globalSettings.customComponentsCategories);
        const names = input.value.split(',').map(item => item.trim());
        names.forEach(el => {
            const name = el.toLowerCase();
            const existingCategory = self.helpers.getCustomComponentCatObjByName(name);
            if(!existingCategory){
                id = self.vueGlobalProp.$_generateId();
                self.globalSettings.customComponentsCategories.push({
                    id: id,
                    label: el
                });
                count++;
            } else {
                id = existingCategory;
            }
        })
        if(count > 0) self.vueGlobalProp.$_showMessage('Category successfully added!');
        
        self.customComponentStates.activeCategory = id;
        self.setCustomComponents();
    },
    customComponentsFilterCat: function(event){
        const self = this;
        target = (event.target.dataset.id) ? event.target : event.target.parentElement;
        if(target.dataset.active === 'true') return;
        self.customComponentStates.activeCategory = target.dataset.id;
        self.setCustomComponents();
    },
    customComponentsMountElements: function(){
        const self = this;
        const canvas = document.querySelector('#brxcCustomComponentsElements');
        let content = "";
        let elements = brxcNestedElementsDefault.concat(self.globalSettings.customComponentsElements);

        // Categories
        if(self.customComponentStates.activeCategory !== "all"){
            if(self.customComponentStates.activeCategory === "uncategorized"){
                elements = elements.filter(el => el && !el.hasOwnProperty('category'));
            } else {
                elements = elements.filter(el => el && el.hasOwnProperty('category') && el.category === self.customComponentStates.activeCategory);
            }
        }

        // Search
        if(self.customComponentStates.search !== ''){
            elements = elements.filter(el => el.label.toLowerCase().includes(self.customComponentStates.search.toLowerCase()));
        }

        // Loop
        elements.forEach(item => {
            content += `<div class="brxc-custom-components__item" data-id="${item.id}">
                            <i class="${item.icon}"></i>
                            <div class="brxc-custom-components__label">
                                ${item.label}
                            </div>`;
            if(!item.hasOwnProperty('default')){
                content += `<div class="brxc-overlay__close-btn" data-balloon="Delete" data-balloon-pos="left">
                                <i class="bricks-svg ti-trash"></i>
                            </div>`
                if((self.vueState.hasOwnProperty('components'))) content +=  `<div class="brxc-custom-components__convert" data-balloon="Convert as Component" data-balloon-pos="left" data-id="${item.id}">
                                 <i class="fas fa-right-left"></i>
                            </div>`;
            }
            content += `</div>`;
        })
        canvas.innerHTML = content;
        
        // Listeners
        const items = canvas.querySelectorAll('.brxc-custom-components__item[data-id]');
        items.forEach(item => {
            item.addEventListener('click', () => {
                self.addCustomComponent(item.dataset.id);
            })
        })
        const deletes = canvas.querySelectorAll('.brxc-overlay__close-btn');
        deletes.forEach(el => {
            el.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                self.deleteCustomComponement(el.parentElement.dataset.id);
            })
        })

        const converts = canvas.querySelectorAll('.brxc-custom-components__convert[data-id]');
        converts.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                self.convertNestableintoComponent(item.dataset.id);
            })
        })
    },
    convertNestableintoComponent: function(id){
        const self = this;
        const arr = brxcNestedElementsDefault.concat(self.globalSettings.customComponentsElements);
        const item = arr.find(el => el.id === id);
        const parent = item.elements[0]

        const newComponent = {
            id: parent.id,
            name: parent.name,
            children: parent.children,
            desc: '',
            elements: JSON.parse(JSON.stringify(item.elements.slice(1)).replaceAll('#brxe-', '.brxe-')),
            category: item.category,
            label: parent.label,
            properties: [],
            settings: JSON.parse(JSON.stringify(parent.settings).replaceAll('#brxe-', '.brxe-'))
        }
        self.vueState.components.push(newComponent);
        self.vueGlobalProp.$_showMessage(`${item.label} has been converted as Component!`);
    },
    deleteCustomComponement: function(id){
        const self = this;
        const arr = self.globalSettings.customComponentsElements;
        const element = arr.find(el => el && el.id === id);
        const order = arr.indexOf(element);
        arr.splice(order, 1);
        self.vueGlobalProp.$_showMessage('Nested element successfully deleted!');
        self.setCustomComponents();
    },
    addCustomComponent: function(dataId){
        const self = this;
        const arr = brxcNestedElementsDefault.concat(self.globalSettings.customComponentsElements);
        const item = arr.find(el => el.id === dataId);
        
        function generateNewComponentIds(arr){
            arr.forEach(el => {
                if(!el.hasOwnProperty('settings')) el.settings = {};
            })

            let newArr = JSON.stringify(arr);
            arr.forEach(el => {
                const newId = self.vueGlobalProp.$_generateId();
                newArr = newArr.replaceAll(el.id, newId);
            })
            return JSON.parse(newArr);
        }
        const elements = generateNewComponentIds(item.elements);
        const globalClasses = item.globalClasses;
        const contentType = self.helpers.getTemplateType();
        const content = self.helpers.getContent();

        // Add Global Classes
        if(globalClasses && Array.isArray(globalClasses) && globalClasses.length > 0){
            globalClasses.forEach(obj => {
                let classExists = Array.from(self.vueState.globalClasses).find(el => el && el.name === obj.name)
                if(!classExists){
                    if(!obj.hasOwnProperty('settings')) obj.settings = {};
                    self.vueState.globalClasses.push(obj);
                }
            }) 
        }

        // Add Elements
        if(self.helpers.isElementActive()){
            const elementObj = self.helpers.getFinalObject(true);
            // Nestable
            if(self.vueGlobalProp.$_getElementConfig(elementObj.name).nestable === true){
                elements[0].parent = elementObj.id;
                elementObj.children.push(elements[0].id);
            // Non Nestable
            } else {
                elements[0].parent = elementObj.parent;
                const parent = self.helpers.getElementObject(elementObj.parent);
                parent.children.push(elements[0].id);
            }

        } else {
            elements[0].parent = 0;
        }
        if(self.helpers.isComponentActive()){
            self.vueState.activeComponent.elements = JSON.parse(JSON.stringify(content.concat(elements)));
        } else {
            self.vueState[contentType] = JSON.parse(JSON.stringify(content.concat(elements)));
        }
        setTimeout((e) => {
            self.vueState.rerenderControls = Date.now();
            document.querySelector('#brxcCustomComponentsOverlay').removeAttribute('data-active');
            self.vueGlobalProp.$_showMessage('Nested Element correctly inserted!');
        },5)
    },
    saveCustomComponentsOptions: function() {
        const self = this;
        const elements = self.globalSettings.customComponentsElements;
        const categories = self.globalSettings.customComponentsCategories;
        jQuery.ajax({
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'save_custom_components_ajax_function',
                nonce: openai_ajax_req.nonce,
                customComponentsElements: JSON.stringify(elements),
                customComponentsCategories: JSON.stringify(categories),
            },
            method: "POST",
            success: function(data) {
                self.vueGlobalProp.$_showMessage('Nested Elements saved successfully!')
            },
            error: function(data) {
                self.vueGlobalProp.$_showMessage('Something went wrong - Nested Elements not saved.')
                console.log(data);
            }
        });
    },
    setGlobalKeyboardsh: function(){
        const self = this;

        function runShortcuts(e, addShortcut = true) {
            const containers = document.querySelectorAll('.brxce-panel-shortcut__container');
        
            if (containers.length < 0) return;
        
            const item = Array.from(document.querySelectorAll('.brxce-panel-shortcut__container li[data-order]')).find(el => el.dataset.order.toLowerCase() === e.key.toLowerCase());
        
            const shortcut = e.shiftKey;
        
            // Check if any excluded keys are pressed
            const excludedKeys = [e.ctrlKey,e.metaKey,e.altKey];
        
            const shouldTriggerItem = !excludedKeys.includes(true);
        
            // View Shortcuts
            if (shortcut) {
                containers.forEach(container => container.classList.add('shortcuts-active'));
            } else {
                containers.forEach(container => container.classList.remove('shortcuts-active'));
            }
        
            if (!addShortcut) return;
        
            // Click shortcut
            if (item && shouldTriggerItem){
                e.preventDefault();
                e.stopPropagation();
                if (shortcut) {
                    const event = new MouseEvent('mousedown', {
                        bubbles: true,
                        cancelable: true,
                        shiftKey: true,
                    });
                    item.dispatchEvent(event);
    
                } else {
                    ADMINBRXC.vueState.brxc.clickedOnLeftPanelShortcuts = true;
                    setTimeout(() => {
                        const event = new MouseEvent('mousedown', {
                            bubbles: true,
                            cancelable: true,
                        });
                        item.dispatchEvent(event);
                        ADMINBRXC.vueState.brxc.clickedOnLeftPanelShortcuts = false;
                    }, 10);
                }
            }
        }
        function excludeFromBuilder(e){
            const activeKeyboard = self.rightShortcutStates.keyboard !== '1';
            const isReadOnly = e.target.tagName.toLowerCase() === 'input' && e.target.readOnly !== true;
            const isTextarea = e.target.tagName.toLowerCase() === 'textarea';
            const isACSSCodeMirror = e.target.classList.contains('acss-dashboard-app');
            const isStructeezy = e.target.closest('#structeezy-menu');
            const isCodeMirror = e.target.closest('.cm-editor');
            return activeKeyboard || isReadOnly || isTextarea || isACSSCodeMirror || isStructeezy || isCodeMirror;
        }
        function excludeFromPreview(e) {
            const tagName = e.target.tagName.toLowerCase();
            const isContentEditable = e.target.closest('[contenteditable="true"]');
            const activeKeyboard = self.rightShortcutStates.keyboard !== '1';
            const isInput = tagName === 'input';
            const isTextarea = tagName === 'textarea';
            const isSelect = tagName === 'select';
            const isButton = tagName === 'button';
            return activeKeyboard || isInput || isTextarea || isSelect || isButton || isContentEditable;
        }
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        document.addEventListener('keyup', function(e) {
            const isExcluded = excludeFromBuilder(e);
            !isExcluded ? runShortcuts(e, false) : '';
        });
        x.document.addEventListener('keyup', function(e) {
            const isExcluded = excludeFromPreview(e);
            !isExcluded ? runShortcuts(e, false) : '';
        });
        document.addEventListener('keydown', function(e) {
            const isExcluded = excludeFromBuilder(e);
            !isExcluded ? runShortcuts(e) : '';
        });
        x.document.addEventListener('keydown', function(e) {
            const isExcluded = excludeFromPreview(e);
            !isExcluded ? runShortcuts(e) : '';
        });
    }, 
    setBricksLabs: function (content){
        if(!content || content.length < 1) return;

        const canvas = document.querySelector('#brxcBricksLabsOverlay #brxc-overlay__canvas');
        if(!canvas) return;

        let output = `<div class="brxc-article__container">`;
        content.forEach(article => {
            const rawDate = new Date(article.date);
            const date = rawDate.toLocaleDateString('en-us', { weekday:"short", year:"numeric", month:"short", day:"numeric"});
            output += `<div class="brxc-article__wrapper">
                <div class="brxc-article__col-left">
                <a href="${article.link}" target="_blank"><img src="${article.featured_image_src_square}" /></a>
                </div>
                <div class="brxc-article__col-right">
                    <a href="${article.link}" target="_blank"><h3>${article.title.rendered}</h3></a>
                    <p class="brxc-article__author-wrapper"><i class="brxc-article__author-icon fas fa-calendar-days"></i>${date}<span class="brxc-article__author">by <strong>${article.author_info.display_name}</strong></span></p>
                    <span class="brxc-article__excerpt">${article.excerpt.rendered}</span>
                    <a href="${article.link}" class="brxc-overlay__action-btn secondary brxc-article__readmore" target="_blank">Read more</a>
                </div>
            </div>`;
        })
        output += `</div>`;
        canvas.innerHTML = output;
    },
    bricksLabsAPI: function(target, query = false, openModal = false){
        const self = this;
        (target) ? target.classList.add('disable') : '';
        const wrapper = document.querySelector('#brxcBricksLabsOverlay');

        if(openModal === true && wrapper.dataset.loaded === "true") {
            return;
        }

        let url;
        (query) ? url = 'https://brickslabs.com/wp-json/wp/v2/posts?search=' + query.replace(/\s+/g, '+') : url = 'https://brickslabs.com/wp-json/wp/v2/posts';
        const post = async () => {
            const rawResponse = await fetch(url);
            const content = await rawResponse.json();
            if(content.error){
                console.log('error');
                (target) ? target.classList.remove('disable') : '';
            } else {
                self.setBricksLabs(content);
                wrapper.setAttribute('data-loaded', 'true');
                (target) ? target.classList.remove('disable') : '';
            }
        };

        post();
            
    },
    // setBreakpointsAttributes: function(){
    //     const self = this;
    //     const icons = document.querySelectorAll('#bricks-toolbar .group-wrapper.breakpoints li.breakpoint');
    //     const breakpoints = self.vueState.breakpoints;
    //     breakpoints.forEach(({ label, key }) => {
    //         icons.forEach(icon => {
    //           const text = icon.dataset.balloon;
    //           if (text.includes(label)) {
    //             icon.dataset.key = key;
    //           }
    //         });
    //     });
    // },
    alertMsg: function(autoremove = true, msg, delay){
        const wrapper = document.querySelector('#brxc-alert-message');
        if(!wrapper) return;

        let message = document.createElement('DIV');
        message.setAttribute("id", "brxcAlertMessageContent");
        message.innerHTML = msg;
        setTimeout(() => {
            wrapper.appendChild(message);
            wrapper.setAttribute('active');
        }, 
        setTimeout(() => {
            if(autoremove){
                message = document.querySelector('#brxcAlertMessageContent');
                message.remove();
                wrapper.classList.remove('active');
            }
        }, delay))
    },
    setAlertMsg: function(){
        const msg = document.querySelector('#bricks-message');
        if(!msg) return;
        const html = `<div id="brxc-alert-message"></div>`;
        msg.insertAdjacentHTML("afterend", html);
    },
    setStructurePanelKeyboardShortcuts: function(){
        const self = this;
        const element = document.getElementById('bricks-structure');
        if(!element) return;
        
        const arrowUpHandler = function(e) {
            if (e.shiftKey && e.key === "ArrowUp" && (e.metaKey && e.altKey) === false) {
                self.moveElement(event,'top');
            }
        };
        
        const arrowRightHandler = function(e) {
            if (e.shiftKey && e.key === "ArrowRight" && (e.metaKey && e.altKey) === false) {
                self.moveElement(event,'right');
            }
        };
        
        const arrowDownHandler = function(e) {
            if (e.shiftKey && e.key === "ArrowDown" && (e.metaKey && e.altKey) === false) {
                self.moveElement(event,'down');
            }
        };
        
        const arrowLeftHandler = function(e) {
            if (e.shiftKey && e.key === "ArrowLeft" && (e.metaKey && e.altKey) === false) {
                self.moveElement(event,'left');
            }
        };
        
        const addKeydownListeners = function() {
            document.addEventListener('keydown', arrowUpHandler);
            document.addEventListener('keydown', arrowRightHandler);
            document.addEventListener('keydown', arrowDownHandler);
            document.addEventListener('keydown', arrowLeftHandler);
        };
        
        const removeKeydownListeners = function() {
            document.removeEventListener('keydown', arrowUpHandler);
            document.removeEventListener('keydown', arrowRightHandler);
            document.removeEventListener('keydown', arrowDownHandler);
            document.removeEventListener('keydown', arrowLeftHandler);
        };
        
        element.addEventListener('mouseenter', addKeydownListeners);
        element.addEventListener('mouseleave', removeKeydownListeners);
    },
    initStates: function(){
        const self = this;
        self.vueState.brxcShowImportInput = false;
        self.vueState.brxcShowLock = true;
        self.vueState.brxc.tagsView = self.globalSettings.structurePanelTagDefaultView;
        if(Array.isArray(self.vueState.colorPalette) && self.vueState.colorPalette.length > 0){
            const defaultPalette = Array.from(self.vueState.colorPalette).find(el => el && el.hasOwnProperty('default') && el.default === "true");
            if(defaultPalette) {
                self.colorStates.activePalette = defaultPalette.id
            } else {
                self.colorStates.activePalette = self.vueState.colorPalette[0].id;
            }
        }

        // Set light mode as default
        const x = document.querySelector('#bricks-builder-iframe').contentWindow;
        document.documentElement.setAttribute('data-theme', 'light');
        x.document.documentElement.setAttribute('data-theme', 'light');

    },
    
    populateNestableElements: function(){
        const self = this;
        for(const [key, value] of Object.entries(bricksData.elements)){
            if(bricksData.elements[key].hasOwnProperty('nestableChildren') && bricksData.elements[key].nestableChildren !== null && key !== "section" ) self.nestableElements.push(key);
        }        
    },
    disableMoveElement: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true)
        if(!elementObj) return;

        const content = self.helpers.getContent();
        const contextualMenu = document.querySelector('#bricks-builder-context-menu');
        const left = contextualMenu.querySelector('span[data-balloon="Indent Left"]');
        const right = contextualMenu.querySelector('span[data-balloon="Indent Right"]');
        const up = contextualMenu.querySelector('span[data-balloon="Move Up"]');
        const down = contextualMenu.querySelector('span[data-balloon="Move Down"]');
        const isParent = elementObj.parent === 0 || self.helpers.isComponentRoot(elementObj.parent)

        // Component Root
        if(self.helpers.isComponentRoot(elementObj.id)){
            [left,right,up,down].forEach(el => {
                el.classList.add('disable');
            })
            return;
        }

        // disable indent left
        left.classList.remove('disable');
        if(isParent) left.classList.add('disable');

        // disable indent right
        right.classList.remove('disable');
        // element is on root
        if (isParent) {
            const hasContainer = content.some(el =>
                (el.parent === 0 || self.helpers.isComponentRoot(el.parent)) &&
                el.id !== elementObj.id &&
                bricksData.elements[el.name]?.nestable === true
            );
        
            if (!hasContainer) {
                right.classList.add('disable');
            }
        // element is nested
        } else {
            const parent = elementObj.parent;
            const parentChildren = self.helpers.getElementObject(parent).children;
        
            const hasNestable = parentChildren.some(el =>
                el !== elementObj.id &&
                bricksData.elements[self.helpers.getElementObject(el).name]?.nestable === true
            );
        
            if (!hasNestable) {
                right.classList.add('disable');
            }
        }
        
        //disable move up & down
        up.classList.remove('disable');
        down.classList.remove('disable');

        // element is on root
        if(isParent){
            const rootContent = self.helpers.isComponentActive() ? self.vueState.activeComponent.elements.filter(el => el.hasOwnProperty('parent') && el.parent === self.vueState.activeComponent.id ) : content.filter(el => el && el.hasOwnProperty('parent') && (el.parent === 0));
            const obj = self.helpers.isComponentActive() ? elementObj.id : elementObj;
            if(rootContent.length === 1 || rootContent.indexOf(obj) === 0) up.classList.add('disable');
            if(rootContent.length === 1 || rootContent.indexOf(obj) === rootContent.length -1) down.classList.add('disable');

        // element is nested
        } else {
            const parent = elementObj.parent;
            const parentChildren = self.helpers.getElementObject(parent).children;
            const currentIndex = parentChildren.indexOf(elementObj.id);
            if(!parentChildren[currentIndex - 1]) up.classList.add('disable');
            if(!parentChildren[currentIndex + 1]) down.classList.add('disable');
        }
        

    },
    showHideElement: function(){
        const self = this;
        if(!self.helpers.isElementActive()) return;
        const activeEl = self.helpers.getFinalObject(true);

        // Label
        const hideElement = document.querySelector('#bricks-builder-context-menu #hideElement .label');
        if (!hideElement || typeof activeEl === "undefined") return;
        const target = self.helpers.createTarget('_display');
        if(activeEl.hasOwnProperty('settings') && activeEl.settings.hasOwnProperty(target) && activeEl.settings[target] === "none") {
            hideElement.textContent = `Show Element`;
        } else {
            hideElement.textContent = `Hide Element`;
        }

        // Frontend
        const frontend = document.querySelector('#bricks-builder-context-menu #hideElement .frontend');
        if(frontend){
            if(activeEl.hasOwnProperty('settings') && activeEl.settings.hasOwnProperty('unrenderFrontend') && activeEl.settings.unrenderFrontend === true){
                frontend.classList.add('active');
            } else {
                frontend.classList.remove('active');
            }
        }
        // Builder
        const builder = document.querySelector('#bricks-builder-context-menu #hideElement .builder');
        if(builder){
            if(activeEl.hasOwnProperty('settings') && activeEl.settings.hasOwnProperty('hideElement') && activeEl.settings.hideElement === true){
                builder.classList.add('active');
            } else {
                builder.classList.remove('active');
            }
        }

        // Settings
        const settings = document.querySelector('#bricks-builder-context-menu #hideElement .settings');
        if(settings){
            if(self.hideElementStates.active === true){
                settings.classList.add('active');
            } else {
                settings.classList.remove('active');
            }
        }

    },
    setDeleteWrapper: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        const contextualMenu = document.querySelector("#bricks-builder-context-menu");
        const deleteIcon = contextualMenu.querySelector('li.delete');
        if (!deleteIcon) return; 
        const buttons = deleteIcon.querySelector('div.buttons');
        if (buttons) buttons.remove();
        
        // component
        if(self.helpers.isComponentRoot(elementObj.id)){
            if (buttons) buttons.remove();
            return;
        }

        if(typeof elementObj === "undefined" || !elementObj.hasOwnProperty('children') || !Array.isArray(elementObj.children) || elementObj.children.length < 1) return;
        let icon = `<div class="buttons"><span class="action" data-balloon="Move Children Up" data-balloon-pos="top-right" onClick="ADMINBRXC.deleteWrapper(event);"><i class="fas fa-trash-can-arrow-up"></i></span></div>`;
        deleteIcon.innerHTML += icon;
    },
    deleteWrapper: function(event) {
        event.preventDefault();
        event.stopPropagation();
    
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
    
        if (!elementObj?.children?.length) return;
    
        const parent = elementObj.parent;
        const children = [...elementObj.children];
    
        const content = self.helpers.getContent();
        const siblings = content.filter(el => el.parent === parent);
        let objIndex = siblings.indexOf(elementObj);
    
        children.forEach(childId => {
            const childObj = self.helpers.getElementObject(childId);
            if (childObj) {
                self.vueGlobalProp.$_moveElement({
                    element: childObj,
                    parentId: parent,
                    index: objIndex,
                });
                objIndex++;
            }
        });
    
        self.vueGlobalProp.$_deleteElement(elementObj);
    },
    convertBasicToRichtoHeader: function(newName){
        const self = this;
        const elementObj = self.vueState.activeElement;
        elementObj.name = newName;
        elementObj.settings.tag = newName === "text-basic" ? "p" : bricksData.elements[newName].tag;
    },
    setConvertBasictoRichtoHeader: function(){
        const self = this;
        const elementObj = self.helpers.getFinalObject(true);
        const oldMenu = document.querySelector('#brxcConvertBasicToRich');
        if (oldMenu) oldMenu.remove();
        const contextualMenu = document.querySelector("#bricks-builder-context-menu li.wrap");
        if(!contextualMenu) return; 

        const name = elementObj.name;
        if (name === 'text' || name === 'text-basic' || name === 'heading'){
            let icons = '';
            icons += `<li id="brxcConvertBasicToRich" class="convert sep"><span class="label">Convert </span>`;
            (name !== 'text-basic') ? icons += `<div class="buttons"><span data-balloon="Basic Text" data-balloon-pos="top" onclick="ADMINBRXC.convertBasicToRichtoHeader('text-basic')"><i class="ti-align-justify"></i></span>` : '';
            (name !== 'text') ? icons += `<div class="buttons"><span data-balloon="Rich Text" data-balloon-pos="top" onclick="ADMINBRXC.convertBasicToRichtoHeader('text')"><i class="ti-align-left"></i></span>` : '';
            (name !== 'heading') ? icons += `<div class="buttons"><span data-balloon="Heading" data-balloon-pos="top" onclick="ADMINBRXC.convertBasicToRichtoHeader('heading')"><i class="ti-text"></i></span>` : '';
            icons += `</div></li>`;
            contextualMenu.insertAdjacentHTML("afterEnd", icons);
        }
        
    },
    importCSSfromElements: function(btn,cm,type,scope){
        const self = this;
        const existingCSS = cm.getValue();
        const dataOptions = { indent_size: 2 };
        const contentArr = self.helpers.getContent();
        let content;
        if (type === "id"){
            
            content = contentArr
        } else if(scope === "global"){
            content = self.vueState.globalClasses;
        } else if(scope === "page"){
            let activeClasses = [];
            contentArr.forEach(el => {
                if(el.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(el.settings._cssGlobalClasses)) activeClasses = activeClasses.concat(el.settings._cssGlobalClasses);
            })
            content = Array.from(self.vueState.globalClasses).filter(el => el && el.hasOwnProperty('id') && activeClasses.includes(el.id));
        }
        let css = "";
        const mq = (self.vueGlobalProp.$_isMobileFirst._value) ? 'min' : 'max';
        self.vueState.breakpoints.forEach(bp => {
            if(bp.hasOwnProperty('base') && bp.base === true) {
                if(content.length > 0){
                    content.forEach(el => {
                        if(el.hasOwnProperty('settings') && el.settings.hasOwnProperty('_cssCustom')) {
                            css += el.settings._cssCustom;
                            delete el.settings._cssCustom;
                        }
                    })
                }
            } else{
                if(content.length > 0){
                    let hasStyle = false;
                    let cssTemp = '';
                    content.forEach(el => {
                        const property = `_cssCustom:${bp.key}`;
                        if(el.hasOwnProperty('settings') && el.settings.hasOwnProperty(property)) {
                            hasStyle = true;
                            cssTemp += el.settings[property];
                            delete el.settings[property];
                        }
                    })
                    if(hasStyle){
                        css += `@media (${mq}-width: ${bp.width}px){`;
                        css += cssTemp; 
                        css += '}'; 
                    }
                }
            }
        })
        
        css = css_beautify(css, dataOptions)
        
        cm.setValue(`${existingCSS}\n${css}`);
        const span = btn.parentElement.querySelector('span');
        setTimeout(() => {
            span.innerHTML = "CSS Imported Successfully!";
        }, setTimeout(() => {
            span.innerHTML = "Import CSS from Global Classes";
        }, 2000))

    },
    generateSelectors: function(btn,cm, incudeMQ){
        const self = this;
        if (!self.helpers.isElementActive()) {
            const wrapper = document.querySelector('#brxcCSSOverlay .brxc-overlay__error-message-wrapper');
            let inner = `<div class="brxc-ai-response-wrapper remove-on-reset">`;
            inner += `<div name="error-css-msg" class="error-message" id="cssErrorMsg"><i class="bricks-svg ti-close" onClick="this.parentElement.parentElement.remove()"></i>Error: Select an element inside the Structure Panel</div></div>`;
            wrapper.innerHTML = inner;
            return;
        }

        const existingCSS = cm.getValue();
        const dataOptions = { indent_size: 2 };
        const mq = (self.vueGlobalProp.$_isMobileFirst._value) ? 'min' : 'max';
        let existingSelector = [];
        let selector = false;
        function createSelector(obj,existingSelector){
            if (obj.settings.hasOwnProperty('_cssGlobalClasses') && Array.isArray(obj.settings._cssGlobalClasses) && obj.settings._cssGlobalClasses.length > 0) {
                const unlocked = [];
                const locked = [];
                obj.settings._cssGlobalClasses.forEach(el => {
                    (self.vueGlobalProp.$_isLocked(el)) ? locked.push(el) : unlocked.push(el);
                });
                const ids = (unlocked.length > 0) ? unlocked : locked;
                if (ids.length > 0) {
                    let classes = [] 
                    ids.forEach(id => {
                        const classObj = self.vueGlobalProp.$_getGlobalClass(id);
                        if(classObj && classObj.hasOwnProperty('name')){
                            classes.push(classObj.name);
                        }
                    })
                    selector = `.${classes.join('.')}`;
                } else {
                    selector = false;
                }
            } else {
                selector = `#${self.vueGlobalProp.$_getElementId(obj)}`;
            } 
            if(selector === false || existingSelector.includes(selector)) return "";
            existingSelector.push(selector);
            return `${selector}{}`;
        }
        let css = "";
        function checkChildren(obj, first){
            if(first === true) existingSelector = [];
            css += createSelector(obj,existingSelector);
            if(obj.children.length < 1) return;
            obj.children.forEach(child =>{
                checkChildren(self.helpers.getElementObject(child), false);
            })
        }
        self.vueState.breakpoints.forEach(bp => {
            if(bp.hasOwnProperty('base') && bp.base === true) {
                checkChildren(self.helpers.getFinalObject(true), true);
            } else if(incudeMQ === true){
                css += `@media (${mq}-width: ${bp.width}px){`;
                checkChildren(self.helpers.getFinalObject(true), true);
                css += '}'; 
            }
        })
        css = css_beautify(css, dataOptions)
        cm.setValue(`${existingCSS}\n${css}`);
        const span = btn.parentElement.querySelector('span');
        setTimeout(() => {
            span.innerHTML = "Selectors Generated Successfully!";
        }, setTimeout(() => {
            span.innerHTML = "Generate Selectors";
        }, 2000))
    },
    setRootClassComponentToggle: function(){
        const self = this;

        // Remove Buttons
        if(!self.helpers.isElementActive()) return
        
        const elementObj = self.helpers.getFinalObject(true);
        if(!bricksData.elements[elementObj.name].hasOwnProperty('nestable') || bricksData.elements[elementObj.name].nestable !== true) {
            const buttons = document.querySelector('#brxcBEMConverter .buttons');
            if (buttons) buttons.remove(); 
            return;
        }
        const li = document.querySelector('#brxcBEMConverter');
        if(!li) return;

        // Add Buttons
        const buttons = li.querySelector('#brxcBEMConverter .buttons');
        if (!buttons){
            const newButtons = document.createElement('DIV');
            newButtons.classList.add('buttons')
            newButtons.innerHTML = `<span class="action" data-balloon="Enable Root Element" data-balloon-pos="top" onclick="event.stopPropagation();ADMINBRXC.rootClassComponentToggle(true)"><i class="fas fas fa-toggle-off"></i></span>`;
            li.appendChild(newButtons);
        }

        const txt = document.querySelector('#brxcBEMConverter span.action');
        if(!txt) return;

        const icon = document.querySelector('#brxcBEMConverter span.action i');
        if(!icon) return;

        if(elementObj.settings.hasOwnProperty('classConverterComponent') && elementObj.settings.classConverterComponent === true){
            txt.dataset.balloon = "Disable Root Component";
            icon.classList.remove('fa-toggle-off')
            icon.classList.add('fa-toggle-on')
        } else {
            txt.dataset.balloon = "Enable Root Component";
            icon.classList.remove('fa-toggle-on')
            icon.classList.add('fa-toggle-off')
        }
    },
    rootClassComponentToggle: function(isStructurePanel = false){
        const self = this;
        if(!self.helpers.isElementActive()) return;

        const elementObj = self.helpers.getFinalObject(true);

        if(elementObj.settings.hasOwnProperty('classConverterComponent') && elementObj.settings.classConverterComponent === true){
            delete elementObj.settings.classConverterComponent;
        } else {
            elementObj.settings.classConverterComponent = true;
        }

        self.vueState.showContextMenu = false;
        if(isStructurePanel){
            self.vueState.showContextMenu = elementObj.id;
            
        } else {
            self.openClassContextualMenu();
        }
    },
    initContextualMenuObservers: function(){
        const self = this;
        const contextualMenu = document.querySelector('#bricks-builder-context-menu');

        const observer = new MutationObserver(function(mutation) {
            const contextualMenu = document.querySelector('#bricks-builder-context-menu');
            if(self.vueState.brxcRunningMenuObserver === true || window.getComputedStyle(contextualMenu).display === 'none') return;
            self.vueState.brxcRunningMenuObserver = true;

            if(self.helpers.isBuilderTweaksTabActive('structure-panel')){
                Object.values(self.globalSettings.structurePanelContextualMenu).includes('move-element') ? self.disableMoveElement() : '';
                Object.values(self.globalSettings.structurePanelContextualMenu).includes('hide-element') ? self.showHideElement() : '';
                Object.values(self.globalSettings.structurePanelContextualMenu).includes('delete-wrapper') ? self.setDeleteWrapper(): '';
                Object.values(self.globalSettings.structurePanelContextualMenu).includes('convert-text') ? self.setConvertBasictoRichtoHeader() : '';
                self.helpers.isBuilderTweaksTabActive('structure-panel') && Object.values(self.globalSettings.structurePanelContextualMenu).includes('class-converter') ? self.setRootClassComponentToggle() : '';
            }

            setTimeout(() => self.vueState.brxcRunningMenuObserver = false, 100)
        });

        observer.observe(contextualMenu, { subtree: true, childList: true, attributes: true, attributeFilter: ['style'] });
    },
    getSelectorsFromFile: function (file) {
        // Remove comments from the file
        file = file.replace(/\/\*[\s\S]*?\*\//g, '');
    
        // Remove media query declarations but keep the content
        file = file.replace(/@media[^{]*\{/gi, '');
    
        // Close remaining brackets from media queries
        file = file.replace(/\s*}\s*(?=})/g, '');
    
        // Pattern One: Match text within curly braces {}
        const patternOne = /\{([^}]*)\}/g;
    
        // Pattern Two: Match dot notation (e.g., .example-name) excluding comments
        const patternTwo = /\.([a-zA-Z0-9_-]+)\b/g;
    
        const stripped = file.replace(patternOne, '');
    
        const selectors = [...stripped.matchAll(patternTwo)].map((match) => match[1]);
    
        return Array.from(new Set(selectors));
    },
    getVariablesFromFile: function (file) {
        // Remove comments from the file
        file = file.replace(/\/\*[\s\S]*?\*\//g, '');
        
        // Remove media query declarations but keep the content
        file = file.replace(/@media[^{]*\{/gi, '');
        
        // Close remaining brackets from media queries
        file = file.replace(/\s*}\s*(?=})/g, '');
        
        // Pattern to match CSS variable declarations without capturing the '--' prefix
        const variablePattern = /--([a-zA-Z0-9_-]+)\s*:\s*[^;]+;/g;
        
        // Extract variable names without the '--' prefix
        const variables = [...file.matchAll(variablePattern)].map((match) => match[1]);
        
        // Return unique variable names
        return Array.from(new Set(variables));;
    },

    parseGlobalCSS: function(key){
        const self = this;
        const cm = document.querySelector(key + ' .CodeMirror[data-type="at"]')
        if(!cm) return;

        const file = cm.CodeMirror.getValue();

        const allClasses = self.getSelectorsFromFile(file);
        let itemFound = 0;
        if(Array.isArray(allClasses) && allClasses.length >0){
            allClasses.forEach(el => {
                const found = Array.from(self.vueState.globalClasses).find(e => e && e.hasOwnProperty('name') &&  e.name === el);
                if(!found){
                    itemFound++;

                    // Generate ID
                    const id = self.vueGlobalProp.$_generateId();

                    // Generate new global class
                    self.generateGlobalClass('globalCSS',el, false, id);

                    // Lock the class
                    if(!self.vueState.globalClassesLocked.includes(`globalCSS${id}`)) self.vueState.globalClassesLocked.push(`globalCSS${id}`);
                }
            })
        }
        const message = () => {
            if(itemFound > 0) {
                return `<span>${itemFound} Classes Exported Successfully!</span>`;
            } else if(itemFound === 0){
                return `<span>Abort: no new class found!</span>`;
            } else {
                return '<span>Error: No Class has been exported</span>'
            }
        }
        self.vueGlobalProp.$_showMessage(message());
    },
    extractGlobalVariables: function(key){
        const self = this;
        const cm = document.querySelector(key + ' .CodeMirror[data-type="at"]')
        if(!cm) return;

        const file = cm.CodeMirror.getValue();
        const allVariables = self.getVariablesFromFile(file);

        let itemFound = 0;
        if(Array.isArray(allVariables) && allVariables.length >0){
            allVariables.forEach(el => {
                const found = Array.from(self.vueState.globalVariables).find(e => e && e.hasOwnProperty('name') &&  e.name === el);
                if(!found){
                    itemFound++;
                    const id = self.vueGlobalProp.$_generateId();

                    self.vueState.globalVariables.push({
                        id: id,
                        name: el,
                    })
                }
            })
        }
        const message = () => {
            if(itemFound > 0) {
                return `<span>${itemFound} Variables Exported Successfully!</span>`;
            } else if(itemFound === 0){
                return `<span>Abort: no new Variable found!</span>`;
            } else {
                return '<span>Error: No Variable has been exported</span>'
            }
        }
        self.vueGlobalProp.$_showMessage(message());
    },
    setDefaultElements: function(){
        const self = this;

        // Heading Textarea
        if (Object.values(self.globalSettings.defaultElementFeatures).includes('heading-textarea')) bricksData.elements.heading.controls.text.type = "textarea";

    },
    populateClassCategories: function(){
        const self = this;
        const finalCats = typeof self.vueState.globalClassesCategories !== "undefined" ? ['All', 'Uncategorized'].concat(Array.from(self.vueState.globalClassesCategories).filter(el => el && el.name).map(el => el && el.name).sort((a, b) => a.localeCompare(b, undefined, {sensitivity: 'base'}))) : false; 
        self.states.classManagerCategories = finalCats;
    },
    refreshColorPrefix: function(){
        const self = this;
        const palettes = self.vueState.colorPalette;
        if(!Array.isArray(palettes) || palettes.length < 1) return;
        let hasChanged = false;
        palettes.forEach(palette => {
            if(!palette.hasOwnProperty('colors') || !Array.isArray(palette.colors) || palette.colors.length < 1) return;
            palette.colors.forEach(color => {
                if (!color.hasOwnProperty('raw') || !color.hasOwnProperty('name') || !color.hasOwnProperty('rawValue') || !color.rawValue.hasOwnProperty('light')) return;
                const name = self.helpers.setColorPrefix(self.helpers.formatForClasses(color.name), self.helpers.isFramework(color.id));
                if (color.raw !== `var(--${name})`) {
                    color.raw = `var(--${name})`;
                    hasChanged = true;
                }
            })
        })
        if (hasChanged) self.helpers.saveChanges('colorPalette');
    },
    setColorVariablesOnLoad: function(){
        const self = this;
        self.generateColorCSS();
        self.refreshColorPrefix();
    },
    setResponsiveHelper: function(item){
        const self = this;
        const slider = document.querySelector('#brxcResponsiveBar')
        if(!slider) return;
        if(item.classList.contains('active')) {
            item.classList.remove('active');
            slider.classList.remove('active');
        } else {
            item.classList.add('active');
            slider.classList.add('active');
        } 
    },
    setResponsiveBar: function(){
        const self = this;
        document.body.classList.add('responsive-helper');
        const iframePreview = document.querySelector('#bricks-preview');
        const container = document.createElement('div');
        container.id = "brxcResponsiveBar";
        let content = `<div class="brxc-range-input-wrapper brxc__range"><div class="brxc-range-input-container"><input type="range" min="1" max="2000" value="1201" class="brxc-input__range${self.vueGlobalProp.$_isMobileFirst._value ? ' reverse' : ''}" oninput="ADMINBRXC.responsiveBar(this);">`
        self.vueState.breakpoints.forEach((bp, index) => {
            content += index > 0 ? `<div class="bp-marker" style="${self.vueGlobalProp.$_isMobileFirst._value ? 'left' : 'right'}: calc((${bp.width - 1} - 0) / (2000 - 0) * 100%)"></div>` : '';
        })
        content += `<div class="ruler">`;
        const rulerArr = self.vueGlobalProp.$_isMobileFirst._value ? [0,200,400,600,800,1000,1200,1400,1600,1800,2000] : [1800,1600,1400,1200,1000,800,600,400,200,0];
        rulerArr.forEach( r => {
            content += `<div class="interval">${r}px</div>`
        }) 
        content += `</div>`;
        content += `</div></div>`;
        container.innerHTML = content;
        iframePreview.prepend(container);

        // listener
        const toolbarItems = document.querySelectorAll('#bricks-toolbar li');
        if (!toolbarItems || toolbarItems.length < 1) return;

        function isDesktop(bp){
            const isMobileFirst = self.vueGlobalProp.$_isMobileFirst._value;
            if(isMobileFirst){
                if(self.vueState.breakpoints.indexOf(bp) === self.vueState.breakpoints.length - 1) return true;
                return false;
                
            } else {
                if(self.vueState.breakpoints.indexOf(bp) === 0) return true;
                return false;
            }
        }

        function isMobile(bp){
            const isMobileFirst = self.vueGlobalProp.$_isMobileFirst._value;
            if(isMobileFirst){
                if(self.vueState.breakpoints.indexOf(bp) === 0) return true;
                return false;
                
            } else {
                if(self.vueState.breakpoints.indexOf(bp) === self.vueState.breakpoints.length - 1) return true;
                return false;
            }
        }
        
        toolbarItems.forEach(el => {
            const slider = document.querySelector('#brxcResponsiveBar input');
            if(!slider) return;
            el.addEventListener('click', () => {
                const isMobileFirst = self.vueGlobalProp.$_isMobileFirst._value;
                if(el.classList.contains('breakpoint')){
                    const bp = self.vueState.breakpoints.find(el => el && el.key === self.vueState.breakpointActive)
                    const bpNext = self.vueState.breakpoints[self.vueState.breakpoints.indexOf(bp) + 1];
                    if(el.dataset.click === 'true') {
                        toolbarItems.forEach(el => el.removeAttribute('data-click'))
                        let minValue;

                        // Calculate  minValue
                        if(isMobileFirst){
                            self.vueState.previewWrapperWidth > bp.width ? minValue = self.vueState.previewWrapperWidth : minValue = 1400
                        } else {
                            isMobile(bp) && bp.hasOwnProperty('widthBuilder') ? minValue = bp.widthBuilder : minValue = 320
                        }
                        
                        // Calculate previewWidth
                        if(bpNext) {
                            const nextValue = isMobileFirst ? bpNext.width - 1 : bpNext.width + 1;
                            self.vueState.previewWidth = nextValue;
                        } else {
                            self.vueState.previewWidth = minValue
                        }
                    } else {
                        toolbarItems.forEach(el => el.removeAttribute('data-click'))
                        el.setAttribute('data-click', 'true');
                        if((!isMobileFirst && isDesktop(bp) && bp.hasOwnProperty('widthBuilder')) || (isMobileFirst && isMobile(bp) && bp.hasOwnProperty('widthBuilder'))){
                            self.vueState.previewWidth = bp.widthBuilder;
                        } else if(!isMobileFirst && isDesktop(bp) && self.vueState.previewWrapperWidth > bp.width){
                            self.vueState.previewWidth = self.vueState.previewWrapperWidth;
                        } else {
                            self.vueState.previewWidth = bp.width;
                        }
                    }
                }
                
                slider.value = self.vueState.previewWidth;
            })

            const input = el.querySelector('input');
            if(!input) return;
            input.addEventListener('keyup', () => {
                setTimeout(() => {
                    slider.value = self.vueState.previewWidth;
                },1)
            })
        })

        const firstBp = document.querySelectorAll('#bricks-toolbar li.breakpoint')[0];
        if(firstBp) firstBp.setAttribute('data-click', 'true');

    },
    responsiveBar: function(target){
        const self = this;
        self.vueState.previewWidth = target.value;

        if (self.debounceTimer) {
            clearTimeout(self.debounceTimer);
        }

        self.debounceTimer = setTimeout(() => {
            const original = self.vueState.breakpoints;
            const bps = original.slice();
            let device;
            bps.forEach(bp => {
                if(self.vueGlobalProp.$_isMobileFirst._value){
                    if (target.value >= bp.width) device = bp.key;
                } else {
                    if (target.value <= bp.width) device = bp.key;
                }
            })

            device ? self.vueState.breakpointActive = device : self.vueState.breakpointActive = self.vueState.breakpoints[0].key;
            setTimeout(() => self.vueState.previewWidth = target.value, 0);
        }, 100);
    },
    hideEmptyElementCategory: function(){
        const cats = document.querySelectorAll('#bricks-panel-elements-categories .category');
        if(!cats || cats.length < 1) return;
        cats.forEach(cat => {
            const els = cat.querySelectorAll('.sortable-wrapper > li');
            if(!els || els.length < 1) return;
            let isHidden = true;
            els.forEach(el => {
                const display = window.getComputedStyle( el ,null).getPropertyValue('display');
                if(display !== 'none') isHidden = false;
            })
            if(isHidden) cat.style.display = "none";
        })
    },
    draggableStructurePanelStates: {
        structureOffsetX: null,
        structureOffsetY: null,
        structureWidth: 400,
    },
    draggableStructurePanel: function () {
        const self = this;
        const structure = document.querySelector('#bricks-structure');
        const preview = document.querySelector('#bricks-preview');
        const header = structure.querySelector('#bricks-panel-header .title');
    
        function move(e) {
            structure.style.setProperty('--right', `${e.clientX - self.draggableStructurePanelStates.structureOffsetX}px`);
            structure.style.setProperty('--width', `${self.draggableStructurePanelStates.structureWidth}px`);
            structure.style.setProperty('--top', `${e.clientY - self.draggableStructurePanelStates.structureOffsetY}px`);
        }
    
        let structureIsDraggable = false; // Track the draggable state
    
        function toggleDraggableState() {
            structureIsDraggable = !structureIsDraggable;
            structure.setAttribute('data-draggable', structureIsDraggable);
            preview.setAttribute('data-draggable', structureIsDraggable);
        }
    
        function setupDraggable() {
            header.addEventListener("mousedown", handleMouseDown);
            document.addEventListener("mouseup", handleMouseUp);
            document.addEventListener("contextmenu", handleMouseUp)
        }
    
        function resetDraggable() {
            header.removeEventListener("mousedown", handleMouseDown);
            document.removeEventListener("mouseup", handleMouseUp);
            document.removeEventListener("contextmenu", handleMouseUp)
        }
    
        function handleDoubleClick(e) {
            toggleDraggableState();
            if(structureIsDraggable){
                move(e)
                setupDraggable()
            } else {
                resetDraggable();
            }
        }
    
        function handleMouseDown(e) {
            preview.style.pointerEvents = "none";
            self.draggableStructurePanelStates.structureOffsetX = e.clientX - structure.offsetLeft;
            self.draggableStructurePanelStates.structureOffsetY = e.clientY - structure.offsetTop;
            self.draggableStructurePanelStates.structureWidth = structure.getBoundingClientRect().width;
            document.addEventListener('mousemove', move);
        }
    
        function handleMouseUp() {
            preview.style.pointerEvents = "auto";
            document.removeEventListener("mousemove", move);
        }
    
        // Initial setup
        header.addEventListener('dblclick', handleDoubleClick);
    },
    codepenStates: {
        includesIds: true,
        excludeIds: '',
        includesClasses: true,
        excludeClasses: '',
        createGlobalClasses: false,
        includesTexts: true,
        includesAttributes: true,
        excludeAttributes: '',
    },
    setCodepenImporter: function(){
        const self = this;
        const modal = document.querySelector('#brxcCodePenImporter');
        const textareas = modal.querySelectorAll('textarea');
        textareas.forEach(textarea => {
            const options = self.codeMirrorOptions(textarea);
            options.mode = textarea.dataset.mode;
            options.styleActiveLine = true;
            options.selfContain = true;
            if(textarea.dataset.mode === "css" || textarea.dataset.mode === "javascript"){
                options.autoCloseBrackets = true;
            }
            if(textarea.dataset.mode === "htmlmixed"){
                options.autoCloseTags = true;
                options.matchTags = true;
                options.profile = "xhtml";
            }
            options.hintOptions = {
                schemaInfo: {
                  html: true  // Enable HTML schema-based hints
                }
            };
            options.search = { bottom: false };
            const MyCM = CodeMirror.fromTextArea(textarea, options);
            emmetCodeMirror(MyCM);
            MyCM.getWrapperElement().setAttribute("data-type", "at");

            // autocomplete
            MyCM.on("keydown", function (cm, event) {
                event.stopPropagation();
                // Check if the completion is not already active
                if (!cm.state.completionActive &&
                    (
                    // Trigger autocomplete only for these keys
                    (event.key >= 'a' && event.key <= 'z') || 
                    event.key === '-' || 
                    event.key === '<' || 
                    event.key === '/') &&
                    // Ensure autocomplete is triggered only when it's appropriate
                    !event.metaKey && !event.altKey && !event.ctrlKey && 
                    event.key !== '{' && event.key !== '}') {

                
                    // Force the autocomplete dropdown to appear without auto-completing
                    CodeMirror.commands.autocomplete(cm, null, { completeSingle: false, hintOptions: { completeSingle: false } });
                    
                }
    
                if(event.metaKey && event.shiftKey && event.key === "7" ){
                    cm.toggleComment();
                }
            })

        })
    },
    codepenImporterInit: function(){
        const self = this;
        const canvas = document.querySelector('#brxcCpImporterFilterCanvas');
        const objs = [
            {
                label: "Include ID's?",
                balloon: "If this option is checked, the original ID of each element will be imported.",
                data: "click",
                prop: "includesIds",
                require: true,
            },
            {
                label: "Exclude ID's that contain:",
                balloon: "Type keywords that will exclude the ID's to be imported. For multiple keywords, separate each word by a comma.",
                data: "input",
                prop: "excludeIds",
                require: self.codepenStates.includesIds,
                placeholder: 'brx-,brxe-',
            },
            {
                label: "Include Classes?",
                balloon: "If this option is checked, the original classes of each element will be imported.",
                data: "click",
                prop: "includesClasses",
                require: true,
            },
            {
                label: "Exclude Classes that contain:",
                balloon: "Type keywords that will exclude the classes to be imported. For multiple keywords, separate each word by a comma.",
                data: "input",
                prop: "excludeClasses",
                require: self.codepenStates.includesClasses,
                placeholder: 'brx-,brxe-',
            },
            {
                label: "Generate Global Classes?",
                balloon: "By default, if a class is not present in the Global Class list, it will be added as a CSS Class. If you enable this option, it will create a dedicated Global Class instead.",
                data: "click",
                prop: "createGlobalClasses",
                require: self.codepenStates.includesClasses,
            },
            {
                label: "Include Attributes?",
                balloon: "If this option is checked, the original attributes of each element will be imported.",
                data: "click",
                prop: "includesAttributes",
                require: true,
            },
            {
                label: "Exclude Attributes that contain:",
                balloon: "Type keywords that will exclude the attributes to be imported. For multiple keywords, separate each word by a comma.",
                data: "input",
                prop: "excludeAttributes",
                require: self.codepenStates.includesAttributes,
                placeholder: 'href,src',
            },
        ]
        let content = `<span class="gridUI__title">IMPORT SETTINGS</span>`;
        objs.forEach(obj => {
            if(obj.data === "click" && obj.require){
                content += `<div class="gridUI__input-wrapper">
                        <label class="has-tooltip">
                            <span>${obj.label}</span>
                            <div data-balloon="${obj.balloon}" data-balloon-pos="bottom" data-balloon-length="medium">
                                <i class="fas fa-circle-question"></i>
                            </div>
                        </label>
                        <i class="fas fa-toggle-${self.codepenStates[obj.prop] === true ? 'on' : 'off'}" data-click="${obj.prop}"></i>
                    </div>`
            }
            if(obj.data === "input" && obj.require){
                content += `<div class="gridUI__input-wrapper brxc-input">
                        <label class="has-tooltip">
                            <span>${obj.label}</span>
                            <div data-balloon="${obj.balloon}" data-balloon-pos="bottom" data-balloon-length="medium">
                                <i class="fas fa-circle-question"></i>
                            </div>
                        </label>
                        <input class="brxc-input-text" data-input="${obj.prop}" value="${self.codepenStates[obj.prop]}" placeholder="${obj.placeholder}"/>
                    </div>`
            }
        })
        
        canvas.innerHTML = content;
        
        // Listeners
        canvas.querySelectorAll('[data-click]').forEach(input => {
            input.addEventListener('click', (e) => {
                const prop = input.dataset.click;
                self.codepenStates[prop] = !self.codepenStates[prop];
                self.codepenImporterInit();
            })
        })
        canvas.querySelectorAll('[data-input]').forEach(input => {
            input.addEventListener('input', (e) => {
                const prop = input.dataset.input;
                self.codepenStates[prop] = e.target.value;
            })
        })
    },
    htmlImporter: function (cmValues, states) {
        const self = this;
        const rootId = self.vueGlobalProp.$_generateId();
        const contentType = self.helpers.getTemplateType();
    
        // Check if activeElement exists and determine if it's on the root
        const activeElement = self.vueState.activeElement;
        const isParent = self.helpers.isElementActive() ? self.helpers.isElementOnRoot(activeElement.parent) : false;
    
        // Determine the parent ID
        let parentId;
    
        if (!activeElement || (isParent && !self.vueGlobalProp.$_isNestable())) {
            // If activeElement is undefined or it's on the root and not nestable
            parentId = 0;
        } else if (self.vueGlobalProp.$_isNestable()) {
            // If nestable, use active ID as parent
            parentId = self.vueState.activeId;
            self.helpers.getElementObject(parentId).children.push(rootId);
        } else {
            // Use the parent of the active element as parent
            parentId = activeElement.parent;
            self.helpers.getElementObject(parentId).children.push(rootId);
        }
    
        // Parse HTML string into an object array
        const arr = self.helpers.parseHtmlStringToObjectArray(rootId, parentId, cmValues, states);
    
        // Concat parsed elements into the correct content structure
        if (self.helpers.isComponentActive()) {
            self.vueState.activeComponent.elements = self.vueState.activeComponent.elements.concat(arr.reverse());
        } else {
            self.vueState[contentType] = self.vueState[contentType].concat(arr.reverse());
        }
    
        // Notify and open the imported element
        setTimeout(() => {
            self.openElement(rootId);
            self.vueGlobalProp.$_showMessage('Codepen imported Successfully!');
        }, 10);
    },
    
    codepenImporter: function(){
        const self = this;
        const modal = document.querySelector('#brxcCodePenImporter');
        const cms = modal.querySelectorAll('.CodeMirror');
        const cmValues = {
            html: cms[0].CodeMirror.getValue() !== "" ? cms[0].CodeMirror.getValue() : false,
            css: cms[1].CodeMirror.getValue() !== "" ? cms[1].CodeMirror.getValue() : false,
            js: cms[2].CodeMirror.getValue() !== "" ? cms[2].CodeMirror.getValue() : false,
        }
        self.htmlImporter(cmValues, self.codepenStates);
    },
    generatedAIStructureStates: {
        mainPrompt: '',
        elementsLabels: true,
        includesIds: true,
        excludeIds: '',
        includesClasses: true,
        excludeClasses: '',
        createGlobalClasses: true,
        bemClasses: true,
        bricksVariables: false,
        bricksVariablesArr: [],
        bricksColors: false,
        bricksColorsArr: [],
        includesTexts: true,
        includesAttributes: true,
        excludeAttributes: '',
    },
    generatedAIStructureInit: function(){
        const self = this;
        const canvas = document.querySelector('#brxcAIGeneratedStructureCanvas');
        if(!canvas) return;
        const objs = [
            {
                label: "Generate Global Classes?",
                balloon: "By default, if a class is not present in the Global Class list, it will be added as a CSS Class. If you enable this option, it will create a dedicated Global Class instead.",
                data: "click",
                prop: "createGlobalClasses",
                require: true,
            },
            {
                label: "Use BEM classes?",
                balloon: "Enable this toggle if you wish the generated classes to follow the BEM methodology.",
                data: "click",
                prop: "bemClasses",
                require: true,
            },
            {
                label: "Use the Bricks/AT Global Variables?",
                balloon: "Enable this toggle if you wish to include your Bricks/AT Variable list to the prompt.",
                data: "click",
                prop: "bricksVariables",
                require: true,
            },
            {
                label: "Select the Categories you want to include:",
                balloon: "Click on the following categories to include the corresponding variables inside the AI prompt",
                data: "select",
                dataArr: self.vueState.globalVariablesCategories,
                prop: "bricksVariablesArr",
                require: self.generatedAIStructureStates.bricksVariables,
            },
            {
                label: "Use AT's Global Color variables?",
                balloon: "Enable this toggle if you wish to include your AT's Global Variable list to the prompt.",
                data: "click",
                prop: "bricksColors",
                require: true,
            },
            {
                label: "Select the Palette(s) you want to include:",
                balloon: "Click on the following palettes to include the corresponding variables inside the AI prompt",
                data: "select",
                dataArr: self.vueState.colorPalette,
                prop: "bricksColorsArr",
                require: self.generatedAIStructureStates.bricksColors,
            },
            {
                label: "Generate labels for each element?",
                balloon: "Enable this toggle if you want AI to update the labels of all the generated elements in the structure.",
                data: "click",
                prop: "elementsLabels",
                require: true,
            },
        ]
        let content = `<div class="gridUI__left-col">
                            <div class="gridUI__input-wrapper brxc-input">
                                <label class="has-tooltip">
                                    <span>Main prompt</span>
                                    <div data-balloon="Describe here how the HTML tree should be structured. Be as specific as possible for better results." data-balloon-pos="bottom" data-balloon-length="medium">
                                        <i class="fas fa-circle-question"></i>
                                    </div>
                                </label>
                                <textarea class="brxc-input-text" data-input="mainPrompt" placeholder="Type your prompt here..."/>${self.generatedAIStructureStates['mainPrompt']}</textarea>
                            </div>
                        </div>
                        <div class="gridUI__right-col"><span class="gridUI__title">AI SETTINGS</span>`;
        objs.forEach(obj => {
            if(obj.data === "click" && obj.require){
                content += `<div class="gridUI__input-wrapper">
                        <label class="has-tooltip">
                            <span>${obj.label}</span>
                            <div data-balloon="${obj.balloon}" data-balloon-pos="bottom" data-balloon-length="medium">
                                <i class="fas fa-circle-question"></i>
                            </div>
                        </label>
                        <i class="fas fa-toggle-${self.generatedAIStructureStates[obj.prop] === true ? 'on' : 'off'}" data-click="${obj.prop}"></i>
                    </div>`
            }
            if(obj.data === "input" && obj.require){
                content += `<div class="gridUI__input-wrapper brxc-input">
                        <label class="has-tooltip">
                            <span>${obj.label}</span>
                            <div data-balloon="${obj.balloon}" data-balloon-pos="bottom" data-balloon-length="medium">
                                <i class="fas fa-circle-question"></i>
                            </div>
                        </label>
                        <textarea class="brxc-input-text" data-input="${obj.prop}" placeholder="${obj.placeholder}"/>${self.generatedAIStructureStates[obj.prop]}</textarea>
                    </div>`
            }
            if(obj.data === "select" && obj.require){
                content += `<div class="gridUI__input-wrapper brxc-input select">
                        <label class="has-tooltip">
                            <span>${obj.label}</span>
                            <div data-balloon="${obj.balloon}" data-balloon-pos="bottom" data-balloon-length="medium">
                                <i class="fas fa-circle-question"></i>
                            </div>
                        </label>
                        <div class="brxc-overlay__action-btn-wrapper">`
                        obj.dataArr.forEach(el => {
                            content += `<div class="brxc-overlay__action-btn${self.generatedAIStructureStates[obj.prop].includes(el.id) ? ' active' : ''}" data-select="${obj.prop}" data-id="${el.id}">${el.name}</div>`
                        })
                        content += `</div></div>`;
            }
        })
        content += `</div>`;
        
        canvas.innerHTML = content;

        // Listeners
        canvas.querySelectorAll('[data-click]').forEach(input => {
            input.addEventListener('click', (e) => {
                const prop = input.dataset.click;
                self.generatedAIStructureStates[prop] = !self.generatedAIStructureStates[prop];
                self.generatedAIStructureInit();
            })
        })
        canvas.querySelectorAll('[data-input]').forEach(input => {
            input.addEventListener('input', (e) => {
                const prop = input.dataset.input;
                self.generatedAIStructureStates[prop] = e.target.value;
            })
        })
        canvas.querySelectorAll('[data-select]').forEach(input => {
            input.addEventListener('click', (e) => {
                const prop = input.dataset.select;
                const id = input.dataset.id;
        
                // Check if the array doesn't contain the ID and push it if not present
                if (!self.generatedAIStructureStates[prop].includes(id)) {
                    self.generatedAIStructureStates[prop].push(id);
                } else {
                    // Remove the id from the array if it exists
                    const index = self.generatedAIStructureStates[prop].indexOf(id);
                    if (index !== -1) {
                        self.generatedAIStructureStates[prop].splice(index, 1);
                    }
                }
                self.generatedAIStructureInit();
            });
        });
    },
    generatePromptForHTMLbyAI: function(target, states) {
        const self = this;
        target.classList.add('disable');
    
        // Construct the initial description with all the details.
        let description = `Generate HTML structure and CSS and Javascript code based on the following user's request:" + ${states.mainPrompt}`;
        if (states.bemClasses) description += ` For each element, add a class that follows the BEM standards.`;
        if (states.elementsLabels) description += ` For each element, add a data-attribute named 'data-bricks-label' and set a short meaningful value into it - possibly related to the associated class and capitalize the text.`;
        
        // Construct detailed descriptions for each property using the state variables
        let cssDescription = "The CSS code corresponding to the HTML structure. Make it responsive on all devices.";
        let jsDescription = "The JavaScript code corresponding to the HTML structure. If no JavaScript is necessary, return an empty string.";
        if (states.bricksVariables) {
            const vars = self.vueState.globalVariables;
            const cats = self.vueState.globalVariablesCategories.filter(el => states.bricksVariablesArr.includes(el.id));
            let string = '';
            cats.forEach(cat => {
                const filteredVars = vars.filter(el => el.category === cat.id).map(el => `--${el.name}`).join(',');
                string += `category **${cat.name}**:${filteredVars}; `;
            });
            cssDescription  += ` Use the following CSS variables where it makes the most sense: ${string}.`;
        }
    
        if (states.bricksColors) {
            const palettes = self.vueState.colorPalette.filter(el => states.bricksColorsArr.includes(el.id));
            let string = '';
            palettes.forEach(palette => {
                const hasATColors = palette.colors.filter(el => el.hasOwnProperty('rawValue'));
                if (hasATColors.length > 0) {
                    const filteredColors = hasATColors.map(el => `--${el.name}`).join(',');
                    string += `palette **${palette.name}**:${filteredColors}; `;
                }
            });
            cssDescription += ` For the CSS, use the following CSS variables when using a color: ${string}.`;
        }
    
        // First Request: Get the best function description from the "Prompt Engineer".
        const firstRequestBody = {
            model: self.globalSettings.defaultAIModel,
            messages: [
                {
                    role: "system",
                    content: "You are a Prompt Engineer. Your task is to refine and shorten descriptions for OpenAI function calls to make them optimal. It's really important that your refined description doesn't exceed the 1000 strings length limit imposed by OpenAI."
                },
                {
                    role: "user",
                    content: description,
                }
            ]
        };
    
        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce
            },
            success: function(response) {
                const fetchDescription = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization' : 'Bearer ' + response,
                        },
                        body: JSON.stringify(firstRequestBody)
                    });
                    const content = await rawResponse.json();
                    if(content.error){
                        self.insertErrorMessage('brxcGenerateAIStructure', false, '#brxcGenerateAIStructureOverlay', content.error.message);
                        target.classList.remove('disable');
                    } else {
                        const result = content.choices[0].message.content.trim(); // The optimized function description
                        self.generateHTMLAndCSS(target, states, {result: result, css: cssDescription, js: jsDescription}); // Call the second function with the optimized description
                    }
                };
                fetchDescription();
            },
            error: function(response){
                self.vueGlobalProp.$_showMessage('Something went wrong with the OpenAI AJAX request: ' + response);
                target.classList.remove('disable');
            }
        });
    },
    
    generateHTMLAndCSS: function(target, states, obj) {
        const self = this;
        const requestBody = {
            model: self.globalSettings.defaultAIModel,
            messages: [
                {
                    role: "system",
                    content: "You are an expert web designer with advanced knowledge in HTML and CSS. Your job is to generate clean, accessible code for any prompt."
                },
                {
                    role: "user",
                    content: states.mainPrompt,
                }
            ],
            functions: [
                {
                    name: "generateHtmlAndCss",
                    description: obj.result,
                    parameters: {
                        type: "object",
                        properties: {
                            html: {
                                type: "string",
                                description: "The HTML structure for the user's request. Use attributes to make it compliant with accessibility standards."
                            },
                            css: {
                                type: "string",
                                description: obj.css
                            },
                            js: {
                                type: "string",
                                description: obj.js
                            }
                        },
                        required: ["html", "css", 'js']
                    }
                }
            ],
            function_call: { name: "generateHtmlAndCss" }
        };

        jQuery.ajax({
            type: 'POST',
            url: openai_ajax_req.ajax_url,
            data: {
                action: 'openai_ajax_function',
                nonce: openai_ajax_req.nonce
            },
            success: function(response) {
                const fetchDescription = async () => {
                    const rawResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization' : 'Bearer ' + response,
                        },
                        body: JSON.stringify(requestBody)
                    });
                    const content = await rawResponse.json();
                    if(content.error){
                        self.insertErrorMessage('brxcGenerateAIStructure', false, '#brxcGenerateAIStructureOverlay', content.error.message);
                        target.classList.remove('disable');
                    } else {
                        const result = content.choices[0].message;
                        if (result.function_call) {
                            const content = JSON.parse(result.function_call.arguments);
                            const obj = {
                                html: content.html,
                                css: content.css,
                                js: content.js,
                            }
                            self.htmlImporter(obj, states);
                            target.classList.remove('disable');
                            self.closeModal(target, target.target, '#brxcGenerateAIStructureOverlay');
                        }
                    }
                };
                fetchDescription();
            },
            error: function(response){
                self.vueGlobalProp.$_showMessage('Something went wrong with the OpenAI AJAX request: ' + response);
                target.classList.remove('disable');
            }
        });
    },
    remoteTemplatesStates: {
        data: [],
        search: '',
        active: {
            url: bricksData.siteUrl,
            name: "My Templates",
            default: true,
        },
        cats: [],
        activeCat: 'All',
        layout: '2-col',
    },
    openRemoteTemplatesModal: function(firstOpen = true, forceOpen = false){
        const self = this;
        const globalFeatures = self.globalSettings.globalFeatures || [];

        // Close if it exists
        const existing = document.querySelector('#brxcRemoteTemplatesOverlay[data-active=true]');
        if(existing && !forceOpen) {
            self.closeTemplateModal();
            return;
        }
        if(firstOpen) Object.values(globalFeatures).includes('zoom-out') ? self.zoomOut(true) : '';

        // Get data
        const maybeExist = self.remoteTemplatesStates.data.find(el => el && el.url === self.remoteTemplatesStates.active.url);
        if(maybeExist){
            self.renderTemplate();
        } else {
            self.remoteTemplatesStates.active.default === true ? 
            self.getTemplateData() :
            self.getRemoteTemplateData(self.remoteTemplatesStates.active);
        }

        if(firstOpen){
            document.body.setAttribute('data-quick-remote-template', 'true');
            const search = document.querySelector('#brxcRemoteTemplatesUI__panel input[type=search]');
            self.openModal(false, '#brxcRemoteTemplatesOverlay', search, true, 'calc(var(--at-remote-template-margin) - 50px)');
        }
    },
    getRemoteTemplateData: function(active){
        const self = this;
        const loader = document.querySelector('#brxcRemoteTemplatesUI__loader');
        if(loader) loader.classList.add('active');
        const dataObj = {
            action: 'get_remote_templates_data_ajax_function',
            nonce: openai_ajax_req.nonce,
            source: active.url,
        };

        function getTemplateDataByAjax(){
            return new Promise((resolve, reject) => {
                jQuery.ajax({
                    url: openai_ajax_req.ajax_url,
                    data: dataObj,
                    method: "POST",
                    success: function (response) {
                        resolve(
                            self.remoteTemplateProcessResponse(response.data)
                        );
                    },
                    error: function (data) {
                        reject('Something went wrong.');
                    }
                });
            });
        }
        getTemplateDataByAjax()
    
    },
    getTemplateData: function(){
        const self = this;
        const loader = document.querySelector('#brxcRemoteTemplatesUI__loader');
        if(loader) loader.classList.add('active');

        const dataObj = {
            action: 'get_templates_data_ajax_function',
            nonce: openai_ajax_req.nonce,
        };

        function getTemplateDataByAjax(){
            return new Promise((resolve, reject) => {
                jQuery.ajax({
                    url: openai_ajax_req.ajax_url,
                    data: dataObj,
                    method: "POST",
                    success: function (response) {
                        resolve(
                            self.templateProcessResponse(response.data)
                        );
                    },
                    error: function (data) {
                        reject('Something went wrong.');
                    }
                });
            });
        }
        getTemplateDataByAjax()
    
    },
    convertTemplateData: function(target, els, position = false){
        const self = this;
        if(target) target.classList.add('disable');

        const dataObj = {
            action: 'convert_template_data_ajax_function',
            nonce: bricksData.nonce,
            atnonce: openai_ajax_req.nonce,
            importImages: 'true',
            templateData: JSON.stringify(els),
        };

        function convertTemplateDataByAjax(){
                jQuery.ajax({
                    url: openai_ajax_req.ajax_url,
                    data: dataObj,
                    method: "POST",
                    success: function (response) {
                        const contentType = self.helpers.getTemplateType();
                        let content = self.helpers.getContent(true);
                        if(position !== false){
                            self.vueState[contentType] = self.helpers.insertAfterNthParent(
                                content,
                                response.data.elements,
                                position
                            );
                            
                        } else {
                            self.vueState[contentType] = JSON.parse(JSON.stringify(content.concat(response.data.elements)));
                        }
                        if(target) target.classList.remove('disable');
                    },
                    error: function (response) {
                        console.log(response);
                        if(target) target.classList.remove('disable');
                    }
                });
            
        }
        convertTemplateDataByAjax()
    
    },
    saveTemplateData: function(el){
        const self = this;

        const obj = {
            'templateTitle': el.title,
            'templateBundle': el.bundles,
            'templateTags': el.tags,
            'templateType': el.type,
            'content': JSON.stringify(el.content),
        }

        const firstObj = {
            action: 'convert_template_data_ajax_function',
            nonce: bricksData.nonce,
            atnonce: openai_ajax_req.nonce,
            templateData: obj.content,
            importImages: 'true',
        };

        const secondObj = {
            action: 'save_template_data_ajax_function',
            nonce: bricksData.nonce,
            atnonce: openai_ajax_req.nonce,
        }

        function handleGlobalClasses(obj) {
            if (obj.hasOwnProperty('global_classes') && Array.isArray(obj.global_classes)) {
                obj.global_classes.forEach(cls => {
                    if (!self.vueState.globalClasses.some(el => el.id === cls.id)) {
                        self.vueState.globalClasses.push(cls);
                    }
                });
            }
        }

        function saveTemplateDataByAjax(ajaxObj, firstRun){
                jQuery.ajax({
                    url: openai_ajax_req.ajax_url,
                    data: ajaxObj,
                    method: "POST",
                    success: function (response) {
                        if(firstRun){
                            obj.content = response.data.elements;
                            secondObj.templateData = JSON.stringify(obj);
                            saveTemplateDataByAjax(secondObj, false)
                        } else{
                            handleGlobalClasses(el);
                            self.helpers.saveChanges('globalClasses');
                            self.helpers.saveChanges('globalClassesLocked');
                            self.vueGlobalProp.$_savePost();
                            self.vueGlobalProp.$_showMessage(`'${obj.templateTitle}' has been saved in My Templates!`);
                        }
                    },
                    error: function (response) {
                        console.log(response);
                    }
                });
            
        }
        saveTemplateDataByAjax(firstObj, true)
    
    },
    remoteTemplateProcessResponse: function(data){
        const self = this;
        if(typeof data.timestamp === 'number'){
            data.url = self.remoteTemplatesStates.active.url;
            data.default = false;
            if(self.remoteTemplatesStates.active.name) data.name = self.remoteTemplatesStates.active.name;
            self.remoteTemplatesStates.data.push(data);
            self.renderTemplate();
        }
    },
    templateProcessResponse: function(data){
        const self = this;
        if(Array.isArray(data)){
            const obj = [];
            obj.url = bricksData.siteUrl;
            obj.name = 'My Templates';
            obj.default = true;
            obj.templates = data;
            obj.bundles = Object.fromEntries([...new Set(data.flatMap(el => el.bundles))].map(tag => [tag, tag]));

            self.remoteTemplatesStates.data.push(obj);
            self.renderTemplate();
        }
    },
    renderTemplate: function(){
        const self = this;
        const loader = document.querySelector('#brxcRemoteTemplatesUI__loader');
        self.remoteTemplateHeader();
        self.remoteTemplateCats();
        self.remoteTemplatePanel();
        if(loader) loader.classList.remove('active');
    },
    remoteTemplateHeader: function(){
        const self = this;
        const canvas = document.querySelector("#brxcRemoteTemplatesUI__header");
        if(!canvas) return;

        const activeData = self.remoteTemplatesStates.data.find(el => el && el.url === self.remoteTemplatesStates.active.url);
        if(!activeData) return;

        let content = '<div id="brxcRemoteTemplateHeaderWrapper">';

        const sources = [{name:'My Templates', url: bricksData.siteUrl},{name:"Community Templates", url: "https://bricksbuilder.io/"}].concat(bricksData.remoteTemplateSettings.filter(el => el.hasOwnProperty('url') && el.url !== "https://bricksbuilder.io/"))

        sources.forEach(el => {
            content += `<div class="brxc-overlay__action-btn${el.url === activeData.url ? ' primary' : ' secondary'}" data-url="${el.url}">${el.name ? el.name : el.url}</div>`
        })
        content += `<div class="brxc-overlay__action-btn ${self.remoteTemplatesStates.layout === "1-col" ? 'primary' : 'secondary'} layout" data-balloon="1-col" data-balloon-pos="left"><span class="bricks-svg-wrapper"><i class="ti-layout-column3-alt"></i></span></div>`;
        content += `<div class="brxc-overlay__action-btn ${self.remoteTemplatesStates.layout === "2-col" ? 'primary' : 'secondary'} layout" data-balloon="2-col" data-balloon-pos="left"><span class="bricks-svg-wrapper"><i class="ti-layout-column2-alt"></i></span></div>`;
        content += '</div>';

        canvas.innerHTML = content;

        // Listeners
        const wrapper = canvas.querySelector('#brxcRemoteTemplateHeaderWrapper');
        wrapper.addEventListener('click', (e) => {
            // Change source
            self.remoteTemplatesStates.activeCat = "All";
            const item = e.target.closest('[data-url]');
            if(item) {
                self.remoteTemplatesStates.activeCat = "All";
                self.remoteTemplatesStates.active = sources.find(el => el.url === item.dataset.url);
                self.openRemoteTemplatesModal(false, true);
            };

            // Set cols
            const layoutBtn = e.target.closest('.brxc-overlay__action-btn.layout');
            if(layoutBtn){
                self.remoteTemplatesStates.layout = layoutBtn.dataset.balloon;
                self.remoteTemplateHeader();
                self.remoteTemplatePanel();
            }
        })
    },
    remoteTemplateCats: function(){
        const self = this;
        const canvas = document.querySelector('#brxcRemoteTemplatesUI__cat-canvas');
        if(!canvas) return;

        const activeData = self.remoteTemplatesStates.data.find(el => el && el.url === self.remoteTemplatesStates.active.url);
        if(!activeData) return;

        let count = 0;

        function isActive (cat) {
            if(cat === self.remoteTemplatesStates.activeCat) return true;
            return false;
        }

        let content = '<ul>';

        // All
        count = activeData.templates.length;
        content += `<li class="${self.remoteTemplatesStates.activeCat === "All" ? 'active' : ''}"${self.remoteTemplatesStates.activeCat === "All" ? ' data-active="true"' : ''} data-id="All" onClick="ADMINBRXC.remoteTemplatesFilterCat(event)"><input type="text" value="All" readonly/><span class="count">${count}</span></li>`
        
        // Categories
        for (const [key, value] of Object.entries(activeData.bundles)){
            const keys = Object.keys(activeData.bundles);
            count = Array.from(activeData.templates).filter(el => el && el.bundles.includes(key)).length;
            content += `<li class="${isActive(key) ? 'active' : ''}"${isActive(key) ? ' data-active="true"' : ''} data-id="${key}" onClick="ADMINBRXC.remoteTemplatesFilterCat(event)"><input type="text" value="${value}" readonly/><span class="count">${count}</span></li>`
        }
            
        content += '</ul>';
        canvas.innerHTML = content;
    },
    remoteTemplatesFilterCat: function(item){
        const self = this;
        self.remoteTemplatesStates.activeCat = item.target.dataset.id;
        self.renderTemplate();
    },
    remoteTemplatePanel: function (target = false) {
        const self = this;
    
        if (target) clearSearchInput(target);
    
        const canvas = document.querySelector('#brxcRemoteTemplatesUI__panel-canvas');
        const activeData = getActiveData();
        if (!activeData) return;
    
        let templates = filterTemplates(activeData.templates);
    
        renderTemplates(canvas, templates);
    
        const wrapper = canvas.querySelector('#brxcRemoteTemplatesPanelWrapper');
        if (wrapper) initializeWrapperSortable(wrapper, activeData);
        
        function clearSearchInput(target) {
            target.parentElement.querySelector('input').value = '';
        }
    
        function getActiveData() {
            return self.remoteTemplatesStates.data.find(el => el && el.url === self.remoteTemplatesStates.active.url);
        }
    
        function filterTemplates(templates) {
            if (self.remoteTemplatesStates.activeCat !== "All") {
                templates = templates.filter(el => el.bundles.includes(self.remoteTemplatesStates.activeCat));
            }
            if (self.remoteTemplatesStates.search !== "") {
                templates = templates.filter(el => el.title.toLowerCase().includes(self.remoteTemplatesStates.search.toLowerCase()));
            }
            return templates;
        }

        function isMyTemplate(){
            return self.remoteTemplatesStates.active.url === bricksData.siteUrl;
        }
    
        function renderTemplates(canvas, templates) {
            const placeholderImg = self.globalSettings.placeholderImg;
            let content = '';
    
            if (templates.length > 0) {
                content = templates.map(template => {
                    const img = template.thumbnail || placeholderImg;
                    return `<div data-id="${template.id}">
                                <div class="brxc-template__img-wrapper">
                                    <img src="${img}" loading="lazy"/>
                                </div>
                                <div class="brxc-template-footer">
                                    <div class="brxc-template-footer__label">
                                        <span>${template.title}</span>
                                        ${!isMyTemplate() ? `<span class="bricks-svg-wrapper save-template" data-balloon="Save in My Templates" data-balloon-pos="top-right"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="bricks-svg"><path d="M21.75 23.25H2.25a1.5 1.5 0 0 1 -1.5 -1.5V7.243a3 3 0 0 1 0.879 -2.121l3.492 -3.493A3 3 0 0 1 7.243 0.75H21.75a1.5 1.5 0 0 1 1.5 1.5v19.5a1.5 1.5 0 0 1 -1.5 1.5Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M9.75 12.75a3 3 0 1 0 6 0 3 3 0 1 0 -6 0Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="m12.75 20.25 6.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M8.25 0.75v3a1.5 1.5 0 0 0 1.5 1.5h7.5a1.5 1.5 0 0 0 1.5 -1.5v-3" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></span>` : ''}
                                    </div>
                                </div>
                            </div>`;
                }).join('');
                content = `<div id="brxcRemoteTemplatesPanelWrapper" class="layout-${self.remoteTemplatesStates.layout}">${content}</div>`;
            } else {
                content = renderNoResults();
            }
    
            canvas.innerHTML = content;
        }
    
        function renderNoResults() {
            return `<div class="notification">
                        <span class="bricks-svg-wrapper" data-name="no-results">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="bricks-svg">
                                <path d="M0.75 12a11.25 11.25 0 1 0 22.5 0 11.25 11.25 0 1 0 -22.5 0Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path>
                                <path d="M15.665 18.75a0.76 0.76 0 0 0 0.744 -0.9 4.5 4.5 0 0 0 -8.818 0 0.759 0.759 0 0 0 0.744 0.9Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path>
                                <path d="m6.75 6.75 3 3 -3.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path>
                                <path d="m17.25 6.75 -3 3 3.75 0" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"></path>
                            </svg>
                        </span>
                        <div class="message"><p>No templates found.</p></div>
                    </div>`;
        }
    
        function initializeWrapperSortable(wrapper, activeData) {
            let targetSortable;
    
            new Sortable(wrapper, {
                group: {
                    name: 'shared',
                    put: false,
                    pull: 'clone',
                },
                selectedClass: "sortable-selected",
                handle: ".brxc-template__img-wrapper",
                animation: 150,
                helper: 'clone',
                filter: ".no-handle",
                onStart: () => initializeTargetSortable(),
                onEnd: (evt) => handleDragEnd(evt, activeData, targetSortable),
            });
    
            wrapper.addEventListener('click', (e) => handleTemplateClick(e, activeData));
        }
    
        function initializeTargetSortable() {
            const target = FRAMEBRXC.content.body.querySelector('main#brx-content');
            targetSortable = new Sortable(target, {
                group: 'shared',
                pull: 'clone',
                selectedClass: "sortable-selected",
                animation: 150,
                helper: 'clone',
                filter: ".no-handle",
            });
        }
    
        function handleDragEnd(evt, activeData, targetSortable) {
            const rootPosition = evt.newIndex;
            const items = FRAMEBRXC.content.body.querySelectorAll('main#brx-content > *');
            const newItem = items[rootPosition];
            const obj = activeData.templates.find(el => el.id === parseInt(newItem.dataset.id));
            const target = document.querySelector(`#brxcRemoteTemplatesPanelWrapper [data-id="${newItem.dataset.id}"]`) ?? false;
    
            newItem.remove();
            handleGlobalClasses(obj);
            self.convertTemplateData(target, obj.content, rootPosition);
            refocusSearch();
    
            if (targetSortable) {
                targetSortable.destroy();
                targetSortable = null;
            }
        }
    
        function handleGlobalClasses(obj) {
            if (obj.hasOwnProperty('global_classes') && Array.isArray(obj.global_classes)) {
                obj.global_classes.forEach(cls => {
                    if (!self.vueState.globalClasses.some(el => el.id === cls.id)) {
                        self.vueState.globalClasses.push(cls);
                    }
                });
            }
        }
    
        function refocusSearch() {
            const search = document.querySelector('#brxcRemoteTemplatesUI__panel input[type=search]');
            if (search) {
                search.focus();
                search.setSelectionRange(0, search.value.length);
            }
        }
    
        function handleTemplateClick(e, activeData) {
            const target = e.target;
            const item = target.closest('[data-id]');
            if (!item) {
                console.log('[data-id] not found in Remote Template modal.');
                return;
            }
            const obj = activeData.templates.find(el => el.id === parseInt(item.dataset.id));

            if(target.classList.contains('save-template')){
                self.saveTemplateData(obj);
                refocusSearch();
            } else {
                handleGlobalClasses(obj);
                self.convertTemplateData(item, obj.content);
                refocusSearch();
            }
        }
    },
    zoomOutStates: {
        scaleActive: true,
        previous: 1,
        active: false,
    },
    zoomOut: function(forceOpen = false, forceClose = false){
        const self = this;
        const target = document.querySelector('#bricks-toolbar li.zoom-out')
        const icon = target.querySelector('i');
        if(!self.zoomOutStates.active) self.zoomOutStates.previous = self.vueState.previewScaleMax;
        if(!self.zoomOutStates.active) self.zoomOutStates.scaleActive = ADMINBRXC.vueState.previewScaleActive
        self.zoomOutStates.active = !self.zoomOutStates.active;
        if(self.zoomOutStates.active || forceOpen === true){
            ADMINBRXC.vueState.previewScaleActive = true;
            self.vueState.previewScaleMax = self.globalSettings.topbarDefaultZoomOut;
            icon.className = 'bricks-svg fas ti-zoom-in';
            target.classList.add('enabled');
            FRAMEBRXC.content.body.setAttribute('data-zoom-out', 'true');
            FRAMEBRXC.content.body.querySelectorAll('.brx-draggable').forEach(el => {
                el.classList.remove('brx-draggable');
            })
        } else{
            ADMINBRXC.vueState.previewScaleActive = self.zoomOutStates.scaleActive
            self.vueState.previewScaleMax = self.zoomOutStates.previous;
            icon.className = 'bricks-svg ti-zoom-out';
            target.classList.remove('enabled');
            FRAMEBRXC.content.body.removeAttribute('data-zoom-out');
        }
    },
    zoomOutRemoveDraggable: function(){
        const self = this;
        if(!self.zoomOutStates.active) return;
        FRAMEBRXC.content.body.querySelectorAll('.brx-draggable').forEach(el => {
            el.classList.remove('brx-draggable');
        })
    },
    colorControls: function(){
        const self = this;
        self.vue._context.components['control-color'].data = function() {
            return {
                changed: !1,
                showPopup: !1,
                storedColor: void 0,
                randomId: this.$_generateId(),
                colorMode: "raw",
                deleteColor: !1,
                editColorIndex: !1,
                inputSaturationStyles: null,
                inputLightnessStyles: null,
                inputAlphaStyles: null,
                inputRaw: null,
                inputHex: null,
                inputHue: 0,
                inputSaturation: 100,
                inputLightness: 50,
                inputRed: 0,
                inputGreen: 0,
                inputBlue: 0,
                inputAlpha: 1,
                placeholderRaw: "",
                activePaletteId: void 0,
                paletteAction: void 0,
                paletteName: "",
                colorName: "",
                colorsView: "list",
                importResults: [],
                colorsFromRaw: {},
                isPopulatingFromRaw: !1
            }
        }
    },
    spacingControls: function(value){
        const self = this;
        self.vue._context.components['control-spacing'].data = function() {
            var e, t;
            let state = value;

            if ("linkedIcon" in this.control && !this.control.linkedIcon) {
                state = "unlinked";
            } else if ("linkOpposites" in this.control && !this.control.linkOpposites) {
                state = value === "opposites" ? "unlinked" : "all";
            }
            return {
                variablesEnabled: !this.bricks.disableVariablesManager,
                directions: null !== (e = this.control) && void 0 !== e && e.directions ? Object.keys(this.control.directions) : ["top", "right", "bottom", "left"],
                focus: "",
                label: "",
                linkState: state,
                linkOpposites: !this.control.hasOwnProperty("linkOpposites") || this.control.linkOpposites,
                linkedIcon: !this.control.hasOwnProperty("linkedIcon") || this.control.linkedIcon,
                property: null === (t = this.control) || void 0 === t || null === (t = t.css) || void 0 === t || null === (t = t[0]) || void 0 === t ? void 0 : t.property
            }
        }
    },
    iconControlsSVG: function(){
        const self = this;
        if(!bricksData.loadData.userCan.uploadSvg) return;

        self.vue._context.components['control-icon'].data = function() {
            var e;
            return {
                showPopup: !1,
                library: 'svg',
                searchFor: "",
                libraries: {
                    placeholder: this.i18n.selectLibrary,
                    options: {
                        fontawesomeBrands: "Fontawesome - Brands",
                        fontawesomeRegular: "Fontawesome - Regular",
                        fontawesomeSolid: "Fontawesome - Solid",
                        ionicons: "Ionicons",
                        themify: "Themify"
                    }
                },
                icons: {
                    fontawesomeBrands: {},
                    fontawesomeRegular: {},
                    fontawesomeSolid: {},
                    fontawesome: {},
                    ionicons: {},
                    themify: {}
                }
            }
        }
    },
    iconControls: function(){
        const self = this;
        if(!bricksData.loadData.userCan.uploadSvg) return;

        self.vue._context.components['control-icon'].data = function() {
            var e;
            return {
                showPopup: !1,
                library: 'svg',
                searchFor: "",
                libraries: {
                    placeholder: this.i18n.selectLibrary,
                    options: {
                    }
                },
                icons: {
                    fontawesomeBrands: {},
                    fontawesomeRegular: {},
                    fontawesomeSolid: {},
                    fontawesome: {},
                    ionicons: {},
                    themify: {}
                }
            }
        }
    },
    setSearchStructure: function(){
        const self = this;
        const structure = document.querySelector('#bricks-structure > main');
        if (!structure) return;
    
        const existing = structure.querySelector('#brxcSearchStructureWrapper');
        if (existing) existing.remove();
    

        const search = document.createElement('DIV');
        search.id = 'brxcSearchStructureWrapper';
        search.setAttribute('class', 'brxc-overlay__search-box');
        search.innerHTML = `<input id= "brxcSearchStructure"type="search" class="iso-search" name="dynamic-data-search" placeholder="Search by element name, label, global class, CSS ID, etc...">
                            <div class="iso-search-icon">
                                <i class="bricks-svg ti-search"></i>
                            </div>
                            <div class="iso-reset" data-balloon="Reset" data-balloon-pos="left" onclick="this.previousElementSibling.previousElementSibling.value = '';ADMINBRXC.searchStructure('');">
                                <i class="bricks-svg fas fa-undo"></i>
                            </div>`;

    
        structure.insertBefore(search, structure.firstChild);

        // Listeners

        const input = search.querySelector('input');
        if(input){
            input.addEventListener('input', (e) => {
                self.searchStructure(e.target.value);
            })
        }
    },
    searchStructure: function(keyword){
        const self = this;

        const structure = document.querySelector('#bricks-structure');
        if(!structure) return;

        const elements = structure.querySelectorAll('.element[data-id]');
        if(elements.length < 1) return;

        if(keyword === '') {
            structure.removeAttribute('data-is-searching');
            elements.forEach(el => {el.removeAttribute('data-search-active')})
            return;
        }
        
        structure.setAttribute('data-is-searching', 'true');
        const searchTerm = keyword.toLowerCase();

        function isVisible(id){
            const obj = self.helpers.getElementObject(id)
            const elementObj = self.vueGlobalProp.$_getElementConfig(obj.name);
            const nameMatch = elementObj.label.toLowerCase().includes(searchTerm);
            const labelMatch = obj.label ? obj.label.toLowerCase().includes(searchTerm) : false;
            const globalClassMatch = obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('_cssGlobalClasses') ? obj.settings._cssGlobalClasses.some(el => self.vueGlobalProp.$_getGlobalClass(el)?.name.toLowerCase().includes(searchTerm)) : false;
            const textMatch = obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('text') ? obj.settings.text.toLowerCase().includes(searchTerm) : false;
            const idMatch = obj.id.toLowerCase().includes(searchTerm);
            const cssIdMatch = obj.hasOwnProperty('settings') && obj.settings.hasOwnProperty('_cssId') ? obj.settings._cssId.toLowerCase().includes(searchTerm) : false;
            return nameMatch || labelMatch || globalClassMatch|| textMatch || idMatch || cssIdMatch;

        }

        elements.forEach(el => {
            const elId = el.dataset.id;
            if(isVisible(elId)){
                el.setAttribute('data-search-active', 'true');
            } else {
                el.removeAttribute('data-search-active');
            }
        })
    },
    delaySaveBtn: function(){
        const self = this;
        const btn = document.querySelector('#bricks-toolbar li.save');
        if(!btn) return;

        btn.addEventListener('click', (e) => {
            setTimeout(() => {
                self.vueGlobalProp.$_savePost({
                    skipNotifications: !0
                })
            },350)
        })
    },
    

    init: function(){
        const self = this;
        self.vueState.brxc = [];

        // Global Classes
        self.handleGlobalClassesOnLoad();

        // States
        self.initStates();
    
        // Observers
        self.initObservers();
        self.initContextualMenuObservers();

        // Functions
        self.setColorVariablesOnLoad();
        self.generateVariableCSS('global');
        self.generateVariableCSS('theme');
        self.generateBuilderCSS();
        self.setIsotope('body');
        self.setCodeMirror();
        self.setControlsOptions();
        self.toggleRadioVisibility();
        self.setAlertMsg();
        self.hideEmptyElementCategory();

        // AI
        (self.helpers.isAIActive()) ? self.initAcc('.accordion.v1', true) : '';

        // Classes & Styles
        self.helpers.isClassesAndStylesTabActive() && self.globalSettings.generalCats.classesAndStyles.includes('class-importer') ? self.importedClasses() : '';
        self.helpers.isClassesAndStylesTabActive() && self.globalSettings.generalCats.classesAndStyles.includes('grids') ? self.importedGrids() : '';


        // Builder Tweaks
        //// Topbar
        if(self.helpers.isBuilderTweaksTabActive('global-features')){
            self.initGridGuide();
            if(Object.values(self.globalSettings.globalFeatures).includes('responsive-helper')){
                self.setResponsiveBar();
                setTimeout(() => {document.querySelector('#bricks-toolbar li.responsive-helper').click()}, 500)
            }
            self.populateClassCategories();
        }

        //// Structure Panels
        if(self.helpers.isBuilderTweaksTabActive('structure-panel')){
            self.setLockElements();
            (self.globalSettings.structurePanelContextualMenu.length > 0) ? self.setContextualMenuItems() : '';
            (self.globalSettings.structurePanelIcons.length > 0) ? self.setHeaderStructurePanel() : '';
            self.setRightShortcutCol();
            Object.values(self.globalSettings.structurePanelGeneralTweaks).includes('styles-and-classes-indicators') ? self.setColorsforStructureIndicators() : '';
            Object.values(self.globalSettings.structurePanelGeneralTweaks).includes("highlight-nestable-elements") ? self.populateNestableElements() : '';
            Object.values(self.globalSettings.structurePanelGeneralTweaks).includes('draggable-structure-panel') ? self.draggableStructurePanel() : '';
            Object.values(self.globalSettings.structurePanelGeneralTweaks).includes('focus-mode') ? self.setFocusModeListener() : '';
            Object.values(self.globalSettings.structurePanelGeneralTweaks).includes('filterable-structure') ? self.setSearchStructure() : '';
            //Object.values(self.globalSettings.structurePanelGeneralTweaks).includes('multiselect') ? self.setMultiSelect() : '';
        } 

        //// Classes and Styles
        if(self.helpers.isBuilderTweaksTabActive('classes-and-styles')){
            Object.values(self.globalSettings.classFeatures).includes("disable-id-styles") ? document.body.setAttribute('data-disable-styles', "true") : '';
            Object.values(self.globalSettings.classFeatures).includes("reorder-classes") ? self.reorderClasses() : '';
            Object.values(self.globalSettings.classFeatures).includes("group-classes-by-lock-status") ? self.groupClassesByLockStatus() : '';
            Object.values(self.globalSettings.classFeatures).includes("locked-class-indicator") ? document.body.setAttribute('data-locked-classes', "true") : '';
            if (Object.values(self.globalSettings.classFeatures).includes("autocomplete-variable") ){
                self.populateCSSVariables();
                document.body.setAttribute('data-variable-autocomplete', "true");
            }
            Object.values(self.globalSettings.classFeatures).includes("scoped-variables") ? self.scopedVariablesCSS() : '';
            if(Object.values(self.globalSettings.classFeatures).includes("variable-picker")) {
                document.body.setAttribute('data-variable-picker', 'true');
            }
        }

        //// Elements
        if(self.helpers.isBuilderTweaksTabActive('elements')){
            Object.values(self.globalSettings.elementFeatures).includes("pseudo-shortcut") ? self.setDefaultPseudoClasses() : '';
            if(Object.values(self.globalSettings.elementFeatures).includes("resize-elements-icons")) {
                self.setElementsColumns();
                self.setColumnNumber(self.globalSettings.defaultElementsCol);
            }
            if(Object.values(self.globalSettings.elementFeatures).includes("superpower-custom-css")) {
                document.body.setAttribute('data-superpower-css', 'true');
                //self.delaySaveBtn();
            }
            if(Object.values(self.globalSettings.elementFeatures).includes("expand-spacing")) {
                document.body.setAttribute('data-expand-spacing', 'true');
            }
            if(Object.values(self.globalSettings.elementFeatures).includes("hide-inactive-accordion-panel")) {
                document.body.setAttribute('data-hide-inactive-panels', 'true');
            }
            if(Object.values(self.globalSettings.elementFeatures).includes("dynamic-data-modal")) {
                document.body.setAttribute('data-dynamic-data-modal', 'true');
            }
            if(Object.values(self.globalSettings.elementFeatures).includes("link-spacing")){
                self.spacingControls(self.globalSettings.linkSpacingDefault);
            }
            if(Object.values(self.globalSettings.elementFeatures).includes("color-default-raw")){
                self.colorControls();
            }
            if(Object.values(self.globalSettings.defaultElementFeatures).includes("icon-svg")){
                self.iconControlsSVG();
            }
            if(Object.values(self.globalSettings.defaultElementFeatures).includes("remove-icon-library-options")){
                self.iconControls();
            }
            Object.values(self.globalSettings.defaultElementFeatures.length > 0) ? self.setDefaultElements() : '';
            
        }

        //// Keyboard Shortcuts
        if(self.helpers.isBuilderTweaksTabActive('keyboard-shortcuts')){
            Object.values(self.globalSettings.keyboardShortcuts.options).includes("move-element") ?self.setStructurePanelKeyboardShortcuts() : '';
            Object.values(self.globalSettings.keyboardShortcuts.options).includes("open-at-modal") ? self.setKeyboardShortcuts() : '';
            self.setGlobalKeyboardsh();
        }


        //// Run state functions
       self.runStateFunctions();
       self.setCodepenImporter();

    }
}
//ADMINBRXC.initPageCSS()
window.addEventListener('DOMContentLoaded', () => {
    ADMINBRXC.initToolbar();
})
window.addEventListener('load', () => {
        // Init
    ADMINBRXC.init()
    document.querySelectorAll('.brxc-overlay__wrapper').forEach(el => el.removeAttribute('style'));
    (ADMINBRXC.helpers.isBuilderTweaksTabActive() && Object.values(ADMINBRXC.globalSettings.elementShortcutIcons).includes("tabs-shortcuts")) ? document.body.setAttribute('data-has-panel-shortcuts','true') : '';

    //FRAME
    FRAMEBRXC.content = document.querySelector('#bricks-builder-iframe').contentDocument;
    FRAMEBRXC.vue = document.querySelector('#bricks-builder-iframe').contentDocument.querySelector('.brx-body').__vue_app__;
    FRAMEBRXC.vueGlobalProp = document.querySelector('#bricks-builder-iframe').contentDocument.querySelector('.brx-body').__vue_app__.config.globalProperties;
    FRAMEBRXC.vueState = document.querySelector('#bricks-builder-iframe').contentDocument.querySelector('.brx-body').__vue_app__.config.globalProperties.$_state;
    ADMINBRXC.selectorPickerInit();
})

// ADMINBRXC.vue._context.components['control-gradient'].data